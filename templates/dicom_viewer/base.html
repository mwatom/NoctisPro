<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DICOM Viewer</title>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
  <style>
    body { margin: 0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; background: #1a1a1a; color: #fff; }
    .layout { display: grid; grid-template-columns: 80px 1fr 300px; grid-template-rows: 60px 1fr; height: 100vh; }
    .toolbar { grid-row: 1 / span 2; grid-column: 1; background: #2a2a2a; border-right: 1px solid #444; padding: 8px 6px; display: flex; flex-direction: column; gap: 6px; }
    .tool { width: 66px; height: 56px; background: #3a3a3a; border: none; border-radius: 8px; color: #fff; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 11px; }
    .tool.active { background: #0078d4; }
    .tool i { font-size: 18px; margin-bottom: 4px; }
    .topbar { grid-row: 1; grid-column: 2 / span 2; display: flex; align-items: center; gap: 12px; padding: 0 16px; background: #2a2a2a; border-bottom: 1px solid #444; }
    .btn { padding: 8px 12px; border: none; border-radius: 6px; cursor: pointer; font-size: 13px; }
    .btn-primary { background: #0078d4; color: #fff; }
    .select { padding: 8px 10px; background: #3a3a3a; border: 1px solid #555; border-radius: 6px; color: #fff; min-width: 220px; }
    .viewport { grid-row: 2; grid-column: 2; background: #000; position: relative; display: flex; align-items: center; justify-content: center; }
    .right { grid-row: 2; grid-column: 3; background: #2a2a2a; border-left: 1px solid #444; padding: 16px; overflow: auto; }
    .panel { margin-bottom: 18px; }
    .panel h3 { font-size: 15px; margin: 0 0 10px; padding-bottom: 8px; border-bottom: 1px solid #444; }
    .control { margin-bottom: 12px; }
    .control .label { display: flex; justify-content: space-between; font-size: 12px; color: #ccc; margin-bottom: 6px; }
    input[type=range] { width: 100%; }
    .overlay { position: absolute; top: 12px; left: 12px; background: rgba(0,0,0,0.6); padding: 8px 10px; border-radius: 6px; font-family: monospace; font-size: 12px; }
    .zoominfo { position: absolute; bottom: 12px; left: 12px; background: rgba(0,0,0,0.6); padding: 6px 10px; border-radius: 6px; font-family: monospace; font-size: 12px; }
    canvas { max-width: 100%; max-height: 100%; image-rendering: pixelated; image-rendering: crisp-edges; }
    .thumbs { display:grid; grid-template-columns: 1fr 1fr; gap:8px; }
    .thumbs img { width:100%; background:#000; border-radius:6px; border:1px solid #444; }
    .row-3 { display:grid; grid-template-columns: 1fr 1fr 1fr; gap:8px; }
    .muted { color:#bbb; font-size:12px; }
    /* 3D dropdown in toolbar */
    .tool-dropdown { position: relative; }
    .tool-dropdown-menu { position: absolute; top: 58px; left: 0; background: #2f2f2f; border: 1px solid #444; border-radius: 8px; width: 180px; display: none; flex-direction: column; overflow: hidden; z-index: 10; }
    .tool-dropdown-menu button { background: transparent; border: none; color: #fff; text-align: left; padding: 10px 12px; cursor: pointer; font-size: 13px; }
    .tool-dropdown-menu button:hover { background: #0078d4; }
  </style>
</head>
<body>
  <div class="layout">
    <div class="toolbar">
      <button class="tool active" data-tool="window"><i class="fas fa-adjust"></i><span>Window</span></button>
      <button class="tool" data-tool="zoom"><i class="fas fa-search-plus"></i><span>Zoom</span></button>
      <button class="tool" data-tool="pan"><i class="fas fa-arrows-alt"></i><span>Pan</span></button>
      <button class="tool" data-tool="measure"><i class="fas fa-ruler"></i><span>Measure</span></button>
      <button class="tool" data-tool="annotate"><i class="fas fa-comment-dots"></i><span>Annotate</span></button>
      <button class="tool" data-tool="crosshair"><i class="fas fa-crosshairs"></i><span>Crosshair</span></button>
      <button class="tool" data-tool="hu"><i class="fas fa-thermometer-half"></i><span>HU</span></button>
      <button class="tool" data-tool="invert"><i class="fas fa-adjust"></i><span>Invert</span></button>
      <button class="tool" data-tool="reset"><i class="fas fa-undo"></i><span>Reset</span></button>
      <button class="tool" data-tool="ai"><i class="fas fa-robot"></i><span>AI</span></button>
      <!-- 3D dropdown moved into toolbar -->
      <div class="tool-dropdown">
        <button id="btn3D" class="tool"><i class="fas fa-cube"></i><span>3D</span></button>
        <div id="menu3D" class="tool-dropdown-menu">
          <button data-recon="mpr"><i class="fas fa-layer-group"></i> MPR</button>
          <button data-recon="mip"><i class="fas fa-bullseye"></i> MIP</button>
          <button data-recon="bone"><i class="fas fa-bone"></i> Bone</button>
        </div>
      </div>
    </div>
    <div class="topbar">
      <button id="btnLoadLocal" class="btn btn-primary"><i class="fas fa-folder-open"></i> Load Local DICOM</button>
      <button id="btnBackWorklist" class="btn" onclick="window.location.href='{% url 'worklist:dashboard' %}'"><i class="fas fa-arrow-left"></i> Back to Worklist</button>
      {% if user.is_authenticated and user.can_edit_reports %}
      <button id="btnWriteReport" class="btn btn-primary" style="display:none"><i class="fas fa-file-signature"></i> Write Report</button>
      {% endif %}
      <input id="localDicom" type="file" multiple webkitdirectory directory accept=".dcm,.dicom,application/dicom" style="display:none" />
      <select id="seriesSelect" class="select"><option value="">Select Series</option></select>
      <div id="patientInfo" style="margin-left:auto;color:#ccc;font-size:13px;">Patient: - | Study Date: - | Modality: -</div>
    </div>
    <div class="viewport" id="viewport">
      <canvas id="dicomCanvas"></canvas>
      <div class="overlay" id="overlay">WW: 400<br>WL: 40<br>Slice: 1/1</div>
      <div class="zoominfo" id="zoominfo">Zoom: 100%</div>
    </div>
    <div class="right">
      <div class="panel">
        <h3>Window/Level</h3>
        <div class="control"><div class="label"><span>Window Width</span><span id="wwVal">400</span></div><input id="ww" type="range" min="1" max="4000" value="400"></div>
        <div class="control"><div class="label"><span>Window Level</span><span id="wlVal">40</span></div><input id="wl" type="range" min="-1000" max="1000" value="40"></div>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;">
          <button class="btn" data-preset="lung">Lung</button>
          <button class="btn" data-preset="bone">Bone</button>
          <button class="btn" data-preset="soft">Soft</button>
          <button class="btn" data-preset="brain">Brain</button>
        </div>
      </div>
      <div class="panel">
        <h3>Navigation</h3>
        <div class="control"><div class="label"><span>Slice</span><span id="sliceVal">1</span></div><input id="slice" type="range" min="0" max="0" value="0"></div>
      </div>
      <div class="panel">
        <h3>Transform</h3>
        <div class="control"><div class="label"><span>Zoom</span><span id="zoomVal">100%</span></div><input id="zoom" type="range" min="25" max="500" value="100"></div>
      </div>
      <div class="panel">
        <h3>3D Reconstruction</h3>
        <div class="control">
          <div class="label"><span>Type</span></div>
          <select id="reconType" class="select">
            <option value="mpr">MPR (Axial/Sagittal/Coronal)</option>
            <option value="mip">MIP (Max Intensity)</option>
            <option value="bone">Bone 3D (threshold)</option>
          </select>
        </div>
        <div class="control" id="boneCtrl" style="display:none;">
          <div class="label"><span>Bone Threshold (HU)</span><span id="boneVal">300</span></div>
          <input id="boneThreshold" type="range" min="100" max="1500" value="300">
        </div>
        <div class="control">
          <button id="btnGenerateRecon" class="btn btn-primary"><i class="fas fa-cogs"></i> Generate</button>
        </div>
        <div class="muted" id="reconStatus"></div>
        <div class="row-3" id="reconViews" style="margin-top:8px; display:none;">
          <img id="viewAxial" alt="Axial"/>
          <img id="viewSagittal" alt="Sagittal"/>
          <img id="viewCoronal" alt="Coronal"/>
        </div>
      </div>
      <div class="panel">
        <h3>Image Info</h3>
        <div id="dimInfo" style="color:#ccc;font-size:12px;">Dimensions: -</div>
        <div id="spacingInfo" style="color:#ccc;font-size:12px;">Pixel Spacing: -</div>
        <div id="seriesInfo" style="color:#ccc;font-size:12px;">Series: -</div>
        <div id="institutionInfo" style="color:#ccc;font-size:12px;">Institution: -</div>
        <div id="clinicalInfo" style="color:#ccc;font-size:12px; margin-top:8px; white-space:pre-wrap;">Clinical Info: -</div>
        <div id="priorityInfo" style="color:#ccc;font-size:12px;">Priority: -</div>
      </div>
      <div class="panel">
        <h3>Measurements</h3>
        <div class="control">
          <button id="btnClearMeasurements" class="btn">Clear All</button>
        </div>
        <ul id="measurementsList" style="list-style:none;padding-left:0;margin:0;color:#ddd;font-size:12px;"></ul>
      </div>
    </div>
  </div>

  <script>
  (function(){
    const canvas = document.getElementById('dicomCanvas');
    const ctx = canvas.getContext('2d');
    const seriesSelect = document.getElementById('seriesSelect');
    const wwSlider = document.getElementById('ww');
    const wlSlider = document.getElementById('wl');
    const sliceSlider = document.getElementById('slice');
    const zoomSlider = document.getElementById('zoom');
    const btnLoadLocal = document.getElementById('btnLoadLocal');
    const inputLocal = document.getElementById('localDicom');
    const btnClearMeasurements = document.getElementById('btnClearMeasurements');
    const measurementsList = document.getElementById('measurementsList');

    const reconType = document.getElementById('reconType');
    const boneCtrl = document.getElementById('boneCtrl');
    const boneSlider = document.getElementById('boneThreshold');
    const boneVal = document.getElementById('boneVal');
    const btnGenerateRecon = document.getElementById('btnGenerateRecon');
    const reconStatus = document.getElementById('reconStatus');
    const reconViews = document.getElementById('reconViews');
    const viewAxial = document.getElementById('viewAxial');
    const viewSagittal = document.getElementById('viewSagittal');
    const viewCoronal = document.getElementById('viewCoronal');

    // 3D dropdown controls
    const btn3D = document.getElementById('btn3D');
    const menu3D = document.getElementById('menu3D');

    let currentStudy = null;
    let currentSeries = null;
    let images = [];
    let index = 0;
    let ww = 400, wl = 40, inverted = false, zoom = 1.0;
    let mprMode = false;
    let mprImgs = { axial: null, sagittal: null, coronal: null };
    let reconMode = null; // 'mpr' | 'mip' | 'bone' | null
    let reconImgs = []; // ordered list of image data URLs for canvas display
    let reconIndex = 0;
    // MPR plane browsing state
    let mprScroll = { axial: 0, sagittal: 0, coronal: 0, counts: { axial: 0, sagittal: 0, coronal: 0 } };
    let showHuProbe = false;
    let activeTool = 'window';
    let isDragging = false;
    let dragStart = null;
    let panOffset = { x: 0, y: 0 };
    let measureDraft = null; // {start:{x,y}, end:{x,y}}
    let measurements = []; // persisted per image id
    let annotations = [];
    let crosshair = false;

    // Map imageId -> arrays to persist while session active
    const imageIdToMeasurements = new Map();
    const imageIdToAnnotations = new Map();

    // Helper: parse pixel spacing robustly (string "0.5\\0.5", "0.5,0.5" or array)
    function parsePixelSpacing(ps){
      if (!ps) return null;
      if (Array.isArray(ps)) return ps.map(Number);
      if (typeof ps === 'string'){
        const parts = ps.split(/[\\,\s]+/).filter(Boolean);
        if (parts.length >= 2) return [parseFloat(parts[0]), parseFloat(parts[1])];
      }
      return null;
    }

    async function fallbackToDesktop(){
      try {
        const params = new URLSearchParams(window.location.search);
        const studyId = params.get('study_id') || (currentStudy && currentStudy.id);
        if (studyId){
          const resp = await fetch(`/viewer/launch-desktop/${studyId}/`);
          const j = await resp.json();
          if (j && j.fallback_url){ window.location.href = j.fallback_url; return; }
          // Desktop launched; leave page as-is
        } else {
          const resp = await fetch('/viewer/launch-desktop/', { method:'POST', headers:{'Content-Type':'application/json'}, body: '{}' });
          const j = await resp.json();
          if (j && j.fallback_url){ window.location.href = j.fallback_url; return; }
        }
      } catch (e) {
        // swallow
      }
    }

    function setCanvasSize(){
      const vp = document.getElementById('viewport');
      const rect = vp.getBoundingClientRect();
      canvas.width = Math.max(100, rect.width - 20);
      canvas.height = Math.max(100, rect.height - 20);
    }
    window.addEventListener('resize', ()=>{ setCanvasSize(); draw(); });

    function q(name){ return new URLSearchParams(window.location.search).get(name); }

    async function loadStudy(studyId){
      try {
        const r = await fetch(`/viewer/study/${studyId}/`);
        if (!r.ok) throw new Error('study fetch failed');
        const data = await r.json();
        currentStudy = data.study;
        // Enable write report button when study is known
        const wr = document.getElementById('btnWriteReport');
        if (wr && currentStudy && currentStudy.id){
          wr.style.display = '';
          wr.onclick = function(){ window.location.href = `/reports/write/${currentStudy.id}/`; };
        }
        document.getElementById('patientInfo').textContent = `Patient: ${currentStudy.patient_name} | Study Date: ${currentStudy.study_date} | Modality: ${currentStudy.modality}`;
        // Show clinical info and priority
        const clin = (currentStudy.clinical_info && currentStudy.clinical_info.trim()) ? currentStudy.clinical_info : '-';
        document.getElementById('clinicalInfo').textContent = `Clinical Info: ${clin}`;
        document.getElementById('priorityInfo').textContent = `Priority: ${currentStudy.priority ? currentStudy.priority.toUpperCase() : '-'}`;
        seriesSelect.innerHTML = '<option value="">Select Series</option>';
        (data.series_list || []).forEach(s=>{
          const opt = document.createElement('option');
          opt.value = s.id; opt.textContent = `Series ${s.series_number} - ${s.modality} (${s.image_count} images)`;
          seriesSelect.appendChild(opt);
        });
        if ((data.series_list||[]).length){
          seriesSelect.value = data.series_list[0].id;
          await loadSeries(data.series_list[0].id);
        }
      } catch (e) {
        await fallbackToDesktop();
      }
    }

    async function loadSeries(seriesId){
      try {
        const r = await fetch(`/viewer/series/${seriesId}/images/`);
        if (!r.ok) throw new Error('series fetch failed');
        const data = await r.json();
        currentSeries = data.series; images = data.images || []; index = 0;
        sliceSlider.max = Math.max(0, images.length - 1); sliceSlider.value = 0; document.getElementById('sliceVal').textContent = '1';
        if (images.length){
          // Fetch defaults from JSON API
          const probe = await fetch(`/viewer/api/image/${images[0].id}/display/`);
          if (probe.ok){
            const j = await probe.json();
            if (j && j.image_info){
              ww = j.image_info.default_window_width || ww;
              wl = j.image_info.default_window_level || wl;
              if (j.windowing && typeof j.windowing.inverted === 'boolean') { inverted = j.windowing.inverted; }
            }
          }
          wwSlider.value = Math.round(ww); wlSlider.value = Math.round(wl); document.getElementById('wwVal').textContent = Math.round(ww); document.getElementById('wlVal').textContent = Math.round(wl);
        }
        // Reset view state
        zoom = 1.0; panOffset = {x:0,y:0}; activeTool = 'window'; crosshair = false; mprMode = false; mprImgs = {axial:null,sagittal:null,coronal:null}; reconMode = null; reconImgs = []; reconIndex = 0;
        // Safely guard missing elements (fix: avoid null access halting draw)
        const enterMpr = document.getElementById('btnEnterMpr');
        const exitMpr = document.getElementById('btnExitMpr');
        if (enterMpr) enterMpr.style.display = images.length ? '' : 'none';
        if (exitMpr) exitMpr.style.display = 'none';
        document.querySelectorAll('.tool').forEach(x=>x.classList.remove('active'));
        document.querySelector('.tool[data-tool="window"]').classList.add('active');
        setCanvasSize();
        await draw();
        await loadOverlaysForCurrentImage();
      } catch (e) {
        await fallbackToDesktop();
      }
    }

    function getCurrentImageId(){
      if (!images.length) return null;
      return images[index].id;
    }

    function getViewportPlacement(imgW, imgH){
      const scale = Math.min(canvas.width / imgW, canvas.height / imgH) * zoom;
      const w = imgW * scale, h = imgH * scale;
      const x = (canvas.width - w)/2 + panOffset.x;
      const y = (canvas.height - h)/2 + panOffset.y;
      return { scale, w, h, x, y };
    }

    async function draw(){
      if (!images.length && reconImgs.length===0) { ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height); return; }
      if (mprMode){
        try{
          // Ensure counts and initial mid-slice indices are loaded
          if (!mprImgs.axial || !mprImgs.sagittal || !mprImgs.coronal){
            const params = new URLSearchParams(); params.set('window_width', ww); params.set('window_level', wl); params.set('inverted', inverted);
            const r = await fetch(`/viewer/api/series/${currentSeries.id}/mpr/?${params.toString()}`);
            const j = await r.json();
            if (j && j.mpr_views){ mprImgs = j.mpr_views; }
            if (j && j.counts){
              mprScroll.counts = j.counts;
              mprScroll.axial = Math.floor((j.counts.axial||0)/2);
              mprScroll.sagittal = Math.floor((j.counts.sagittal||0)/2);
              mprScroll.coronal = Math.floor((j.counts.coronal||0)/2);
            }
          }
          ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
          const regions = [
            { x: 0, y: 0, w: Math.floor(canvas.width/3), h: canvas.height, key: 'axial' },
            { x: Math.floor(canvas.width/3), y: 0, w: Math.floor(canvas.width/3), h: canvas.height, key: 'sagittal' },
            { x: Math.floor(2*canvas.width/3), y: 0, w: canvas.width - Math.floor(2*canvas.width/3), h: canvas.height, key: 'coronal' },
          ];
          for (const reg of regions){
            // Fetch specific slice for this plane index
            const params2 = new URLSearchParams();
            params2.set('plane', reg.key);
            params2.set('slice', mprScroll[reg.key] || 0);
            params2.set('window_width', ww);
            params2.set('window_level', wl);
            params2.set('inverted', inverted);
            const r2 = await fetch(`/viewer/api/series/${currentSeries.id}/mpr/?${params2.toString()}`);
            const j2 = await r2.json();
            if (j2 && j2.image){ mprImgs[reg.key] = j2.image; if (j2.counts) mprScroll.counts = j2.counts; }
            if (!mprImgs[reg.key]) continue;
            const im = await loadImage(mprImgs[reg.key]);
            const scale = Math.min(reg.w / im.width, reg.h / im.height);
            const dw = im.width * scale, dh = im.height * scale;
            const dx = reg.x + (reg.w - dw)/2, dy = reg.y + (reg.h - dh)/2;
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(im, dx, dy, dw, dh);
            // Draw plane label and slice index
            ctx.save();
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(dx + 8, dy + 8, 130, 22);
            ctx.fillStyle = '#0ff';
            ctx.font = '12px monospace';
            ctx.fillText(`${reg.key.toUpperCase()} ${ (mprScroll[reg.key]||0) + 1 }/${ mprScroll.counts[reg.key]||0 }`, dx + 12, dy + 24);
            ctx.restore();
          }
          document.getElementById('overlay').innerHTML = `MPR | WW: ${Math.round(ww)}<br>WL: ${Math.round(wl)}`;
          document.getElementById('zoominfo').textContent = `MPR`;
          return;
        } catch(e){ /* fallback to normal draw below */ }
      }
      if (reconMode && reconImgs.length){
        try {
          ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
          const im = await loadImage(reconImgs[reconIndex]);
          const scale = Math.min(canvas.width / im.width, canvas.height / im.height) * zoom;
          const dw = im.width * scale, dh = im.height * scale;
          const dx = (canvas.width - dw)/2 + panOffset.x; const dy = (canvas.height - dh)/2 + panOffset.y;
          ctx.imageSmoothingEnabled = false;
          ctx.drawImage(im, dx, dy, dw, dh);
          document.getElementById('overlay').innerHTML = `${reconMode.toUpperCase()} | View ${reconIndex+1}/${reconImgs.length}`;
          document.getElementById('zoominfo').textContent = `Zoom: ${Math.round(zoom*100)}%`;
          return;
        } catch(e){}
      }
      try {
        const img = images[index];
        const url = `/viewer/image/${img.id}/?ww=${ww}&wl=${wl}&invert=${inverted}`;
        const htmlImg = new Image(); htmlImg.crossOrigin = 'anonymous';
        await new Promise((resolve,reject)=>{ htmlImg.onload=resolve; htmlImg.onerror=reject; htmlImg.src=url; });
        const vp = getViewportPlacement(htmlImg.width, htmlImg.height);
        ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(htmlImg, vp.x, vp.y, vp.w, vp.h);
        drawOverlays(vp);
        document.getElementById('overlay').innerHTML = `WW: ${Math.round(ww)}<br>WL: ${Math.round(wl)}<br>Slice: ${index+1}/${images.length}`;
        document.getElementById('zoominfo').textContent = `Zoom: ${Math.round(zoom*100)}%`;
      } catch (e) {
        await fallbackToDesktop();
      }
    }

    function drawOverlays(vp){
      // Measurements (draft first)
      ctx.save();
      ctx.strokeStyle = 'yellow';
      ctx.fillStyle = 'yellow';
      ctx.lineWidth = 2;
      const toCanvas = (p)=>({
        x: vp.x + p.x * vp.scale,
        y: vp.y + p.y * vp.scale,
      });
      const drawLine = (a,b)=>{
        const A = toCanvas(a), B = toCanvas(b);
        ctx.beginPath(); ctx.moveTo(A.x, A.y); ctx.lineTo(B.x, B.y); ctx.stroke();
      };
      const drawText = (p, text)=>{
        const P = toCanvas(p);
        ctx.font = '12px monospace';
        ctx.fillStyle = 'yellow';
        ctx.fillText(text, P.x + 6, P.y - 6);
      };
      if (measureDraft && measureDraft.start && measureDraft.end){
        drawLine(measureDraft.start, measureDraft.end);
      }
      measurements.forEach(m=>{ drawLine(m.start, m.end); if (m.label) drawText(m.end, m.label); });
      // Annotations
      annotations.forEach(a=>{ drawText(a.pos, a.text); });
      // Crosshair
      if (crosshair){
        ctx.strokeStyle = 'rgba(0,255,255,0.8)';
        ctx.beginPath();
        ctx.moveTo(canvas.width/2, 0); ctx.lineTo(canvas.width/2, canvas.height);
        ctx.moveTo(0, canvas.height/2); ctx.lineTo(canvas.width, canvas.height/2);
        ctx.stroke();
      }
      ctx.restore();
    }

    function canvasToImageCoords(vp, cx, cy){
      const x = (cx - vp.x) / vp.scale;
      const y = (cy - vp.y) / vp.scale;
      return { x, y };
    }

    function imageDistance(a, b){
      const dx = b.x - a.x, dy = b.y - a.y;
      const px = Math.sqrt(dx*dx + dy*dy);
      const spacing = parsePixelSpacing(currentSeries && currentSeries.pixel_spacing);
      if (spacing && spacing.length >= 2 && isFinite(spacing[0]) && isFinite(spacing[1])){
        const mm = Math.sqrt((dx*spacing[0])**2 + (dy*spacing[1])**2);
        return { px, mm };
      }
      return { px, mm: null };
    }

    async function saveMeasurementToServer(m){
      const imageId = getCurrentImageId();
      if (!imageId) return;
      const dist = imageDistance(m.start, m.end);
      const payload = {
        image_id: imageId,
        type: 'distance',
        points: [m.start, m.end],
        value: dist.mm || dist.px,
        unit: dist.mm ? 'mm' : 'px',
        notes: ''
      };
      try {
        const r = await fetch('/viewer/measurements/save/', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
        const j = await r.json();
        if (j && j.success){
          m.label = dist.mm ? `${dist.mm.toFixed(2)} mm` : `${dist.px.toFixed(1)} px`;
        }
      } catch(e){}
    }

    async function saveAnnotationToServer(p, text){
      const imageId = getCurrentImageId();
      if (!imageId) return;
      try {
        await fetch('/viewer/annotations/save/', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ image_id: imageId, position_x: p.x, position_y: p.y, text }) });
      } catch(e){}
    }

    async function loadOverlaysForCurrentImage(){
      const imageId = getCurrentImageId();
      if (!imageId) return;
      // Load from cache or backend
      if (imageIdToMeasurements.has(imageId)) measurements = imageIdToMeasurements.get(imageId); else {
        try {
          const r = await fetch(`/viewer/measurements/${imageId}/`); const j = await r.json();
          measurements = (j.measurements||[]).map(m=>({ start: m.points[0], end: m.points[1], label: m.unit==='mm' ? `${(+m.value).toFixed(2)} mm` : `${(+m.value).toFixed(1)} px` }));
          imageIdToMeasurements.set(imageId, measurements);
        } catch(e){ measurements = []; }
      }
      if (imageIdToAnnotations.has(imageId)) annotations = imageIdToAnnotations.get(imageId); else {
        try {
          const r = await fetch(`/viewer/annotations/${imageId}/`); const j = await r.json();
          annotations = (j.annotations||[]).map(a=>({ pos: {x:a.position_x, y:a.position_y}, text: a.text }));
          imageIdToAnnotations.set(imageId, annotations);
        } catch(e){ annotations = []; }
      }
      renderMeasurementsList();
      await draw();
    }

    function renderMeasurementsList(){
      measurementsList.innerHTML = '';
      measurements.forEach((m, i)=>{
        const li = document.createElement('li');
        li.textContent = `Measurement ${i+1}: ${m.label||''}`;
        measurementsList.appendChild(li);
      });
    }

    // UI wiring
    seriesSelect.addEventListener('change', e=>{ if(e.target.value) loadSeries(e.target.value); });
    wwSlider.addEventListener('input', e=>{ ww = +e.target.value; document.getElementById('wwVal').textContent = ww; draw(); });
    wlSlider.addEventListener('input', e=>{ wl = +e.target.value; document.getElementById('wlVal').textContent = wl; draw(); });
    sliceSlider.addEventListener('input', async e=>{ index = +e.target.value; document.getElementById('sliceVal').textContent = index+1; await loadOverlaysForCurrentImage(); });
    zoomSlider.addEventListener('input', e=>{ zoom = (+e.target.value)/100; document.getElementById('zoomVal').textContent = `${e.target.value}%`; draw(); });
    document.querySelectorAll('[data-preset]').forEach(btn=>btn.addEventListener('click', ()=>{
      const p = btn.getAttribute('data-preset');
      const map = { lung:{ww:1500,wl:-600}, bone:{ww:2000,wl:300}, soft:{ww:400,wl:40}, brain:{ww:100,wl:50} };
      if (map[p]){ ww = map[p].ww; wl = map[p].wl; wwSlider.value = ww; wlSlider.value = wl; document.getElementById('wwVal').textContent = ww; document.getElementById('wlVal').textContent = wl; draw(); }
    }));
    document.querySelectorAll('.tool').forEach(t=>t.addEventListener('click', ()=>{
      const tool = t.getAttribute('data-tool');
      document.querySelectorAll('.tool').forEach(x=>x.classList.remove('active')); t.classList.add('active');
      if (tool === 'invert'){ inverted = !inverted; draw(); return; }
      if (tool === 'reset'){ zoom = 1.0; panOffset = {x:0,y:0}; zoomSlider.value = 100; document.getElementById('zoomVal').textContent = '100%'; draw(); return; }
      if (tool === 'ai'){ alert('AI analysis result: (stub) No backend connected.'); return; }
      if (tool === 'crosshair'){ crosshair = !crosshair; draw(); return; }
      if (tool === 'hu'){ showHuProbe = !showHuProbe; draw(); return; }
      if (tool === 'measure') { showHuProbe = false; }
      // remove old inline MPR toggle from tool button; handled by 3D dropdown now
      if (tool === 'mpr'){
        return; // no-op
      }
      if (mprMode){ return; }
      activeTool = tool;
    }));

    // Mouse interactions on viewport
    const viewport = document.getElementById('viewport');
    viewport.addEventListener('mousedown', (e)=>{
      isDragging = true; dragStart = { x: e.offsetX, y: e.offsetY };
      // Start measurement draft
      if (activeTool === 'measure'){
        const vp2 = getViewportPlacement(canvas.width, canvas.height);
        measureDraft = { start: canvasToImageCoords(vp2, e.offsetX, e.offsetY), end: canvasToImageCoords(vp2, e.offsetX, e.offsetY) };
      }
    });
    viewport.addEventListener('mousemove', async (e)=>{
      if (!isDragging) return;
      const vp = getViewportPlacement(canvas.width, canvas.height);
      if (activeTool === 'window'){
        const dx = e.offsetX - dragStart.x; const dy = e.offsetY - dragStart.y; dragStart = { x: e.offsetX, y: e.offsetY };
        ww = Math.max(1, ww + dx*4); wl = wl + dy*2; wwSlider.value = Math.round(ww); wlSlider.value = Math.round(wl); document.getElementById('wwVal').textContent = Math.round(ww); document.getElementById('wlVal').textContent = Math.round(wl); await draw();
      } else if (activeTool === 'pan'){
        panOffset.x += (e.offsetX - dragStart.x); panOffset.y += (e.offsetY - dragStart.y); dragStart = { x: e.offsetX, y: e.offsetY }; await draw();
      } else if (activeTool === 'measure' && measureDraft){
        measureDraft.end = canvasToImageCoords(vp, e.offsetX, e.offsetY); await draw();
      } else if (activeTool === 'annotate'){
        // no-op while dragging
      } else if (activeTool === 'zoom'){
        const dy = e.offsetY - dragStart.y; dragStart = { x: e.offsetX, y: e.offsetY }; const factor = dy<0 ? 1.05 : 0.95; zoom = Math.min(5.0, Math.max(0.25, zoom*factor)); zoomSlider.value = Math.round(zoom*100); document.getElementById('zoomVal').textContent = `${Math.round(zoom*100)}%`; await draw();
      }
    });
    // HU probe on mousemove in MPR when enabled
    viewport.addEventListener('mousemove', async (e)=>{
      if (!mprMode || !showHuProbe) return;
      // Determine which plane region the mouse is in
      const regions = [
        { x: 0, y: 0, w: Math.floor(canvas.width/3), h: canvas.height, key: 'axial' },
        { x: Math.floor(canvas.width/3), y: 0, w: Math.floor(canvas.width/3), h: canvas.height, key: 'sagittal' },
        { x: Math.floor(2*canvas.width/3), y: 0, w: canvas.width - Math.floor(2*canvas.width/3), h: canvas.height, key: 'coronal' },
      ];
      const mx = e.offsetX, my = e.offsetY;
      const region = regions.find(r=> mx>=r.x && mx<r.x+r.w && my>=r.y && my<r.y+r.h);
      if (!region) return;
      // Load current image for region to compute mapping
      const im = await loadImage(mprImgs[region.key]);
      const scale = Math.min(region.w / im.width, region.h / im.height);
      const dw = im.width * scale, dh = im.height * scale;
      const dx = region.x + (region.w - dw)/2, dy = region.y + (region.h - dh)/2;
      if (mx < dx || mx > dx+dw || my < dy || my > dy+dh) return;
      const px = (mx - dx) / scale; // image coordinates
      const py = (my - dy) / scale;
      // Query HU from backend
      const q = new URLSearchParams();
      q.set('mode','mpr'); q.set('series_id', currentSeries.id); q.set('plane', region.key);
      q.set('slice', mprScroll[region.key]||0); q.set('x', Math.floor(px)); q.set('y', Math.floor(py));
      try {
        const resp = await fetch(`/viewer/api/hu/?${q.toString()}`);
        const j = await resp.json();
        if (j && typeof j.hu === 'number'){
          const base = `MPR | WW: ${Math.round(ww)}<br>WL: ${Math.round(wl)}`;
          document.getElementById('overlay').innerHTML = `${base}<br>${region.key.toUpperCase()} HU: ${j.hu}`;
        }
      } catch(e){}
    });
    viewport.addEventListener('mouseup', async (e)=>{
      if (!isDragging) return; isDragging = false;
      const vp = getViewportPlacement(canvas.width, canvas.height);
      if (activeTool === 'measure' && measureDraft){
        measureDraft.end = canvasToImageCoords(vp, e.offsetX, e.offsetY);
        const m = { start: measureDraft.start, end: measureDraft.end };
        measureDraft = null; measurements.push(m); imageIdToMeasurements.set(getCurrentImageId(), measurements);
        await saveMeasurementToServer(m); renderMeasurementsList(); await draw();
      } else if (activeTool === 'annotate'){
        const pos = canvasToImageCoords(vp, e.offsetX, e.offsetY);
        const text = prompt('Enter annotation text:');
        if (text){ annotations.push({ pos, text }); imageIdToAnnotations.set(getCurrentImageId(), annotations); await saveAnnotationToServer(pos, text); await draw(); }
      }
    });

    // Mouse wheel slice/zoom
    document.getElementById('viewport').addEventListener('wheel', async (e)=>{
      e.preventDefault();
      if (reconMode && reconImgs.length){
        const d = e.deltaY>0 ? 1 : -1;
        reconIndex = Math.max(0, Math.min(reconImgs.length-1, reconIndex + d));
        await draw();
        return;
      }
      if (mprMode){
        // Determine which third the cursor is in and scroll that plane
        const mx = e.offsetX, w = canvas.width; const d = e.deltaY>0 ? 1 : -1;
        let plane = 'axial';
        if (mx < Math.floor(w/3)) plane = 'axial';
        else if (mx < Math.floor(2*w/3)) plane = 'sagittal';
        else plane = 'coronal';
        const count = (mprScroll.counts[plane]||1);
        const cur = (mprScroll[plane]||0);
        const ni = Math.max(0, Math.min(count-1, cur + d));
        if (ni !== cur){ mprScroll[plane] = ni; await draw(); }
        return;
      }
      if (e.ctrlKey){ const delta = e.deltaY>0?0.9:1.1; zoom = Math.max(0.1, Math.min(5.0, zoom*delta)); zoomSlider.value = Math.round(zoom*100); document.getElementById('zoomVal').textContent = `${Math.round(zoom*100)}%`; draw(); }
      else { const d = e.deltaY>0?1:-1; const ni = Math.max(0, Math.min(images.length-1, index+d)); if (ni !== index){ index = ni; sliceSlider.value = index; document.getElementById('sliceVal').textContent = index+1; loadOverlaysForCurrentImage(); } }
    }, { passive:false });

    // Local DICOM upload
    btnLoadLocal.addEventListener('click', ()=> inputLocal.click());
    inputLocal.addEventListener('change', async (e)=>{
      try {
        if (!e.target.files || !e.target.files.length) return;
        reconStatus.textContent = 'Uploading DICOM files...';
        const form = new FormData();
        Array.from(e.target.files).forEach(f=> form.append('dicom_files', f));
        const resp = await fetch('/viewer/upload/', { method:'POST', body: form });
        const data = await resp.json();
        if (!data.success) throw new Error(data.error || 'Upload failed');
        reconStatus.textContent = 'Upload complete. Loading study...';
        await loadStudy(data.study_id);
        reconStatus.textContent = '';
      } catch (err){
        reconStatus.textContent = `Error: ${err.message}`;
        await fallbackToDesktop();
      } finally {
        e.target.value = '';
      }
    });

    // Recon controls
    reconType.addEventListener('change', ()=>{
      const v = reconType.value; boneCtrl.style.display = v==='bone' ? '' : 'none';
    });
    boneSlider.addEventListener('input', e=> boneVal.textContent = e.target.value);

    // Extracted function so both dropdown and button can trigger
    async function generateReconstruction(kind){
      try {
        if (!currentSeries || !currentSeries.id){ alert('Select a series first'); return; }
        reconStatus.textContent = 'Generating...';
        reconMode = null; reconImgs = []; reconIndex = 0; panOffset = {x:0,y:0}; zoom = 1.0;
        const params = new URLSearchParams();
        params.set('window_width', ww);
        params.set('window_level', wl);
        params.set('inverted', inverted);
        let url = '';
        const type = kind || reconType.value;
        if (type === 'mpr') url = `/viewer/api/series/${currentSeries.id}/mpr/?${params.toString()}`;
        else if (type === 'mip') url = `/viewer/api/series/${currentSeries.id}/mip/?${params.toString()}`;
        else { url = `/viewer/api/series/${currentSeries.id}/bone/?threshold=${boneSlider.value}`; }
        const r = await fetch(url);
        const j = await r.json();
        if (j.error) throw new Error(j.error);
        if (j.mpr_views){ reconMode = 'mpr'; reconImgs = [j.mpr_views.axial, j.mpr_views.sagittal, j.mpr_views.coronal]; mprMode = true; if (j.counts){ mprScroll.counts = j.counts; mprScroll.axial = Math.floor((j.counts.axial||0)/2); mprScroll.sagittal = Math.floor((j.counts.sagittal||0)/2); mprScroll.coronal = Math.floor((j.counts.coronal||0)/2); } }
        if (j.mip_views){ reconMode = 'mip'; reconImgs = [j.mip_views.axial, j.mip_views.sagittal, j.mip_views.coronal]; }
        if (j.bone_views){ reconMode = 'bone'; reconImgs = [j.bone_views.axial || j.bone_views.bone_axial_preview, j.bone_views.sagittal || j.bone_views.bone_sagittal_preview, j.bone_views.coronal || j.bone_views.bone_coronal_preview]; }
        reconImgs = reconImgs.filter(Boolean);
        reconIndex = 0;
        await draw();
                reconStatus.textContent = 'Done'; setTimeout(()=> reconStatus.textContent = '', 1500);
       } catch (err){
         reconStatus.textContent = `Error: ${err.message}`;
         await fallbackToDesktop();
       }
     }
 
     btnGenerateRecon.addEventListener('click', async ()=>{ await generateReconstruction(); });
 
     // 3D dropdown interactions
     btn3D.addEventListener('click', ()=>{
       menu3D.style.display = (menu3D.style.display === 'flex') ? 'none' : 'flex';
       if (menu3D.style.display === '' || menu3D.style.display === 'none') menu3D.style.display = 'flex';
     });
     menu3D.addEventListener('click', async (e)=>{
       const btn = e.target.closest('button[data-recon]');
       if (!btn) return;
       const kind = btn.getAttribute('data-recon');
       menu3D.style.display = 'none';
       await generateReconstruction(kind);
     });
     // Close dropdown when clicking outside
     document.addEventListener('click', (e)=>{
       if (!menu3D.contains(e.target) && e.target !== btn3D) menu3D.style.display = 'none';
     });
 
     // Clear measurements
     btnClearMeasurements.addEventListener('click', ()=>{
       measurements = []; imageIdToMeasurements.set(getCurrentImageId(), measurements); renderMeasurementsList(); draw();
     });
 
     // Utils
     function loadImage(src){
       return new Promise((res, rej)=>{ const im = new Image(); im.onload=()=>res(im); im.onerror=rej; im.src=src; });
     }
 
     // Init
     setCanvasSize();
     const studyId = q('study_id');
     if (studyId) loadStudy(studyId);
   })();
   </script>
 </body>
 </html>