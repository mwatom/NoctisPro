<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DICOM Viewer</title>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
  <style>
    :root {
      --primary-bg: #0a0a0a;
      --secondary-bg: #1a1a1a;
      --card-bg: #252525;
      --card-surface: #252525;
      --header-bg: #333333;
      --border-color: #404040;
      --accent-color: #00d4ff;
      --text-primary: #ffffff;
      --text-secondary: #b3b3b3;
      --text-muted: #666666;
      --success-color: #00ff88;
      --warning-color: #ffaa00;
      --danger-color: #ff4444;
      --urgent-color: #ff0066;
      --scheduled-color: #4a90e2;
      --in-progress-color: #f5a623;
      --completed-color: #7ed321;
      --cancelled-color: #d0021b;
    }
    html, body { margin: 0; padding: 0; height: 100%; width: 100%; overflow: hidden; }
    body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: var(--primary-bg); color: var(--text-primary); }
    .main-container { height: 100vh; width: 100vw; position: fixed; top: 0; left: 0; overflow: hidden; }
    .layout { display: grid; grid-template-columns: 82px 1fr 320px; grid-template-rows: 60px 1fr; height: 100%; width: 100%; }
    .toolbar { grid-row: 1 / span 2; grid-column: 1; background: var(--secondary-bg); border-right: 1px solid var(--border-color); padding: 8px 6px; display: flex; flex-direction: column; gap: 6px; overflow:auto; }
    .tool { width: 52px; height: 46px; background: var(--card-bg); border: 1px solid var(--border-color); border-radius: 2px; color: var(--text-primary); cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 9px; transition: all 0.2s ease; font-weight: 500; position: relative; }
    .tool.active { background: var(--accent-color); color: var(--primary-bg); border-color: var(--accent-color); box-shadow: 0 0 8px rgba(0, 212, 255, 0.3); }
    .tool:hover:not(.active) { background: var(--accent-color); color: var(--primary-bg); border-color: var(--accent-color); transform: translateY(-1px); box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); }
    .tool:disabled { opacity: 0.5; cursor: not-allowed; pointer-events: none; }
    .tool i { font-size: 16px; margin-bottom: 2px; }
    .topbar { grid-row: 1; grid-column: 2 / span 2; display: flex; align-items: center; gap: 8px; padding: 0 16px; background: var(--header-bg); border-bottom: 1px solid var(--border-color); }
    .btn { padding: 3px 8px; border: 1px solid var(--border-color); border-radius: 2px; cursor: pointer; font-size: 10px; background: var(--card-bg); color: var(--text-primary); transition: all 0.2s ease; font-weight: 500; display: inline-flex; align-items: center; gap: 3px; text-decoration: none; min-width: 60px; justify-content: center; }
    .btn:hover:not(:disabled) { background: var(--accent-color); color: var(--primary-bg); border-color: var(--accent-color); transform: translateY(-1px); box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); }
    .btn:disabled { opacity: 0.6; cursor: not-allowed; pointer-events: none; }
    .btn-primary { background: var(--accent-color); color: var(--primary-bg); border-color: var(--accent-color); }
    .btn-primary:hover:not(:disabled) { background: #00b8d4; border-color: #00b8d4; }
    .btn-danger { background: var(--danger-color); color: var(--text-primary); border-color: var(--danger-color); }
    .btn-danger:hover:not(:disabled) { background: #ff6666; border-color: #ff6666; transform: translateY(-1px); box-shadow: 0 2px 4px rgba(255, 68, 68, 0.3); }
    
    .btn-control { padding: 3px 8px; border: 1px solid var(--border-color); border-radius: 2px; cursor: pointer; font-size: 10px; background: var(--card-bg); color: var(--text-primary); transition: all 0.2s ease; font-weight: 500; display: inline-flex; align-items: center; gap: 3px; text-decoration: none; min-width: 80px; justify-content: center; }
    .btn-control:hover:not(:disabled) { background: var(--accent-color); color: var(--primary-bg); border-color: var(--accent-color); transform: translateY(-1px); box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); }
    .btn-control:disabled { opacity: 0.6; cursor: not-allowed; pointer-events: none; }
    .select { padding: 4px 6px; background: var(--secondary-bg); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); min-width: 160px; font-size: 10px; }
    .select:focus { outline: none; border-color: var(--accent-color); box-shadow: 0 0 0 1px var(--accent-color); }
    .viewport { grid-row: 2; grid-column: 2; background: #000000; position: relative; display: flex; align-items: center; justify-content: center; overflow: hidden; }
    .right { grid-row: 2; grid-column: 3; background: var(--secondary-bg); border-left: 1px solid var(--border-color); padding: 16px; overflow-y: auto; overflow-x: hidden; }
    .panel { background: var(--card-surface); border: 1px solid var(--border-color); border-radius: 8px; padding: 12px; margin-bottom: 16px; }
    .panel h3 { font-size: 12px; margin: 0 0 12px; padding-bottom: 8px; border-bottom: 1px solid var(--border-color); letter-spacing: .3px; color: var(--accent-color); font-weight: 600; text-transform: uppercase; }
    .control { margin-bottom: 12px; }
    .control .label { display: flex; justify-content: space-between; font-size: 11px; color: var(--text-secondary); margin-bottom: 6px; font-weight: 500; }
    input[type=range] { width: 100%; accent-color: var(--accent-color); height: 4px; background: var(--border-color); border-radius: 2px; }
    input[type=number] { width: 100%; padding: 6px 8px; background: var(--secondary-bg); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 11px; }
    input[type=number]:focus { outline: none; border-color: var(--accent-color); box-shadow: 0 0 0 1px var(--accent-color); }
    .overlay { position: absolute; top: 12px; left: 12px; background: rgba(0,0,0,0.8); padding: 8px 12px; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 11px; border: 1px solid var(--border-color); }
    .zoominfo { position: absolute; bottom: 12px; left: 12px; background: rgba(0,0,0,0.8); padding: 6px 10px; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 11px; border: 1px solid var(--border-color); }
    canvas { max-width: 100%; max-height: 100%; image-rendering: pixelated; image-rendering: crisp-edges; display: block; }
    .thumbs { display:grid; grid-template-columns: 1fr 1fr; gap:8px; }
    .thumbs img { width:100%; background:#000; border-radius:6px; border:1px solid var(--border-color); }
    .row-3 { display:grid; grid-template-columns: 1fr 1fr 1fr; gap:8px; }
    .muted { color:var(--text-muted); font-size:11px; padding:4px 0; }
    /* 3D dropdown in toolbar */
    .tool-dropdown { position: relative; }
    .tool-dropdown-menu { position: absolute; top: 48px; left: 0; background: var(--card-surface); border: 1px solid var(--border-color); border-radius: 6px; width: 180px; display: none; flex-direction: column; overflow: hidden; z-index: 10; box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
    .tool-dropdown-menu button { background: transparent; border: none; color: var(--text-primary); text-align: left; padding: 8px 12px; cursor: pointer; font-size: 11px; transition: all 0.2s ease; font-weight: 500; }
    .tool-dropdown-menu button:hover { background: var(--accent-color); color: var(--primary-bg); }
    /* 3D modal */
    #threeContainer { position: fixed; inset: 0; background: rgba(0,0,0,0.95); display: none; z-index: 1000; overflow: hidden; }
    #threeMount { position: absolute; inset: 0; overflow: hidden; }
    #close3d { position: absolute; top: 12px; right: 12px; z-index: 1001; background: var(--card-surface); border: 1px solid var(--border-color); color: var(--text-primary); padding: 8px 12px; border-radius: 4px; cursor: pointer; transition: all 0.2s ease; }
    #close3d:hover { background: var(--border-color); }
    /* DICOM tags modal */
    #dicomModal { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; background: rgba(0,0,0,0.8); z-index: 1200; overflow: hidden; }
    #dicomModal .modal-card { background:var(--card-surface); border:1px solid var(--border-color); padding:20px; width:70%; max-width: 960px; max-height:80%; overflow-y:auto; overflow-x:hidden; border-radius:8px; box-shadow: 0 8px 24px rgba(0,0,0,0.4); }
    #dicomModal .modal-header { display:flex; justify-content: space-between; align-items:center; margin-bottom:12px; border-bottom: 1px solid var(--border-color); padding-bottom: 12px; }
    #dicomModal h3 { color: var(--accent-color); font-weight: 600; margin: 0; text-transform: uppercase; font-size: 12px; }
    #dicomModal #dicomTagsPre { background: var(--secondary-bg); border: 1px solid var(--border-color); border-radius: 4px; padding: 12px; color: var(--text-secondary); font-family: 'Courier New', monospace; font-size: 11px; }
    
    /* Print modal */
    #printModal { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; background: rgba(0,0,0,0.8); z-index: 1300; overflow: hidden; }
    #printModal .modal-card { background:var(--card-surface); border:1px solid var(--border-color); padding:20px; width:500px; max-height:80%; overflow-y:auto; overflow-x:hidden; border-radius:8px; box-shadow: 0 8px 24px rgba(0,0,0,0.4); }
    #printModal .modal-header { display:flex; justify-content: space-between; align-items:center; margin-bottom:16px; border-bottom: 1px solid var(--border-color); padding-bottom: 12px; }
    #printModal h3 { color: var(--accent-color); font-weight: 600; margin: 0; text-transform: uppercase; font-size: 12px; }
    #printModal .form-group { margin-bottom: 16px; }
    #printModal .form-group label { display: block; margin-bottom: 6px; font-size: 11px; color: var(--text-secondary); font-weight: 500; }
    #printModal .form-group select, #printModal .form-group input { width: 100%; padding: 8px; background: var(--secondary-bg); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 11px; }
    #printModal .form-group select:focus, #printModal .form-group input:focus { outline: none; border-color: var(--accent-color); box-shadow: 0 0 0 1px var(--accent-color); }
    #printModal .btn-group { display: flex; gap: 8px; justify-content: flex-end; margin-top: 20px; }
  </style>
  
  <!-- Three.js CDN for 3D functionality -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r160/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>
  
  <!-- Performance optimization: Image preloader and cache -->
  <script>
    class ImagePreloader {
      constructor() {
        this.cache = new Map();
        this.preloadQueue = [];
        this.isPreloading = false;
        this.maxCacheSize = 100;
      }
      
      async preloadImage(url) {
        if (this.cache.has(url)) {
          return this.cache.get(url);
        }
        
        return new Promise((resolve) => {
          const img = new Image();
          img.onload = () => {
            if (this.cache.size >= this.maxCacheSize) {
              const firstKey = this.cache.keys().next().value;
              this.cache.delete(firstKey);
            }
            this.cache.set(url, img);
            resolve(img);
          };
          img.onerror = () => resolve(null);
          img.src = url;
        });
      }
      
      async preloadNextImages(currentIndex, images, count = 3) {
        const preloadPromises = [];
        for (let i = 1; i <= count && currentIndex + i < images.length; i++) {
          const nextImage = images[currentIndex + i];
          if (nextImage && nextImage.url) {
            preloadPromises.push(this.preloadImage(nextImage.url));
          }
        }
        return Promise.all(preloadPromises);
      }
    }
    
    const imagePreloader = new ImagePreloader();
  </script>
</head>
<body>
  <div class="main-container">
    <div class="layout">
    <div class="toolbar">
      <button type="button" class="tool active" data-tool="window"><i class="fas fa-adjust"></i><span>Window</span></button>
      <button type="button" class="tool" data-tool="zoom"><i class="fas fa-search-plus"></i><span>Zoom</span></button>
      <button type="button" class="tool" data-tool="pan"><i class="fas fa-arrows-alt"></i><span>Pan</span></button>
      <button type="button" class="tool" data-tool="measure"><i class="fas fa-ruler"></i><span>Measure</span></button>
      <button type="button" class="tool" data-tool="annotate"><i class="fas fa-comment-dots"></i><span>Annotate</span></button>
      <button type="button" class="tool" data-tool="crosshair"><i class="fas fa-crosshairs"></i><span>Crosshair</span></button>
      <button type="button" class="tool" data-tool="hu"><i class="fas fa-thermometer-half"></i><span>HU</span></button>
      <button type="button" class="tool" data-tool="invert"><i class="fas fa-adjust"></i><span>Invert</span></button>
      <button type="button" class="tool" data-tool="reset"><i class="fas fa-undo"></i><span>Reset</span></button>
      <button type="button" class="tool" data-tool="fit"><i class="fas fa-compress-arrows-alt"></i><span>Fit</span></button>
      <button type="button" class="tool" data-tool="one"><i class="fas fa-expand"></i><span>1:1</span></button>
      <button type="button" class="tool" data-tool="cine"><i class="fas fa-film"></i><span>Cine</span></button>
      <button type="button" class="tool" data-tool="spyglass"><i class="fas fa-search"></i><span>Spyglass</span></button>
      <button type="button" class="tool" data-tool="align-center"><i class="fas fa-align-center"></i><span>Center</span></button>
      <button type="button" class="tool" data-tool="reload"><i class="fas fa-sync"></i><span>Reload</span></button>
      <button type="button" class="tool" data-tool="ai"><i class="fas fa-robot"></i><span>AI</span></button>
      <!-- 3D dropdown moved into toolbar -->
      <div class="tool-dropdown">
        <button type="button" id="btn3D" class="tool"><i class="fas fa-cube"></i><span>3D</span></button>
        <div id="menu3D" class="tool-dropdown-menu">
          <button type="button" data-recon="mpr"><i class="fas fa-layer-group"></i> MPR</button>
          <button type="button" data-recon="mip"><i class="fas fa-bullseye"></i> MIP</button>
          <button type="button" data-recon="bone"><i class="fas fa-bone"></i> Bone</button>
        </div>
      </div>
    </div>
    <div class="topbar">
      <button type="button" id="btnLoadLocal" class="btn-control"><i class="fas fa-folder-open"></i> Load Local DICOM</button>
      <a id="btnBackWorklist" class="btn" href="{% url 'worklist:dashboard' %}" onclick="return returnToWorklist(event)"><i class="fas fa-arrow-left"></i> Back to Worklist</a>
      {% if user.is_authenticated and user.can_edit_reports %}
      <button type="button" id="btnWriteReport" class="btn-control" style="display:none"><i class="fas fa-file-signature"></i> Write Report</button>
      {% endif %}
      <input id="localDicom" type="file" multiple webkitdirectory directory accept=".dcm,.dicom,application/dicom" style="display:none" />
      <select id="seriesSelect" class="select"><option value="">Select Series</option></select>
      <select id="sortSelect" class="select">
        <option value="">Sort: Instance # (asc)</option>
        <option value="inst_desc">Instance # (desc)</option>
      </select>
      <button type="button" id="btnToggleTags" class="btn"><i class="fas fa-tags"></i> Tags</button>
      <button type="button" id="btnShowDicom" class="btn"><i class="fas fa-info-circle"></i> Show DICOM</button>
      <button type="button" id="btnCapture" class="btn"><i class="fas fa-camera"></i> Capture</button>
      <button type="button" id="btnPrint" class="btn"><i class="fas fa-print"></i> Print</button>
      
      {% if user.is_superuser %}
      <button type="button" id="btnDeleteStudy" class="btn btn-danger" style="margin-left: auto;"><i class="fas fa-trash"></i> Delete Study</button>
      {% endif %}
      <div id="patientInfo" style="margin-left:auto;color:#ccc;font-size:13px;">Patient: - | Study Date: - | Modality: -</div>
    </div>
    <div class="viewport" id="viewport">
      <canvas id="dicomCanvas"></canvas>
      <div class="overlay" id="overlay">WW: 400<br>WL: 40<br>Slice: 1/1</div>
      <div class="zoominfo" id="zoominfo">Zoom: 100%</div>
    </div>
    <div class="right">
      <div class="panel">
        <h3>Window/Level</h3>
        <div class="control"><div class="label"><span>Window Width</span><span id="wwVal">400</span></div><input id="ww" type="range" min="1" max="4000" value="400"></div>
        <div class="control"><input id="wwNum" type="number" min="1" max="4000" step="1" value="400"></div>
        <div class="control"><div class="label"><span>Window Level</span><span id="wlVal">40</span></div><input id="wl" type="range" min="-1000" max="1000" value="40"></div>
        <div class="control"><input id="wlNum" type="number" min="-1000" max="1000" step="1" value="40"></div>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:6px;">
          <button type="button" class="btn" data-preset="lung">Lung</button>
          <button type="button" class="btn" data-preset="bone">Bone</button>
          <button type="button" class="btn" data-preset="soft">Soft</button>
          <button type="button" class="btn" data-preset="brain">Brain</button>
        </div>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:6px;margin-top:8px;">
          <button type="button" id="btnSavePreset" class="btn"><i class="fas fa-bookmark"></i> Save</button>
          <button type="button" id="btnLoadPreset" class="btn"><i class="fas fa-list"></i> Load</button>
        </div>
      </div>
      <div class="panel">
        <h3>Measurement Units</h3>
        <div class="control">
          <label class="label" for="unitSelect"><span>Display Unit</span><span id="unitVal">mm</span></label>
          <select id="unitSelect" class="select">
            <option value="mm" selected>Millimeters (mm)</option>
            <option value="cm">Centimeters (cm)</option>
          </select>
        </div>
      </div>
      <div class="panel" id="mprMeasurePanel" style="display:none;">
        <h3>MPR Measurements</h3>
        <div class="control">
          <div class="label"><span>Plane Selection</span></div>
          <select id="mprMeasurePlane" class="select">
            <option value="auto" selected>Auto (by quadrant)</option>
            <option value="axial">Axial</option>
            <option value="sagittal">Sagittal</option>
            <option value="coronal">Coronal</option>
          </select>
        </div>
        <div class="control">
          <div class="label"><span>Measurement</span></div>
          <select id="mprMeasureType" class="select">
            <option value="distance" selected>Distance</option>
          </select>
        </div>
      </div>
      <div class="panel">
        <h3>Navigation</h3>
        <div class="control"><div class="label"><span>Slice</span><span id="sliceVal">1</span></div><input id="slice" type="range" min="0" max="0" value="0"></div>
      </div>
      <div class="panel">
        <h3>Transform</h3>
        <div class="control"><div class="label"><span>Zoom</span><span id="zoomVal">100%</span></div><input id="zoom" type="range" min="25" max="500" value="100"></div>
      </div>
      <div class="panel">
        <h3>3D Reconstruction</h3>
        <div class="control">
          <div class="label"><span>Type</span></div>
          <select id="reconType" class="select">
            <option value="mpr">MPR (Axial/Sagittal/Coronal)</option>
            <option value="mip">MIP (Max Intensity)</option>
            <option value="bone">Bone 3D (threshold)</option>
          </select>
        </div>
        <div class="control" id="boneCtrl" style="display:none;">
          <div class="label"><span>Bone Threshold (HU)</span><span id="boneVal">300</span></div>
          <input id="boneThreshold" type="range" min="100" max="1500" value="300">
        </div>
        <div class="control">
          <button type="button" id="btnGenerateRecon" class="btn-control"><i class="fas fa-cogs"></i> Generate</button>
        </div>
        <div class="muted" id="reconStatus"></div>
        <div class="row-3" id="reconViews" style="margin-top:8px; display:none;">
          <img id="viewAxial" alt="Axial" loading="lazy" decoding="async"/>
          <img id="viewSagittal" alt="Sagittal" loading="lazy" decoding="async"/>
          <img id="viewCoronal" alt="Coronal" loading="lazy" decoding="async"/>
        </div>
      </div>
      <div class="panel">
        <h3>Image Info</h3>
        <div id="dimInfo" style="color:var(--text-secondary);font-size:11px;margin-bottom:4px;">Dimensions: -</div>
        <div id="spacingInfo" style="color:var(--text-secondary);font-size:11px;margin-bottom:4px;">Pixel Spacing: -</div>
        <div id="seriesInfo" style="color:var(--text-secondary);font-size:11px;margin-bottom:4px;">Series: -</div>
        <div id="institutionInfo" style="color:var(--text-secondary);font-size:11px;margin-bottom:4px;">Institution: -</div>
        <div id="clinicalInfo" style="color:var(--text-secondary);font-size:11px; margin-top:8px; white-space:pre-wrap;padding:6px;background:var(--secondary-bg);border:1px solid var(--border-color);border-radius:4px;">Clinical Info: -</div>
        <div id="priorityInfo" style="color:var(--text-secondary);font-size:11px;margin-top:4px;">Priority: -</div>
      </div>
      <div class="panel">
        <h3>Measurements</h3>
        <div class="control">
          <button type="button" id="btnClearMeasurements" class="btn">Clear All</button>
        </div>
        <ul id="measurementsList" style="list-style:none;padding-left:0;margin:0;color:var(--text-secondary);font-size:11px;"></ul>
      </div>
    </div>
  </div>
  </div>

  <!-- Three.js for rotatable bone mesh (loaded only if used) -->
  <!-- Removed deprecated UMD scripts; using ES Modules via importmap -->
  <div id="threeContainer" role="dialog" aria-modal="true">
    <button type="button" id="close3d" class="btn">Close 3D</button>
    <div id="threeMount"></div>
  </div>
  <div id="dicomModal">
    <div  role="dialog" aria-modal="true">
      <div  role="dialog" aria-modal="true">
        <h3 style="margin:0;">DICOM Tags</h3>
        <button type="button" id="closeDicomModal" class="btn">Close</button>
      </div>
      <pre id="dicomTagsPre" style="white-space:pre-wrap; color:#ddd;"></pre>
    </div>
  </div>

  <!-- Print Modal -->
  <div id="printModal">
    <div  role="dialog" aria-modal="true">
      <div  role="dialog" aria-modal="true">
        <h3>Print DICOM Image</h3>
        <button type="button" id="closePrintModal" class="btn">Close</button>
      </div>
      <form id="printForm">
        <div class="form-group">
          <label for="printMedium">Print Medium:</label>
          <select id="printMedium" name="print_medium">
            <option value="paper">📄 Paper</option>
            <option value="film">🎞️ Medical Film</option>
          </select>
        </div>
        <div class="form-group">
          <label for="layoutType">Layout:</label>
          <select id="layoutType" name="layout_type">
            <option value="single">Single Image</option>
            <option value="quad">Quad Layout (4 images)</option>
            <option value="comparison">Side-by-Side Comparison</option>
            <option value="film_standard">Film Standard (minimal text)</option>
          </select>
          <div class="form-text" id="layoutDescription">One image per page with full details</div>
        </div>
        <div class="form-group">
          <label for="printerSelect">Printer:</label>
          <select id="printerSelect" name="printer_name">
            <option value="">Loading printers...</option>
          </select>
          <div class="form-text" id="printerHelp" style="font-size: 10px; color: var(--text-muted); margin-top: 4px;">
            🖨️ Client printers automatically detected. Server printers marked with 🖥️.
          </div>
        </div>
        <div class="form-group">
          <label for="paperSize">Paper/Film Size:</label>
          <select id="paperSize" name="paper_size">
            <option value="A4">A4 (210 × 297 mm)</option>
            <option value="Letter">Letter (8.5 × 11 in)</option>
            <option value="FILM_14X17">Film 14" × 17"</option>
            <option value="FILM_11X14">Film 11" × 14"</option>
          </select>
        </div>
        <div class="form-group" id="paperTypeGroup">
          <label for="paperType">Paper Type:</label>
          <select id="paperType" name="paper_type">
            <option value="glossy">🌟 Glossy Photo Paper</option>
            <option value="matte">Matte Paper</option>
            <option value="plain">Plain Paper</option>
            <option value="film">Medical Film</option>
          </select>
        </div>
        <div class="form-group">
          <label for="printQuality">Print Quality:</label>
          <select id="printQuality" name="print_quality">
            <option value="high">High Quality (1200 DPI)</option>
            <option value="normal">Normal Quality (600 DPI)</option>
            <option value="draft">Draft Quality (300 DPI)</option>
          </select>
        </div>
        <div class="form-group">
          <label for="copies">Number of Copies:</label>
          <input type="number" id="copies" name="copies" value="1" min="1" max="10">
        </div>
        <div class="btn-group">
          <button type="button" id="cancelPrint" class="btn">Cancel</button>
          <button type="submit" id="submitPrint" class="btn btn-primary">
            <i class="fas fa-print"></i> Print Image
          </button>
        </div>
      </form>
    </div>
  </div>

  <script>
  (function(){

    // Store the referrer for back navigation
    (function() {
      const referrer = document.referrer;
      if (referrer && referrer.includes('/worklist/')) {
        sessionStorage.setItem('worklistReferrer', referrer);
      }
      
      // Update back button href dynamically
      const backBtn = document.getElementById('btnBackWorklist');
      if (backBtn) {
        const storedReferrer = sessionStorage.getItem('worklistReferrer');
        if (storedReferrer) {
          backBtn.href = storedReferrer;
        }
      }
    })();
    
    const canvas = document.getElementById('dicomCanvas');
    const ctx = canvas.getContext('2d');
    const seriesSelect = document.getElementById('seriesSelect');
    const wwSlider = document.getElementById('ww');
    const wlSlider = document.getElementById('wl');
    const wwNum = document.getElementById('wwNum');
    const wlNum = document.getElementById('wlNum');
    const sliceSlider = document.getElementById('slice');
    const zoomSlider = document.getElementById('zoom');
    const btnLoadLocal = document.getElementById('btnLoadLocal');
    const inputLocal = document.getElementById('localDicom');
    const btnClearMeasurements = document.getElementById('btnClearMeasurements');
    const measurementsList = document.getElementById('measurementsList');

    const reconType = document.getElementById('reconType');
    const boneCtrl = document.getElementById('boneCtrl');
    const boneSlider = document.getElementById('boneThreshold');
    const boneVal = document.getElementById('boneVal');
    const btnGenerateRecon = document.getElementById('btnGenerateRecon');
    const reconStatus = document.getElementById('reconStatus');
    const reconViews = document.getElementById('reconViews');
    const viewAxial = document.getElementById('viewAxial');
    const viewSagittal = document.getElementById('viewSagittal');
    const viewCoronal = document.getElementById('viewCoronal');

    // 3D dropdown controls
    const btn3D = document.getElementById('btn3D');
    const menu3D = document.getElementById('menu3D');
    
    // 3D dropdown functionality - Fixed with better state management
    if (btn3D && menu3D) {
      let dropdownOpen = false;
      
      btn3D.addEventListener('click', (e) => {
        e.stopPropagation();
        dropdownOpen = !dropdownOpen;
        menu3D.style.display = dropdownOpen ? 'flex' : 'none';
        btn3D.classList.toggle('active', dropdownOpen);
      });
      
      menu3D.addEventListener('click', (e) => {
        e.stopPropagation();
        const button = e.target.closest('button');
        if (button && button.dataset.recon) {
          const reconType = button.dataset.recon;
          try {
            generateReconstruction(reconType);
            
          } catch (error) {
            console.error('3D reconstruction error:', error);
            showToast(`Failed to start ${reconType.toUpperCase()} reconstruction`, 'error');
          }
          dropdownOpen = false;
          menu3D.style.display = 'none';
          btn3D.classList.remove('active');
        }
      });
      
      // Close dropdown when clicking outside
      document.addEventListener('click', (e) => {
        if (!btn3D.contains(e.target) && !menu3D.contains(e.target)) {
          dropdownOpen = false;
          menu3D.style.display = 'none';
          btn3D.classList.remove('active');
        }
      });
    }
    
    // Reduce initial image decode overhead for large previews
    [viewAxial, viewSagittal, viewCoronal].forEach(img=>{ if(img){ img.loading='eager'; img.decoding='async'; }});

    // Topbar extras
    const sortSelect = document.getElementById('sortSelect');
    const btnToggleTags = document.getElementById('btnToggleTags');
    const btnShowDicom = document.getElementById('btnShowDicom');
    const btnCapture = document.getElementById('btnCapture');
    const dicomModal = document.getElementById('dicomModal');
    const dicomTagsPre = document.getElementById('dicomTagsPre');
    const closeDicomModal = document.getElementById('closeDicomModal');
    const btnSavePreset = document.getElementById('btnSavePreset');
    const btnLoadPreset = document.getElementById('btnLoadPreset');

    // Capture button handler - Fixed with proper error handling
    if (btnCapture) {
      btnCapture.addEventListener('click', () => {
        try {
          if (!canvas || !canvas.getContext) {
            
              break;
              
            case 'mpr':
              // No-op, handled by 3D dropdown
              return;
              
            default:
              // Generic tool activation
              break;
          }
          
          // Handle MPR mode specifics
          if (mprMode) {
            const mprPanel = document.getElementById('mprMeasurePanel');
            if (mprPanel) {
              mprPanel.style.display = (tool === 'measure') ? '' : mprPanel.style.display;
            }
            return;
          }
          
          // Set active tool
          activeTool = tool;
          
        } catch (error) {
          console.error('Tool button error:', error);
          showToast(`Tool error: ${error.message}`, 'error');
        }
      });
    });

    // Mouse interactions on viewport
    const viewport = document.getElementById('viewport');
    viewport.addEventListener('mousedown', (e)=>{
      isDragging = true; dragStart = { x: e.offsetX, y: e.offsetY };
      // Start measurement draft
      if (activeTool === 'measure'){
        if (mprMode){
          const halfW = Math.floor(canvas.width/2), halfH = Math.floor(canvas.height/2);
          const mx = e.offsetX, my = e.offsetY;
          let plane = null; if (mx < halfW && my < halfH) plane='sagittal'; else if (mx>=halfW && my<halfH) plane='coronal'; else if (mx<halfW && my>=halfH) plane='axial';
          if (mprFullPlane) plane = mprFullPlane;
          if (mprMeasurePlaneMode !== 'auto') plane = mprMeasurePlaneMode;
          if (plane && mprRegionVps[plane]){
            const vpR = mprRegionVps[plane];
            // Ignore clicks outside the image bounds within region
            if (mx < vpR.x || mx > vpR.x + vpR.imgW * vpR.scale || my < vpR.y || my > vpR.y + vpR.imgH * vpR.scale) {
              return;
            }
            const imgPt = canvasToImageCoords(vpR, e.offsetX, e.offsetY);
            measureDraft = { plane, start: imgPt, end: imgPt };
          }
        } else {
          const vp2 = lastVp || { x:0, y:0, scale:1 };
          measureDraft = { start: canvasToImageCoords(vp2, e.offsetX, e.offsetY), end: canvasToImageCoords(vp2, e.offsetX, e.offsetY) };
        }
      }
      if (mprMode && activeTool === 'crosshair'){
        const halfW = Math.floor(canvas.width/2), halfH = Math.floor(canvas.height/2);
        const mx = e.offsetX, my = e.offsetY;
        let plane = null; if (mx < halfW && my < halfH) plane='sagittal'; else if (mx>=halfW && my<halfH) plane='coronal'; else if (mx<halfW && my>=halfH) plane='axial';
        if (plane && mprRegionVps[plane]){
          const vpR = mprRegionVps[plane];
          // Ignore clicks outside the image bounds within region
          if (mx < vpR.x || mx > vpR.x + vpR.imgW * vpR.scale || my < vpR.y || my > vpR.y + vpR.imgH * vpR.scale) {
            return;
          }
          const imgPt = canvasToImageCoords(vpR, mx, my);
          // Update crosshair global coordinates and synchronize all planes
          const oldCross = {...mprCross};
          let needsUpdate = false;
          
          if (plane === 'axial'){
            const newX = Math.round(imgPt.x);
            const newY = Math.round(imgPt.y);
            if (mprCross.x !== newX || mprCross.y !== newY) {
              mprCross.x = newX;
              mprCross.y = newY;
              mprScroll.sagittal = Math.max(0, Math.min((mprScroll.counts.sagittal||1)-1, newX));
              mprScroll.coronal = Math.max(0, Math.min((mprScroll.counts.coronal||1)-1, newY));
              needsUpdate = true;
            }
          } else if (plane === 'sagittal'){
            // sagittal image: x->height(y), y->depth(z)
            const newY = Math.round(imgPt.x);
            const newZ = Math.round(imgPt.y);
            if (mprCross.y !== newY || mprCross.z !== newZ) {
              mprCross.y = newY;
              mprCross.z = newZ;
              mprScroll.axial = Math.max(0, Math.min((mprScroll.counts.axial||1)-1, newZ));
              mprScroll.coronal = Math.max(0, Math.min((mprScroll.counts.coronal||1)-1, newY));
              needsUpdate = true;
            }
          } else if (plane === 'coronal'){
            // coronal image: x->width(x), y->depth(z)
            const newX = Math.round(imgPt.x);
            const newZ = Math.round(imgPt.y);
            if (mprCross.x !== newX || mprCross.z !== newZ) {
              mprCross.x = newX;
              mprCross.z = newZ;
              mprScroll.axial = Math.max(0, Math.min((mprScroll.counts.axial||1)-1, newZ));
              mprScroll.sagittal = Math.max(0, Math.min((mprScroll.counts.sagittal||1)-1, newX));
              needsUpdate = true;
            }
          }
          
          if (needsUpdate) {
            // Force refresh of all plane images when crosshair moves
            mprImgs = { axial: null, sagittal: null, coronal: null };
            
            // Prefetch the new slice positions for smooth interaction
            prefetchMprSlices('axial', mprScroll.axial, 2);
            prefetchMprSlices('sagittal', mprScroll.sagittal, 2);
            prefetchMprSlices('coronal', mprScroll.coronal, 2);
            
            draw();
          }
        }
      }
      if (showHuProbe){
        if (mprMode){
          // determine plane by quadrant
          const halfW = Math.floor(canvas.width/2), halfH = Math.floor(canvas.height/2);
          const mx = e.offsetX, my = e.offsetY;
          let plane = null; if (mx < halfW && my < halfH) plane='sagittal'; else if (mx>=halfW && my<halfH) plane='coronal'; else if (mx<halfW && my>=halfH) plane='axial';
          if (plane && mprRegionVps[plane]){
            const vpR = mprRegionVps[plane];
            const imgPt = canvasToImageCoords(vpR, e.offsetX, e.offsetY);
            huEllipse = { mode:'mpr', plane, slice: (mprScroll[plane]||0), cx: imgPt.x, cy: imgPt.y, rx: 1, ry: 1 };
          }
        } else if (lastVp){
          const imgPt = canvasToImageCoords(lastVp, e.offsetX, e.offsetY);
          huEllipse = { mode:'series', cx: imgPt.x, cy: imgPt.y, rx: 1, ry: 1 };
        }
        draw();
      }
      if (spyglass.active){ spyglass.isPress = true; spyglass.cx = e.offsetX; spyglass.cy = e.offsetY; draw(); }
    });
    viewport.addEventListener('mousemove', async (e)=>{
      if (!isDragging) { if (spyglass.active && spyglass.isPress){ spyglass.cx = e.offsetX; spyglass.cy = e.offsetY; requestDraw(); } return; }
      const vp = lastVp || { x:0, y:0, scale:1 };
      if (activeTool === 'window'){
        const dx = e.offsetX - dragStart.x; const dy = e.offsetY - dragStart.y; dragStart = { x: e.offsetX, y: e.offsetY };
        ww = Math.max(1, ww + dx*4); wl = wl + dy*2; wwSlider.value = Math.round(ww); wlSlider.value = Math.round(wl); document.getElementById('wwVal').textContent = Math.round(ww); document.getElementById('wlVal').textContent = Math.round(wl); requestDraw();
      } else if (activeTool === 'pan'){
        panOffset.x += (e.offsetX - dragStart.x); panOffset.y += (e.offsetY - dragStart.y); dragStart = { x: e.offsetX, y: e.offsetY }; requestDraw();
      } else if (activeTool === 'measure' && measureDraft){
        if (mprMode && measureDraft.plane && mprRegionVps[measureDraft.plane]){
          const vpR = mprRegionVps[measureDraft.plane];
          measureDraft.end = canvasToImageCoords(vpR, e.offsetX, e.offsetY);
        } else {
          measureDraft.end = canvasToImageCoords(vp, e.offsetX, e.offsetY);
        }
        requestDraw();
      } else if (activeTool === 'annotate'){
        // no-op while dragging
      } else if (activeTool === 'zoom'){
        const dy = e.offsetY - dragStart.y; dragStart = { x: e.offsetX, y: e.offsetY }; const factor = dy<0 ? 1.05 : 0.95; zoom = Math.min(5.0, Math.max(0.25, zoom*factor)); zoomSlider.value = Math.round(zoom*100); document.getElementById('zoomVal').textContent = `${Math.round(zoom*100)}%`; requestDraw();
      } else if (mprMode && activeTool === 'crosshair'){
        const halfW = Math.floor(canvas.width/2), halfH = Math.floor(canvas.height/2);
        const mx = e.offsetX, my = e.offsetY;
        let plane = null; if (mx < halfW && my < halfH) plane='sagittal'; else if (mx>=halfW && my<halfH) plane='coronal'; else if (mx<halfW && my>=halfH) plane='axial';
        if (mprFullPlane) plane = mprFullPlane;
        if (plane && mprRegionVps[plane]){
          const vpR = mprRegionVps[plane];
          // Ignore clicks outside the image bounds within region
          if (mx < vpR.x || mx > vpR.x + vpR.imgW * vpR.scale || my < vpR.y || my > vpR.y + vpR.imgH * vpR.scale) {
            return;
          }
          const imgPt = canvasToImageCoords(vpR, mx, my);
          
          // Update crosshair global coordinates and synchronize all planes
          const oldCross = {...mprCross};
          
          if (plane === 'axial'){
            mprCross.x = Math.round(imgPt.x);
            mprCross.y = Math.round(imgPt.y);
            // Update orthogonal planes to intersect this point
            mprScroll.sagittal = Math.max(0, Math.min((mprScroll.counts.sagittal||1)-1, mprCross.x));
            mprScroll.coronal = Math.max(0, Math.min((mprScroll.counts.coronal||1)-1, mprCross.y));
          } else if (plane === 'sagittal'){
            // sagittal image: x->height(y), y->depth(z)
            mprCross.y = Math.round(imgPt.x);
            mprCross.z = Math.round(imgPt.y);
            mprScroll.axial = Math.max(0, Math.min((mprScroll.counts.axial||1)-1, mprCross.z));
            mprScroll.coronal = Math.max(0, Math.min((mprScroll.counts.coronal||1)-1, mprCross.y));
          } else if (plane === 'coronal'){
            // coronal image: x->width(x), y->depth(z)
            mprCross.x = Math.round(imgPt.x);
            mprCross.z = Math.round(imgPt.y);
            mprScroll.axial = Math.max(0, Math.min((mprScroll.counts.axial||1)-1, mprCross.z));
            mprScroll.sagittal = Math.max(0, Math.min((mprScroll.counts.sagittal||1)-1, mprCross.x));
          }
          
          // Check if crosshair position actually changed
          const crossChanged = (oldCross.x !== mprCross.x || oldCross.y !== mprCross.y || oldCross.z !== mprCross.z);
          
          if (crossChanged) {
            // Prefetch new slices for updated orthogonal planes
            console.log(`Crosshair moved to [${mprCross.x}, ${mprCross.y}, ${mprCross.z}]`);
            
            // Update slice indicators
            document.querySelector('[data-plane="axial"] .slice-indicator')?.textContent = `${mprScroll.axial + 1}/${mprScroll.counts.axial || 0}`;
            document.querySelector('[data-plane="sagittal"] .slice-indicator')?.textContent = `${mprScroll.sagittal + 1}/${mprScroll.counts.sagittal || 0}`;
            document.querySelector('[data-plane="coronal"] .slice-indicator')?.textContent = `${mprScroll.coronal + 1}/${mprScroll.counts.coronal || 0}`;
            
            // Load new slices for orthogonal planes immediately
            const loadPromises = [];
            if (plane !== 'axial') {
              loadPromises.push(getMprImage(currentSeries.id, 'axial', mprScroll.axial).then(img => {
                mprImgs.axial = img;
              }));
            }
            if (plane !== 'sagittal') {
              loadPromises.push(getMprImage(currentSeries.id, 'sagittal', mprScroll.sagittal).then(img => {
                mprImgs.sagittal = img;
              }));
            }
            if (plane !== 'coronal') {
              loadPromises.push(getMprImage(currentSeries.id, 'coronal', mprScroll.coronal).then(img => {
                mprImgs.coronal = img;
              }));
            }
            
            // Wait for all images to load then redraw
            Promise.all(loadPromises).then(() => {
              requestDraw();
            }).catch(err => {
              console.error('Error loading orthogonal images:', err);
              requestDraw(); // Draw anyway
            });
            
            // Also prefetch surrounding slices
            prefetchMprSlices('axial', mprScroll.axial, 2);
            prefetchMprSlices('sagittal', mprScroll.sagittal, 2);
            prefetchMprSlices('coronal', mprScroll.coronal, 2);
          }
          
          requestDraw();
        }
      } else if (showHuProbe && huEllipse){
        if (huEllipse.mode==='mpr' && mprRegionVps[huEllipse.plane]){
          const vpR = mprRegionVps[huEllipse.plane];
          const cur = canvasToImageCoords(vpR, e.offsetX, e.offsetY);
          huEllipse.rx = Math.abs(cur.x - huEllipse.cx);
          huEllipse.ry = Math.abs(cur.y - huEllipse.cy);
          requestDraw();
        } else if (lastVp && huEllipse.mode==='series'){
          const cur = canvasToImageCoords(lastVp, e.offsetX, e.offsetY);
          huEllipse.rx = Math.abs(cur.x - huEllipse.cx);
          huEllipse.ry = Math.abs(cur.y - huEllipse.cy);
          requestDraw();
        }
      }
    });
    // HU probe on mousemove in MPR when enabled
    viewport.addEventListener('mousemove', async (e)=>{
      if (!mprMode || !showHuProbe) return;
      
      // Skip if we're in the middle of dragging to resize an ellipse
      if (isDragging && huEllipse) return;
      // Determine which plane region the mouse is in
      const halfW = Math.floor(canvas.width/2), halfH = Math.floor(canvas.height/2);
      const mx = e.offsetX, my = e.offsetY;
      let plane = null; if (mx < halfW && my < halfH) plane='sagittal'; else if (mx>=halfW && my<halfH) plane='coronal'; else if (mx<halfW && my>=halfH) plane='axial';
      if (mprFullPlane) plane = mprFullPlane;
      if (!plane || !mprRegionVps[plane]) return;
      try {
        const vpR = mprRegionVps[plane];
        const imgPt = canvasToImageCoords(vpR, mx, my);
        const px = Math.max(0, Math.min(vpR.imgW-1, imgPt.x));
        const py = Math.max(0, Math.min(vpR.imgH-1, imgPt.y));
        // Query HU from backend
        const q = new URLSearchParams();
        q.set('mode','mpr'); q.set('series_id', currentSeries.id); q.set('plane', plane);
        q.set('slice', mprScroll[plane]||0); q.set('x', Math.floor(px)); q.set('y', Math.floor(py));
        try {
          const resp = await fetch(`/dicom-viewer/api/hu/?${q.toString()}`);
          const j = await resp.json();
          if (j && typeof j.hu === 'number'){
            document.getElementById('overlay').innerHTML = `HU (${plane}): ${j.hu} @ x:${Math.floor(px)} y:${Math.floor(py)} slice:${(mprScroll[plane]||0)+1}/${mprScroll.counts[plane]||0}`;
          }
        } catch(e){}
      } catch(e){}
    });
    viewport.addEventListener('mouseup', async (e)=>{
      if (!isDragging) return; isDragging = false;
      const vp = lastVp || { x:0, y:0, scale:1 };
      if (activeTool === 'measure' && measureDraft){
        if (mprMode && measureDraft.plane && mprRegionVps[measureDraft.plane]){
          const vpR = mprRegionVps[measureDraft.plane];
          measureDraft.end = canvasToImageCoords(vpR, e.offsetX, e.offsetY);
          const plane = measureDraft.plane;
          const m = { plane, start: measureDraft.start, end: measureDraft.end };
          const dist = mprImageDistance(plane, m.start, m.end);
          if (dist.mm){
            const mm = dist.mm; const cm = mm/10.0;
            m.label = (measureUnit==='cm') ? `${cm.toFixed(2)} cm` : `${mm.toFixed(2)} mm`;
          } else { m.label = `${dist.px.toFixed(1)} px`; }
          mprMeasurements[plane].push(m);
          measureDraft = null; await draw();
        } else {
          measureDraft.end = canvasToImageCoords(vp, e.offsetX, e.offsetY);
          const m = { start: measureDraft.start, end: measureDraft.end };
          measureDraft = null; measurements.push(m); imageIdToMeasurements.set(getCurrentImageId(), measurements);
          await saveMeasurementToServer(m); renderMeasurementsList(); await draw();
        }
      } else if (activeTool === 'annotate'){
        const pos = canvasToImageCoords(vp, e.offsetX, e.offsetY);
                 // Create inline annotation with default text
         const text = 'Annotation';
         annotations.push({ pos, text }); 
         imageIdToAnnotations.set(getCurrentImageId(), annotations); 
         await saveAnnotationToServer(pos, text); 
         await draw();
         showToast('Annotation added', 'success', 2000);
      } else if (showHuProbe && huEllipse){
        // Submit ROI to backend
        try {
          const qp = new URLSearchParams();
          qp.set('shape','ellipse');
          if (huEllipse.mode==='series'){
            qp.set('mode','series');
            qp.set('image_id', String(getCurrentImageId()));
          } else {
            qp.set('mode','mpr');
            qp.set('series_id', String(currentSeries.id));
            qp.set('plane', huEllipse.plane);
            qp.set('slice', String(huEllipse.slice||0));
          }
          qp.set('cx', Math.round(huEllipse.cx));
          qp.set('cy', Math.round(huEllipse.cy));
          qp.set('rx', Math.max(1, Math.round(huEllipse.rx)));
          qp.set('ry', Math.max(1, Math.round(huEllipse.ry)));
          const r = await fetch(`/dicom-viewer/api/hu/?${qp.toString()}`);
          const j = await r.json();
          if (j && j.stats){
            const s = j.stats; // mean, std, min, max, n
            document.getElementById('overlay').innerHTML = `HU ROI (ellipse): mean ${s.mean.toFixed(1)}, sd ${s.std.toFixed(1)}, min ${s.min.toFixed(0)}, max ${s.max.toFixed(0)} (n=${s.n})`;
          }
        } catch(e){}
        await draw();
      }
      if (spyglass.active){ spyglass.isPress = false; }
    });
    // Double-click enlarge/restore MPR plane
    viewport.addEventListener('dblclick', async (e)=>{
      if (!mprMode) return;
      if (mprFullPlane) { mprFullPlane = null; await draw(); return; }
      const halfW = Math.floor(canvas.width/2), halfH = Math.floor(canvas.height/2);
      const mx = e.offsetX, my = e.offsetY;
      let plane = null; if (mx < halfW && my < halfH) plane='sagittal'; else if (mx>=halfW && my<halfH) plane='coronal'; else if (mx<halfW && my>=halfH) plane='axial';
      if (plane) { mprFullPlane = plane; await draw(); }
    });

    // Mouse wheel slice/zoom
    document.getElementById('viewport').addEventListener('wheel', async (e)=>{
      e.preventDefault();
      if (spyglass.active && spyglass.isPress){
        const d = e.deltaY>0 ? -10 : 10; spyglass.radius = Math.max(20, Math.min(300, spyglass.radius + d)); requestDraw(); return;
      }
      if (reconMode && reconImgs.length){
        const d = e.deltaY>0 ? 1 : -1;
        reconIndex = Math.max(0, Math.min(reconImgs.length-1, reconIndex + d));
        requestDraw();
        return;
      }
      if (mprMode){
        // Determine which quadrant and scroll that plane
        const halfW = Math.floor(canvas.width/2), halfH = Math.floor(canvas.height/2);
        const mx = e.offsetX, my = e.offsetY; const d = e.deltaY>0 ? 1 : -1;
        let plane = null;
        if (mx < halfW && my < halfH) plane = 'sagittal';
        else if (mx >= halfW && my < halfH) plane = 'coronal';
        else if (mx < halfW && my >= halfH) plane = 'axial';
        else plane = null; // bottom-right empty
        if (mprFullPlane) plane = mprFullPlane;
        if (!plane) return;
        const count = (mprScroll.counts[plane]||1);
        const cur = (mprScroll[plane]||0);
        const ni = Math.max(0, Math.min(count-1, cur + d));
                 if (ni !== cur){
           mprScroll[plane] = ni;
           
           // Keep crosshair in sync with the scrolled plane axis and update other planes
           if (plane === 'axial') {
             mprCross.z = ni;
           } else if (plane === 'sagittal') {
             mprCross.x = ni;
             // Update coronal slice to intersect at this sagittal position
             mprScroll.coronal = Math.max(0, Math.min((mprScroll.counts.coronal||1)-1, mprCross.y));
           } else if (plane === 'coronal') {
             mprCross.y = ni;
             // Update sagittal slice to intersect at this coronal position  
             mprScroll.sagittal = Math.max(0, Math.min((mprScroll.counts.sagittal||1)-1, mprCross.x));
           }
           
           // Clear images to force refresh with new slice positions
           mprImgs = { axial: null, sagittal: null, coronal: null };
           
           prefetchMprSlices(plane, ni);
           await draw();
         }
        return;
      }
      if (e.ctrlKey){ const delta = e.deltaY>0?0.9:1.1; zoom = Math.max(0.1, Math.min(5.0, zoom*delta)); zoomSlider.value = Math.round(zoom*100); document.getElementById('zoomVal').textContent = `${Math.round(zoom*100)}%`; requestDraw(); }
      else { const d = e.deltaY>0?1:-1; const ni = Math.max(0, Math.min(images.length-1, index+d)); if (ni !== index){ index = ni; sliceSlider.value = index; document.getElementById('sliceVal').textContent = index+1; requestDraw(); debouncedLoadOverlaysForCurrentImage(); prefetchAround(index, 3); } }
    }, { passive:false });

    // Local DICOM upload with debounce protection
    let uploadInProgress = false;
    
    // Load Local DICOM button - Fixed with better state management
    if (btnLoadLocal && inputLocal) {
      btnLoadLocal.addEventListener('click', () => {
        if (uploadInProgress) {
          showToast('Upload already in progress', 'warning');
          return;
        }
        try {
          inputLocal.click();
        } catch (error) {
          console.error('File input error:', error);
          showToast('Failed to open file dialog', 'error');
        }
      });
    }
    
    // File input change handler - Fixed with comprehensive error handling
    if (inputLocal) {
      inputLocal.addEventListener('change', async (e) => {
        try {
          if (uploadInProgress) {
            showToast('Upload already in progress', 'warning');
            return;
          }
          
          const files = e.target.files ? Array.from(e.target.files) : [];
          if (!files.length) {
            showToast('No files selected', 'warning');
            return;
          }
          
          // Validate file types
          const validFiles = files.filter(file => {
            const name = file.name.toLowerCase();
            return name.endsWith('.dcm') || name.endsWith('.dicom') || file.type === 'application/dicom' || file.size > 132;
          });
          
          if (validFiles.length === 0) {
            showToast('No valid DICOM files found', 'error');
            return;
          }
          
          if (validFiles.length < files.length) {
            showToast(`${files.length - validFiles.length} non-DICOM files filtered out`, 'warning');
          }
          
          // Set upload state immediately
          uploadInProgress = true;
          btnLoadLocal.disabled = true;
          btnLoadLocal.style.pointerEvents = 'none';
          btnLoadLocal.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Uploading...';
          reconStatus.textContent = `Uploading ${validFiles.length} DICOM files...`;
          showProgressIndicator();
          
          const CHUNK_SIZE = 50; // Reduced for better reliability
          const MAX_PARALLEL = 2;
          const chunks = [];
          for (let i = 0; i < validFiles.length; i += CHUNK_SIZE) {
            chunks.push(validFiles.slice(i, i + CHUNK_SIZE));
          }
          
          let current = 0;
          let lastStudyId = null;
          let errors = 0;
          
          async function uploadChunk(chunk) {
            try {
              const form = new FormData();
              chunk.forEach(f => form.append('dicom_files', f));
              
              const resp = await fetch('/dicom-viewer/upload/', { 
                method: 'POST', 
                body: form,
                headers: {
                  'X-Requested-With': 'XMLHttpRequest'
                }
              });
              
              if (!resp.ok) {
                const errorText = await resp.text();
                console.error('Upload failed with status:', resp.status, errorText);
                errors++;
                return;
              }
              
              const data = await resp.json();
              
              if (!data.success) {
                console.error('Upload chunk failed:', data.error);
                errors++;
                return;
              }
              
              current += chunk.length;
              if (!lastStudyId && data.study_id) lastStudyId = data.study_id;
              reconStatus.textContent = `Uploading... ${current}/${validFiles.length} (${Math.round(current/validFiles.length*100)}%)`;
              
            } catch (error) {
              console.error('Upload chunk error:', error);
              errors++;
            }
          }
          
          // Process chunks with controlled parallelism
          let chunkIndex = 0;
          const workers = Array.from({length: Math.min(MAX_PARALLEL, chunks.length)}).map(async () => {
            while (chunkIndex < chunks.length) {
              const currentChunk = chunkIndex++;
              if (currentChunk < chunks.length) {
                await uploadChunk(chunks[currentChunk]);
              }
            }
          });
          
          await Promise.all(workers);
          
          if (errors > 0 && current === 0) {
            throw new Error('All upload chunks failed');
          }
          
          if (errors > 0) {
            showToast(`Upload completed with ${errors} errors`, 'warning');
          }
          
          reconStatus.textContent = 'Upload complete. Loading study...';
          
          if (lastStudyId) {
            await loadStudy(lastStudyId);
            showToast('DICOM files uploaded and loaded successfully', 'success');
          } else {
            throw new Error('No study ID returned from upload');
          }
          
          reconStatus.textContent = '';
          
        } catch (err) {
          console.error('Upload error:', err);
          reconStatus.textContent = `Error: ${err.message}`;
          showToast(`Upload failed: ${err.message}`, 'error');
          // Don't fallback to desktop for upload errors
        } finally {
          // Reset upload state
          uploadInProgress = false;
          btnLoadLocal.disabled = false;
          btnLoadLocal.style.pointerEvents = '';
          btnLoadLocal.innerHTML = '<i class="fas fa-folder-open"></i> Load Local DICOM';
          hideProgressIndicator();
          
          // Reset file input and clear any lingering progress indicators
          inputLocal.value = '';
          reconStatus.textContent = '';
          e.target.value = '';
        }
      });
    }

    // Recon controls
    reconType.addEventListener('change', ()=>{
      const v = reconType.value; boneCtrl.style.display = v==='bone' ? '' : 'none';
    });
    boneSlider.addEventListener('input', e=> boneVal.textContent = e.target.value);

    // Debounce mechanism for reconstruction buttons to prevent multiple clicks
    let reconstructionTimeout = null;

    // Extracted function so both dropdown and button can trigger
    async function generateReconstruction(kind){
      try {
        // Prevent multiple simultaneous reconstruction requests
        if (reconstructionInProgress) {
          console.warn('Reconstruction already in progress');
          return;
        }
        
        if (!currentSeries || !currentSeries.id){ 
          console.warn('Select a series first'); 
          reconStatus.textContent = 'Please select a series first';
          return; 
        }
        
        // Set loading state immediately to prevent UI freezing
        reconstructionInProgress = true;
        reconStatus.textContent = 'Preparing reconstruction...';
        
        // Disable reconstruction buttons during processing
        const reconButtons = document.querySelectorAll('[data-recon], #btnGenerateRecon');
        reconButtons.forEach(btn => btn.style.pointerEvents = 'none');
        
        // Show progress indicator
        showProgressIndicator();
        
        // Clear any cached MPR images to ensure fresh load
        mprImgs = {};
        
        reconMode = null; reconImgs = []; reconIndex = 0; panOffset = {x:0,y:0}; zoom = 1.0;
        const params = new URLSearchParams();
        params.set('window_width', ww);
        params.set('window_level', wl);
        params.set('inverted', inverted);
        let url = '';
        const type = kind || reconType.value;
        if (type === 'mpr') url = `/dicom-viewer/api/series/${currentSeries.id}/mpr/?${params.toString()}`;
        else if (type === 'mip') url = `/dicom-viewer/api/series/${currentSeries.id}/mip/?quality=high&${params.toString()}`;
        else { url = `/dicom-viewer/api/series/${currentSeries.id}/bone/?threshold=${boneSlider.value}&mesh=true&quality=high`; }
        
        console.log(`Requesting reconstruction: ${type}, URL: ${url}`);
        
        // Add timeout and progress updates
        const controller = new AbortController();
        const timeoutId = setTimeout(() => {
          controller.abort();
          throw new Error('Reconstruction timeout - please try again');
        }, 180000); // 3 minute timeout for slow connections
        
        reconStatus.textContent = 'Loading reconstruction...';
        
        const r = await fetch(url, { 
          signal: controller.signal,
          headers: {
            'Cache-Control': 'no-cache',
            'Pragma': 'no-cache'
          }
        });
        
        clearTimeout(timeoutId);
        console.log(`Response status: ${r.status}`);
        
        if (!r.ok) {
          const errorText = await r.text();
          throw new Error(`HTTP ${r.status}: ${errorText}`);
        }
        
        reconStatus.textContent = 'Processing data...';
        
        const j = await r.json();
        console.log(`Response data:`, j);
        
        if (j.error) throw new Error(j.error);
        
        if (j.mpr_views){ 
          console.log('Processing MPR views');
          reconMode = 'mpr'; 
          reconImgs = [j.mpr_views.axial, j.mpr_views.sagittal, j.mpr_views.coronal]; 
          console.log('MPR images:', reconImgs.map(img => img ? 'loaded' : 'null'));
          mprMode = true; 
          document.getElementById('mprMeasurePanel').style.display=''; 
          if (j.counts){ 
            mprScroll.counts = j.counts; 
            mprScroll.axial = Math.floor((j.counts.axial||0)/2); 
            mprScroll.sagittal = Math.floor((j.counts.sagittal||0)/2); 
            mprScroll.coronal = Math.floor((j.counts.coronal||0)/2); 
            mprCross = { x: mprScroll.sagittal, y: mprScroll.coronal, z: mprScroll.axial }; 
            prefetchMprSlices('axial', mprScroll.axial); 
            prefetchMprSlices('sagittal', mprScroll.sagittal); 
            prefetchMprSlices('coronal', mprScroll.coronal); 
          } 
        }
        if (j.mip_views){ 
          console.log('Processing MIP views');
          reconMode = 'mip'; 
          reconImgs = [j.mip_views.axial, j.mip_views.sagittal, j.mip_views.coronal]; 
          console.log('MIP images:', reconImgs.map(img => img ? 'loaded' : 'null'));
          document.getElementById('mprMeasurePanel').style.display='none'; 
          mprMode = true; 
          mprFullPlane = null; 
          mprScroll.counts = j.counts || mprScroll.counts; 
        }
        if (j.bone_views){ 
          console.log('Processing bone views');
          reconMode = 'bone'; 
          reconImgs = [j.bone_views.axial || j.bone_views.bone_axial_preview, j.bone_views.sagittal || j.bone_views.bone_sagittal_preview, j.bone_views.coronal || j.bone_views.bone_coronal_preview]; 
          console.log('Bone images:', reconImgs.map(img => img ? 'loaded' : 'null'));
          document.getElementById('mprMeasurePanel').style.display='none'; 
          mprMode = true; 
          mprFullPlane = null; 
          if (j.mesh) showBone3D(j.mesh); 
        }
        reconImgs = reconImgs.filter(Boolean);
        reconIndex = 0;
        console.log(`Final reconstruction mode: ${reconMode}, images: ${reconImgs.length}`);
        await draw();
        reconStatus.textContent = 'Done'; setTimeout(()=> reconStatus.textContent = '', 1500);
      } catch (err){
        console.error('Reconstruction error:', err);
        reconStatus.textContent = `Error: ${err.message}`;
        await fallbackToDesktop();
      } finally {
        // Re-enable reconstruction buttons and reset state
        reconstructionInProgress = false;
        hideProgressIndicator();
        const reconButtons = document.querySelectorAll('[data-recon], #btnGenerateRecon');
        reconButtons.forEach(btn => btn.style.pointerEvents = '');
      }
    }
 
           // Generate reconstruction button - Fixed with proper reconstruction type detection
           if (btnGenerateRecon) {
             btnGenerateRecon.addEventListener('click', () => {
               const selectedType = reconType.value || 'mpr';
               try {
                 generateReconstruction(selectedType);
               } catch (error) {
                 console.error('Reconstruction button error:', error);
                 showToast(`Failed to start reconstruction: ${error.message}`, 'error');
               }
             });
           }

            // Simple back navigation
      function returnToWorklist(e){
        if (e) e.preventDefault();
        window.history.back();
        return false;
      }
      // expose for inline onclick
      window.returnToWorklist = returnToWorklist;

    // Preload MPR mid-slices after series load to avoid UI stall on first click
    function warmupMpr(){
      if (!currentSeries || !currentSeries.id) return;
      const params = new URLSearchParams(); params.set('window_width', ww); params.set('window_level', wl); params.set('inverted', inverted);
      fetch(`/dicom-viewer/api/series/${currentSeries.id}/mpr/?${params.toString()}`)
        .then(r=>r.json())
        .then(j=>{ if (j && j.counts) { mprScroll.counts = j.counts; mprScroll.axial = Math.floor((j.counts.axial||0)/2); mprScroll.sagittal = Math.floor((j.counts.sagittal||0)/2); mprScroll.coronal = Math.floor((j.counts.coronal||0)/2); prefetchMprSlices('axial', mprScroll.axial); prefetchMprSlices('sagittal', mprScroll.sagittal); prefetchMprSlices('coronal', mprScroll.coronal);} })
        .catch(()=>{});
    }
 
     // 3D dropdown interactions (already handled above)
 
     // Clear measurements - Fixed with confirmation and feedback
     if (btnClearMeasurements) {
       btnClearMeasurements.addEventListener('click', () => {
         try {
           const hasMeasurements = mprMode ? 
             (mprMeasurements.axial.length > 0 || mprMeasurements.sagittal.length > 0 || mprMeasurements.coronal.length > 0) :
             (measurements.length > 0);
           
           if (!hasMeasurements) {
             showToast('No measurements to clear', 'info');
             return;
           }
           
           if (!confirm('Are you sure you want to clear all measurements?')) {
             return;
           }
           
           if (mprMode) {
             mprMeasurements.axial = [];
             mprMeasurements.sagittal = [];
             mprMeasurements.coronal = [];
             showToast('MPR measurements cleared', 'success');
           } else {
             measurements = [];
             const imageId = getCurrentImageId();
             if (imageId) {
               imageIdToMeasurements.set(imageId, measurements);
             }
             renderMeasurementsList();
             showToast('Measurements cleared', 'success');
           }
           
           draw();
           
         } catch (error) {
           console.error('Clear measurements error:', error);
           showToast(`Failed to clear measurements: ${error.message}`, 'error');
         }
       });
     }

     // Sorting
     sortSelect.addEventListener('change', async ()=>{
       if (!images || !images.length) return;
       const mode = sortSelect.value;
       if (mode === 'inst_desc') images.sort((a,b)=> (b.instance_number||0) - (a.instance_number||0));
       else images.sort((a,b)=> (a.instance_number||0) - (b.instance_number||0));
       index = 0; sliceSlider.max = Math.max(0, images.length - 1); sliceSlider.value = 0; document.getElementById('sliceVal').textContent = '1';
       await loadOverlaysForCurrentImage();
     });

     // Toggle tags overlay
     btnToggleTags.addEventListener('click', async ()=>{
       showTagsOverlay = !showTagsOverlay; await loadOverlaysForCurrentImage();
     });

     // Show DICOM modal - Removed duplicate handler (handled above with better error handling)
     closeDicomModal.addEventListener('click', ()=>{ dicomModal.style.display = 'none'; });
     dicomModal.addEventListener('click', (e)=>{ if (e.target === dicomModal) dicomModal.style.display = 'none'; });

     // Capture canvas - Removed duplicate handler (handled above with better error handling)

     // Print functionality
     const btnPrint = document.getElementById('btnPrint');
     const printModal = document.getElementById('printModal');
     const closePrintModal = document.getElementById('closePrintModal');
     const cancelPrint = document.getElementById('cancelPrint');
     const printForm = document.getElementById('printForm');
     const printerSelect = document.getElementById('printerSelect');
     
     // Client-side printer detection and capabilities
     async function loadClientPrinters() {
       printerSelect.innerHTML = '<option value="">Detecting printers...</option>';
       
       try {
         // Check if the browser supports the Print API
         if ('navigator' in window && 'print' in navigator) {
           console.log('Browser print API available');
         }
         
         // Use the modern approach with Print API if available
         if (window.navigator && window.navigator.printer) {
           try {
             const printers = await window.navigator.printer.getPrinters();
             if (printers && printers.length > 0) {
               printerSelect.innerHTML = '';
               printers.forEach((printer, index) => {
                 const option = document.createElement('option');
                 option.value = `client:${printer.id || index}`;
                 option.textContent = `🖨️ ${printer.name || `Printer ${index + 1}`}`;
                 printerSelect.appendChild(option);
               });
               return;
             }
           } catch (e) {
             console.log('Print API not fully supported:', e);
           }
         }
         
         // Fallback: Auto-detect using browser's print dialog capabilities
         await detectPrintersFromMediaQuery();
         
       } catch (error) {
         console.error('Error detecting client printers:', error);
         printerSelect.innerHTML = '<option value="browser">🖨️ Use Browser Print Dialog</option>';
       }
     }
     
     // Detect printer capabilities using media queries and print dialog
     async function detectPrintersFromMediaQuery() {
       printerSelect.innerHTML = '';
       
       // Add default browser printing option
       const browserOption = document.createElement('option');
       browserOption.value = 'browser';
       browserOption.textContent = '🖨️ System Default Printer (Browser)';
       browserOption.selected = true;
       printerSelect.appendChild(browserOption);
       
       // Try to detect common printer types and capabilities
       const printCapabilities = {
         color: window.matchMedia('print and (color)').matches,
         grayscale: window.matchMedia('print and (monochrome)').matches,
         highResolution: window.matchMedia('print and (min-resolution: 300dpi)').matches,
         a4: window.matchMedia('print and (width: 210mm)').matches,
         letter: window.matchMedia('print and (width: 8.5in)').matches
       };
       
       console.log('Detected print capabilities:', printCapabilities);
       
       // Add high-quality option if supported
       if (printCapabilities.highResolution || printCapabilities.color) {
         const hqOption = document.createElement('option');
         hqOption.value = 'browser-hq';
         hqOption.textContent = '🖨️ High Quality Print (300+ DPI)';
         printerSelect.appendChild(hqOption);
       }
       
       // Add photo printer option
       const photoOption = document.createElement('option');
       photoOption.value = 'browser-photo';
       photoOption.textContent = '📸 Photo Quality Print';
       printerSelect.appendChild(photoOption);
       
       // Store capabilities for later use
       window.detectedPrintCapabilities = printCapabilities;
     }

     // Print button - Fixed with comprehensive error handling
     if (btnPrint && printModal) {
       btnPrint.addEventListener('click', async () => {
         try {
           if (!canvas || !canvas.getContext) {
             showToast('No image available for printing', 'error');
             return;
           }
           
           // Show loading state
           btnPrint.disabled = true;
           btnPrint.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Loading...';
           
           // Auto-detect client machine printers using Web API
           await loadClientPrinters();
           
           // Also load server printers as fallback
           try {
             const printersResponse = await fetch('/dicom-viewer/print/printers/');
             const printersData = await printersResponse.json();
             
             if (printersData.success && printersData.printers.length > 0) {
             // Add server printers with indication
             printersData.printers.forEach(printer => {
               const option = document.createElement('option');
               option.value = `server:${printer.name}`;
               option.textContent = `🖥️ Server: ${printer.name} - ${printer.description}`;
               printerSelect.appendChild(option);
             });
           }
         } catch (e) {
           console.warn('Server printers not available:', e);
         }
         
         // Load modality-specific layouts
         const currentModality = getCurrentModality();
         if (currentModality) {
           const layoutsResponse = await fetch(`/dicom-viewer/print/layouts/?modality=${currentModality}`);
           const layoutsData = await layoutsResponse.json();
           
           if (layoutsData.success) {
             const layoutSelect = document.getElementById('layoutType');
             layoutSelect.innerHTML = '';
             
             layoutsData.layouts.forEach(layout => {
               const option = document.createElement('option');
               option.value = layout.value;
               option.textContent = layout.name;
               option.setAttribute('data-description', layout.description);
               layoutSelect.appendChild(option);
             });
             
             // Update description
             updateLayoutDescription();
           }
         }
         
           printModal.style.display = 'flex';
           showToast('Print options loaded', 'success');
           
         } catch(error) {
           console.error('Error loading print options:', error);
           showToast(`Failed to load print options: ${error.message}`, 'error');
         } finally {
           // Reset button state
           btnPrint.disabled = false;
           btnPrint.innerHTML = '<i class="fas fa-print"></i> Print';
         }
       });
     }

     // Handle print medium changes
     const printMedium = document.getElementById('printMedium');
     const paperTypeGroup = document.getElementById('paperTypeGroup');
     const paperSize = document.getElementById('paperSize');
     const paperType = document.getElementById('paperType');
     
     printMedium.addEventListener('change', function() {
       if (this.value === 'film') {
         // Show film-specific options
         paperType.innerHTML = `
           <option value="film">Medical Film</option>
           <option value="film_blue">Blue-Base Film</option>
           <option value="film_clear">Clear-Base Film</option>
         `;
         
         // Show film sizes
         paperSize.innerHTML = `
           <option value="FILM_14X17">Film 14" × 17" (Standard)</option>
           <option value="FILM_11X14">Film 11" × 14"</option>
           <option value="FILM_10X12">Film 10" × 12"</option>
           <option value="FILM_8X10">Film 8" × 10"</option>
         `;
         
         paperTypeGroup.querySelector('label').textContent = 'Film Type:';
       } else {
         // Show paper-specific options
         paperType.innerHTML = `
           <option value="glossy">🌟 Glossy Photo Paper</option>
           <option value="matte">Matte Paper</option>
           <option value="plain">Plain Paper</option>
         `;
         
         // Show paper sizes
         paperSize.innerHTML = `
           <option value="A4">A4 (210 × 297 mm)</option>
           <option value="Letter">Letter (8.5 × 11 in)</option>
         `;
         
         paperTypeGroup.querySelector('label').textContent = 'Paper Type:';
       }
     });

     // Handle layout type changes
     const layoutType = document.getElementById('layoutType');
     layoutType.addEventListener('change', updateLayoutDescription);
     
     function updateLayoutDescription() {
       const selectedOption = layoutType.options[layoutType.selectedIndex];
       const description = selectedOption.getAttribute('data-description') || selectedOption.textContent;
       document.getElementById('layoutDescription').textContent = description;
     }
     
     function getCurrentModality() {
       // Extract modality from patient info
       const patientInfo = document.getElementById('patientInfo').textContent;
       const modalityMatch = patientInfo.match(/Modality: ([^|]+)/);
       return modalityMatch ? modalityMatch[1].trim() : '';
     }

     // Close print modal
     closePrintModal.addEventListener('click', ()=>{ printModal.style.display = 'none'; });
     cancelPrint.addEventListener('click', ()=>{ printModal.style.display = 'none'; });
     printModal.addEventListener('click', (e)=>{ if (e.target === printModal) printModal.style.display = 'none'; });

     // Client-side printing function
     function printImageOnClient(imageData, settings) {
       const printWindow = window.open('', '_blank', 'width=800,height=600');
       const printHTML = `
         <!DOCTYPE html>
         <html>
         <head>
           <title>DICOM Print</title>
           <style>
             body { margin: 0; padding: 20px; font-family: Arial, sans-serif; }
             .print-container { text-align: center; }
             .dicom-image { max-width: 100%; height: auto; }
             .print-info { margin-top: 20px; font-size: 12px; color: #666; }
           </style>
         </head>
         <body>
           <div class="print-container">
             <img src="${imageData}" class="dicom-image" alt="DICOM Image">
             <div class="print-info">
               <p>Patient: ${document.getElementById('patientInfo').textContent}</p>
               <p>Printed: ${new Date().toLocaleString()}</p>
               <p>Settings: ${settings.paperSize}, ${settings.quality}</p>
             </div>
           </div>
         </body>
         </html>
       `;
       
       printWindow.document.write(printHTML);
       printWindow.document.close();
       
       // Auto-print after a short delay
       setTimeout(() => {
         printWindow.focus();
         printWindow.print();
       }, 500);
       
       return printWindow;
     }

     // Handle print form submission
     printForm.addEventListener('submit', async (e)=>{
        e.preventDefault();
        
        try {
          // Get current canvas image data
          const imageData = canvas.toDataURL('image/png', 1.0);
          const selectedPrinter = document.getElementById('printerSelect').value;
          
          // Check if this is a client-side printer
          if (selectedPrinter.startsWith('browser') || selectedPrinter.startsWith('client')) {
            // Handle client-side printing
            const printerSettings = {
              paperSize: document.getElementById('paperSize').value,
              paperType: document.getElementById('paperType').value,
              quality: document.getElementById('printQuality').value,
              copies: document.getElementById('copies').value,
              layout: document.getElementById('layoutType').value,
              medium: document.getElementById('printMedium').value
            };
            
            console.log('Printing on client with settings:', printerSettings);
            
            // Use client-side printing
            const printWindow = printImageOnClient(imageData, printerSettings);
            
            showToast('Print dialog opened successfully', 'success');
            printModal.style.display = 'none';
            
            return;
          }
          
          // Server-side printing (existing functionality)
          // Get patient information from current study
          const patientInfo = document.getElementById('patientInfo').textContent;
          const patientMatch = patientInfo.match(/Patient: ([^|]+)/);
          const dateMatch = patientInfo.match(/Study Date: ([^|]+)/);
          const modalityMatch = patientInfo.match(/Modality: ([^|]+)/);
          
          const formData = new FormData();
          formData.append('image_data', imageData);
          formData.append('printer_name', selectedPrinter.replace('server:', ''));
          formData.append('paper_size', document.getElementById('paperSize').value);
          formData.append('paper_type', document.getElementById('paperType').value);
          formData.append('print_quality', document.getElementById('printQuality').value);
          formData.append('copies', document.getElementById('copies').value);
          formData.append('layout_type', document.getElementById('layoutType').value);
          formData.append('print_medium', document.getElementById('printMedium').value);
          formData.append('patient_name', patientMatch ? patientMatch[1].trim() : 'Unknown Patient');
          formData.append('study_date', dateMatch ? dateMatch[1].trim() : '');
          formData.append('modality', modalityMatch ? modalityMatch[1].trim() : '');
          formData.append('series_description', currentSeries ? currentSeries.description || '' : '');
          formData.append('institution_name', 'Medical Facility');
          
          // Add CSRF token
          const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]')?.value || 
                           document.querySelector('meta[name="csrf-token"]')?.getAttribute('content') ||
                           getCookie('csrftoken');
          if (csrfToken) {
            formData.append('csrfmiddlewaretoken', csrfToken);
          }
          
          // Submit print job
          const submitBtn = document.getElementById('submitPrint');
          const originalText = submitBtn.innerHTML;
          submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Printing...';
          submitBtn.disabled = true;
          
          const response = await fetch('/dicom-viewer/print/image/', {
            method: 'POST',
            body: formData
          });
          
          const result = await response.json();
          
          if (result.success) {
            console.log('Print success:', result.message);
            showToast('Print job sent successfully', 'success');
            printModal.style.display = 'none';
          } else {
            console.error('Print error:', result.error);
            showToast('Print failed', 'error');
          }
          
                 } catch(e) {
            console.error('Error printing image:', e.message);
          } finally {
          // Reset button
          const submitBtn = document.getElementById('submitPrint');
          submitBtn.innerHTML = '<i class="fas fa-print"></i> Print Image';
          submitBtn.disabled = false;
        }
      });

    // Clean toast notification system (duplicate removed)

        // Utils
    function loadImage(src) {
      return new Promise((res, rej) => {
        const im = new Image();
        im.decoding = 'async';
        im.crossOrigin = 'anonymous';
        im.onload = () => {
          if (im.width > 0 && im.height > 0) {
            res(im);
          } else {
            rej(new Error('Invalid image dimensions'));
          }
        };
        im.onerror = (e) => {
          console.error('Image load error:', e, 'src:', src);
          rej(e);
        };
        im.src = src;
      });
    }
    function mprKey(seriesId, plane, sliceIndex, wwVal, wlVal, inv){
      return `${seriesId}|${plane}|${sliceIndex}|${Math.round(wwVal)}|${Math.round(wlVal)}|${inv?1:0}`;
    }
    
    // Duplicate functions removed to prevent code leakage
    async function getMprImage(seriesId, plane, sliceIndex){
      const key = mprKey(seriesId, plane, sliceIndex, ww, wl, inverted);
      if (mprImageCache.has(key)){
        const val = mprImageCache.get(key);
        return (typeof val?.then === 'function') ? await val : val;
      }
      const url = `/dicom-viewer/api/series/${seriesId}/mpr/?plane=${encodeURIComponent(plane)}&slice=${sliceIndex}&window_width=${Math.round(ww)}&window_level=${Math.round(wl)}&inverted=${inverted}`;
      const pending = fetch(url)
        .then(r=>{ if(!r.ok) throw new Error('mpr fetch failed'); return r.json(); })
        .then(j=>{ if(!j || !j.image) throw new Error('no mpr image'); return j.image; })
        .then(img=>{ mprImageCache.set(key, img); return img; })
        .catch(err=>{ mprImageCache.delete(key); throw err; });
      mprImageCache.set(key, pending);
      return await pending;
    }
    function prefetchMprSlices(plane, centerSlice, radius=3){
      if (!currentSeries || !mprScroll || !mprScroll.counts) return;
      const total = Math.max(0, (mprScroll.counts[plane]||0));
      if (!total) return;
      for (let o = -radius; o <= radius; o++){
        if (o === 0) continue;
        const s = centerSlice + o;
        if (s < 0 || s >= total) continue;
        const key = mprKey(currentSeries.id, plane, s, ww, wl, inverted);
        if (mprImageCache.has(key)) continue;
        // Fire-and-forget; cache will store promise/result
        getMprImage(currentSeries.id, plane, s).catch(err=>{ console.error('Failed to prefetch MPR image:', plane, s, err); });
      }
    }
    
    // 3D viewer for bone mesh
    let three = { renderer: null, scene: null, camera: null, controls: null };
    
    function disposeSceneObjects() {
      if (!three.scene) return;
      const toRemove = [];
      three.scene.traverse(obj => {
        if (obj.isMesh) {
          if (obj.geometry) obj.geometry.dispose();
          if (obj.material) {
            if (Array.isArray(obj.material)) obj.material.forEach(m => m.dispose());
            else obj.material.dispose();
          }
          toRemove.push(obj);
        }
      });
      toRemove.forEach(obj => three.scene.remove(obj));
    }
    
    let threeAnimId = null;
    
    function showBone3D(meshData) {
      try {
        const container = document.getElementById('threeContainer');
        const mount = document.getElementById('threeMount');
        container.style.display = 'block';
        
        // Initialize Three.js only once
        if (!three.renderer) {
          three.renderer = new THREE.WebGLRenderer({
            antialias: true,
            preserveDrawingBuffer: false,
            powerPreference: 'high-performance'
          });
          three.renderer.setSize(mount.clientWidth, mount.clientHeight);
          mount.appendChild(three.renderer.domElement);
          
          three.scene = new THREE.Scene();
          three.scene.background = new THREE.Color(0x000000);
          
          three.camera = new THREE.PerspectiveCamera(45, mount.clientWidth / mount.clientHeight, 0.1, 10000);
          three.camera.position.set(0, 0, 400);
          
          three.controls = new THREE.OrbitControls(three.camera, three.renderer.domElement);
          three.controls.enableDamping = true;
          three.controls.dampingFactor = 0.05;
          
          const light1 = new THREE.DirectionalLight(0xffffff, 1.0);
          light1.position.set(1, 1, 1);
          three.scene.add(light1);
          
          const light2 = new THREE.AmbientLight(0x444444);
          three.scene.add(light2);
          
          const onResize3D = () => {
            if (!three.renderer) return;
            three.renderer.setSize(mount.clientWidth, mount.clientHeight);
            three.camera.aspect = mount.clientWidth / mount.clientHeight;
            three.camera.updateProjectionMatrix();
          };
          window.addEventListener('resize', onResize3D, { passive: true });
          three._onResize3D = onResize3D;
        } else {
          disposeSceneObjects();
        }
        
        // Build geometry with enhanced quality
        const vertices = new Float32Array(meshData.vertices.flat());
        const indices = new Uint32Array(meshData.faces.flat());
        const geom = new THREE.BufferGeometry();
        geom.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
        geom.setIndex(new THREE.BufferAttribute(indices, 1));
        geom.computeVertexNormals();
        
        // Enhanced material for better bone visualization
        const material = new THREE.MeshPhongMaterial({
          color: 0xf5f5dc, // Bone color
          specular: 0x222222,
          shininess: 50,
          transparent: false,
          side: THREE.DoubleSide
        });
        
        const mesh = new THREE.Mesh(geom, material);
        
        // Center & scale
        geom.computeBoundingSphere();
        const bs = geom.boundingSphere;
        if (bs) {
          mesh.position.sub(bs.center);
          const target = 150;
          const s = bs.radius > 0 ? target / bs.radius : 1;
          mesh.scale.setScalar(s);
        }
        
        three.scene.add(mesh);
        
        // Animate
        if (threeAnimId) cancelAnimationFrame(threeAnimId);
        const animate = () => {
          if (!three.renderer || container.style.display === 'none') return;
          three.controls.update();
          three.renderer.render(three.scene, three.camera);
          threeAnimId = requestAnimationFrame(animate);
        };
        animate();
        
        // Close button functionality
        const closeBtn = document.getElementById('close3d');
        if (closeBtn) {
          closeBtn.onclick = () => {
            if (threeAnimId) {
              cancelAnimationFrame(threeAnimId);
              threeAnimId = null;
            }
            disposeSceneObjects();
            if (three._onResize3D) {
              window.removeEventListener('resize', three._onResize3D);
            }
            container.style.display = 'none';
          };
        }
      } catch (e) {
        console.warn('3D setup failed', e);
        showToast('3D visualization failed to load', 'error');
      }
    }
 
     // Debug function for 3D troubleshooting
    window.debug3D = function() {
      console.log('=== 3D Debug Info ===');
      console.log('MPR Mode:', mprMode);
      console.log('MPR Images:', mprImgs);
      console.log('MPR Cross:', mprCross);
      console.log('MPR Scroll:', mprScroll);
      console.log('MPR Region VPs:', mprRegionVps);
      console.log('Current Series:', currentSeries);
      console.log('Reconstruction Mode:', reconMode);
      console.log('Reconstruction Images:', reconImgs);
      console.log('===================');
    };

    // Series selection handler
    if (seriesSelect) {
      seriesSelect.addEventListener('change', async () => {
        const selectedSeriesId = seriesSelect.value;
        if (selectedSeriesId) {
          await loadSeries(selectedSeriesId);
        }
      });
    }
    
    // Window/level controls
    if (wwSlider && wlSlider && wwNum && wlNum) {
      wwSlider.addEventListener('input', () => {
        ww = parseInt(wwSlider.value);
        wwNum.value = ww;
        document.getElementById('wwVal').textContent = ww;
        imageCache.clear();
        mprImageCache.clear();
        requestDraw();
      });
      
      wlSlider.addEventListener('input', () => {
        wl = parseInt(wlSlider.value);
        wlNum.value = wl;
        document.getElementById('wlVal').textContent = wl;
        imageCache.clear();
        mprImageCache.clear();
        requestDraw();
      });
      
      wwNum.addEventListener('input', () => {
        ww = parseInt(wwNum.value);
        wwSlider.value = ww;
        document.getElementById('wwVal').textContent = ww;
        imageCache.clear();
        mprImageCache.clear();
        requestDraw();
      });
      
      wlNum.addEventListener('input', () => {
        wl = parseInt(wlNum.value);
        wlSlider.value = wl;
        document.getElementById('wlVal').textContent = wl;
        imageCache.clear();
        mprImageCache.clear();
        requestDraw();
      });
    }
    
    // Slice navigation
    if (sliceSlider) {
      sliceSlider.addEventListener('input', () => {
        index = parseInt(sliceSlider.value);
        document.getElementById('sliceVal').textContent = index + 1;
        requestDraw();
        prefetchAround(index, 3);
      });
    }
    
    // Zoom control
    if (zoomSlider) {
      zoomSlider.addEventListener('input', () => {
        zoom = parseInt(zoomSlider.value) / 100;
        document.getElementById('zoomVal').textContent = zoomSlider.value + '%';
        requestDraw();
      });
    }
    
        // Canvas mouse event handlers
    canvas.addEventListener('mousedown', (e) => {
      if (activeTool === 'pan') {
        isDragging = true;
        dragStart = { x: e.clientX - panOffset.x, y: e.clientY - panOffset.y };
      } else if (activeTool === 'measure') {
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) / rect.width * canvas.width;
        const y = (e.clientY - rect.top) / rect.height * canvas.height;
        measureDraft = { start: { x, y }, end: { x, y } };
        requestDraw();
      }
    });
    
    canvas.addEventListener('mousemove', (e) => {
      if (isDragging && activeTool === 'pan') {
        panOffset.x = e.clientX - dragStart.x;
        panOffset.y = e.clientY - dragStart.y;
        requestDraw();
      } else if (measureDraft && activeTool === 'measure') {
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) / rect.width * canvas.width;
        const y = (e.clientY - rect.top) / rect.height * canvas.height;
        measureDraft.end = { x, y };
        requestDraw();
      }
    });
    
    canvas.addEventListener('mouseup', (e) => {
      if (isDragging && activeTool === 'pan') {
        isDragging = false;
        dragStart = null;
      } else if (measureDraft && activeTool === 'measure') {
        // Add measurement
        const measurement = {
          start: measureDraft.start,
          end: measureDraft.end,
          label: 'Measurement'
        };
        measurements.push(measurement);
        imageIdToMeasurements.set(getCurrentImageId(), measurements);
        renderMeasurementsList();
        measureDraft = null;
        requestDraw();
      }
    });
    
    // Tool selection
    document.querySelectorAll('.tool[data-tool]').forEach(tool => {
      tool.addEventListener('click', () => {
        document.querySelectorAll('.tool').forEach(t => t.classList.remove('active'));
        tool.classList.add('active');
        activeTool = tool.dataset.tool;
        
        // Handle special tools
        if (activeTool === 'reset') {
          ww = defaultWw;
          wl = defaultWl;
          zoom = 1.0;
          panOffset = { x: 0, y: 0 };
          wwSlider.value = ww;
          wlSlider.value = wl;
          wwNum.value = ww;
          wlNum.value = wl;
          zoomSlider.value = 100;
          document.getElementById('wwVal').textContent = ww;
          document.getElementById('wlVal').textContent = wl;
          document.getElementById('zoomVal').textContent = '100%';
          imageCache.clear();
          mprImageCache.clear();
          requestDraw();
        } else if (activeTool === 'fit') {
          zoom = 1.0;
          panOffset = { x: 0, y: 0 };
          zoomSlider.value = 100;
          document.getElementById('zoomVal').textContent = '100%';
          requestDraw();
        } else if (activeTool === 'one') {
          zoom = 1.0;
          zoomSlider.value = 100;
          document.getElementById('zoomVal').textContent = '100%';
          requestDraw();
        } else if (activeTool === 'invert') {
          inverted = !inverted;
          imageCache.clear();
          mprImageCache.clear();
          requestDraw();
        }
      });
    });
    
    // Comprehensive initialization - Fixed with validation and error handling
    function initializeViewer() {
      try {
        console.log('Initializing DICOM viewer...');
        
        // Validate essential elements
        const essentialElements = {
          canvas: document.getElementById('dicomCanvas'),
          viewport: document.getElementById('viewport'),
          seriesSelect: document.getElementById('seriesSelect'),
          wwSlider: document.getElementById('ww'),
          wlSlider: document.getElementById('wl')
        };
        
        const missingElements = Object.entries(essentialElements)
          .filter(([name, element]) => !element)
          .map(([name]) => name);
        
        if (missingElements.length > 0) {
          console.error('Missing essential elements:', missingElements);
          showToast(`Viewer initialization failed: missing ${missingElements.join(', ')}`, 'error');
          return;
        }
        
        // Set initial canvas size
        setCanvasSize();
        
        // Validate canvas context
        if (!canvas.getContext) {
          console.error('Canvas context not available');
          showToast('Canvas not supported in this browser', 'error');
          return;
        }
        
        // Initialize canvas
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#000000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Load study if specified
        const studyId = q('study_id') || q('study') || {% if study_id %}'{{ study_id }}'{% else %}null{% endif %};
        if (studyId) {
          console.log(`Loading study ID: ${studyId}`);
          loadStudy(studyId);
        } else {
          // Show available studies for selection if no study ID specified
          loadAvailableStudies();
          showToast('DICOM viewer ready - select a study or load local DICOM files', 'info', 5000);
        }
        
        // Validate all button elements
        const buttons = [
          'btnLoadLocal', 'btnBackWorklist', 'btnWriteReport', 'btnToggleTags', 
          'btnShowDicom', 'btnCapture', 'btnPrint', 'btnClearMeasurements',
          'btnSavePreset', 'btnLoadPreset', 'btnGenerateRecon'
        ];
        
        const missingButtons = buttons.filter(id => !document.getElementById(id));
        if (missingButtons.length > 0) {
          console.warn('Some buttons not found:', missingButtons);
        }
        
        console.log('DICOM viewer initialized successfully');
        
        // Initialize all button event handlers
        initializeButtonHandlers();
        
      } catch (error) {
        console.error('Viewer initialization error:', error);
        showToast(`Initialization failed: ${error.message}`, 'error');
        // Reset all button states on error
        resetAllButtonStates();
      }
    }
    
    // Function to reset all button states - fixes stuck loading spinners
    function resetAllButtonStates() {
      try {
        // Reset Load Local button
        if (btnLoadLocal) {
          btnLoadLocal.disabled = false;
          btnLoadLocal.style.pointerEvents = '';
          btnLoadLocal.innerHTML = '<i class="fas fa-folder-open"></i> Load Local DICOM';
        }
        
        // Reset Print button
        const btnPrint = document.getElementById('btnPrint');
        if (btnPrint) {
          btnPrint.disabled = false;
          btnPrint.innerHTML = '<i class="fas fa-print"></i> Print';
        }
        
        // Reset Generate Reconstruction button
        if (btnGenerateRecon) {
          btnGenerateRecon.disabled = false;
          btnGenerateRecon.innerHTML = '<i class="fas fa-cogs"></i> Generate';
        }
        
        // Reset Save/Load Preset buttons
        if (btnSavePreset) {
          btnSavePreset.disabled = false;
          btnSavePreset.innerHTML = '<i class="fas fa-bookmark"></i> Save';
        }
        
        if (btnLoadPreset) {
          btnLoadPreset.disabled = false;
          btnLoadPreset.innerHTML = '<i class="fas fa-list"></i> Load';
        }
        
        // Reset upload state
        uploadInProgress = false;
        
        console.log('All button states reset');
      } catch (error) {
        console.error('Error resetting button states:', error);
      }
    }
    
    // Function to initialize all button handlers - fixes button interaction issues
    function initializeButtonHandlers() {
      try {
        // Ensure all critical buttons have proper event handlers
        
        // Load Local DICOM button
        if (btnLoadLocal && !btnLoadLocal.hasAttribute('data-initialized')) {
          btnLoadLocal.setAttribute('data-initialized', 'true');
          btnLoadLocal.addEventListener('click', () => {
            if (uploadInProgress) {
              showToast('Upload already in progress', 'warning');
              return;
            }
            try {
              inputLocal.click();
            } catch (error) {
              console.error('File input error:', error);
              showToast('Failed to open file dialog', 'error');
            }
          });
        }
        
        // Clear Measurements button
        if (btnClearMeasurements && !btnClearMeasurements.hasAttribute('data-initialized')) {
          btnClearMeasurements.setAttribute('data-initialized', 'true');
          btnClearMeasurements.addEventListener('click', () => {
            try {
              const hasMeasurements = mprMode ? 
                (mprMeasurements.axial.length > 0 || mprMeasurements.sagittal.length > 0 || mprMeasurements.coronal.length > 0) :
                (measurements.length > 0);
              
              if (!hasMeasurements) {
                showToast('No measurements to clear', 'info');
                return;
              }
              
              if (!confirm('Are you sure you want to clear all measurements?')) {
                return;
              }
              
              if (mprMode) {
                mprMeasurements.axial = [];
                mprMeasurements.sagittal = [];
                mprMeasurements.coronal = [];
                showToast('MPR measurements cleared', 'success');
              } else {
                measurements = [];
                const imageId = getCurrentImageId();
                if (imageId) {
                  imageIdToMeasurements.set(imageId, measurements);
                }
                renderMeasurementsList();
                showToast('Measurements cleared', 'success');
              }
              
              requestDraw();
              
            } catch (error) {
              console.error('Clear measurements error:', error);
              showToast(`Failed to clear measurements: ${error.message}`, 'error');
            }
          });
        }
        
        console.log('Button handlers initialized successfully');
      } catch (error) {
        console.error('Error initializing button handlers:', error);
      }
    }
    
    // Global error handler to prevent UI from getting stuck
    window.addEventListener('error', (event) => {
      console.error('Global error caught:', event.error);
      resetAllButtonStates();
      hideProgressIndicator();
      showToast('An error occurred. Interface reset.', 'warning');
    });
    
    window.addEventListener('unhandledrejection', (event) => {
      console.error('Unhandled promise rejection:', event.reason);
      resetAllButtonStates();
      hideProgressIndicator();
    });
    
    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeViewer);
    } else {
      initializeViewer();
    }

     // Unit selector wiring
     const unitSelect = document.getElementById('unitSelect');
     const unitVal = document.getElementById('unitVal');
     if (unitSelect){
             unitSelect.addEventListener('change', ()=>{
        measureUnit = unitSelect.value === 'cm' ? 'cm' : 'mm';
        unitVal.textContent = measureUnit;
        // Recompute labels for current measurements (series view)
        measurements = (measurements||[]).map(m=>{
          if (m && m.start && m.end){
            const dist = imageDistance(m.start, m.end);
            if (dist.mm){
              const mm = dist.mm; const cm = mm/10.0;
              m.label = (measureUnit==='cm') ? `${cm.toFixed(2)} cm` : `${mm.toFixed(2)} mm`;
            }
          }
          return m;
        });
        // Recompute MPR measurement labels
        ['axial','sagittal','coronal'].forEach(plane=>{
          mprMeasurements[plane] = (mprMeasurements[plane]||[]).map(m=>{
            if (m && m.start && m.end){
              const dist = mprImageDistance(plane, m.start, m.end);
              if (dist.mm){
                const mm = dist.mm; const cm = mm/10.0;
                m.label = (measureUnit==='cm') ? `${cm.toFixed(2)} cm` : `${mm.toFixed(2)} mm`;
              }
            }
            return m;
          });
        });
        renderMeasurementsList();
        requestDraw();
      });
     }

     document.getElementById('mprMeasurePlane').addEventListener('change', (e)=>{ mprMeasurePlaneMode = e.target.value; });
     document.getElementById('mprMeasureType').addEventListener('change', (e)=>{ mprMeasureType = e.target.value; });

     // Preset handlers - Fixed with comprehensive error handling and user feedback
     if (btnSavePreset) {
       btnSavePreset.addEventListener('click', async () => {
         try {
           if (!currentStudy) {
             showToast('No study loaded to save preset for', 'warning');
             return;
           }
           
           const name = prompt('Enter preset name:', `${currentStudy.modality || 'Custom'}_Preset_${Date.now()}`);
           if (!name) {
             showToast('Preset save cancelled', 'info');
             return;
           }
           
           const payload = {
             name: name.trim(),
             modality: (currentStudy && currentStudy.modality) || '',
             window_width: ww,
             window_level: wl,
             inverted: inverted
           };
           
           btnSavePreset.disabled = true;
           btnSavePreset.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Saving...';
           
           const response = await fetch('/dicom-viewer/api/presets/', {
             method: 'POST',
             headers: {
               'Content-Type': 'application/json',
               'X-CSRFToken': getCookie('csrftoken')
             },
             body: JSON.stringify(payload)
           });
           
           if (!response.ok) {
             throw new Error(`HTTP ${response.status}: ${response.statusText}`);
           }
           
           const result = await response.json();
           if (result.success) {
             showToast(`Preset "${name}" saved successfully`, 'success', 2000);
           } else {
             throw new Error(result.error || 'Failed to save preset');
           }
           
         } catch (error) {
           console.error('Save preset error:', error);
           showToast(`Failed to save preset: ${error.message}`, 'error');
         } finally {
           btnSavePreset.disabled = false;
           btnSavePreset.innerHTML = '<i class="fas fa-bookmark"></i> Save';
         }
       });
     }
     
     if (btnLoadPreset) {
       btnLoadPreset.addEventListener('click', async () => {
         try {
           btnLoadPreset.disabled = true;
           btnLoadPreset.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Loading...';
           
           const modality = (currentStudy && currentStudy.modality) || '';
           const response = await fetch(`/dicom-viewer/api/presets/?modality=${encodeURIComponent(modality)}`);
           
           if (!response.ok) {
             throw new Error(`HTTP ${response.status}: ${response.statusText}`);
           }
           
           const data = await response.json();
           const presets = data.presets || [];
           
           if (!presets.length) {
             showToast('No presets found for this modality', 'info');
             return;
           }
           
           // Load the most recent preset automatically
           const preset = presets[presets.length - 1];
           
           // Apply preset values
           ww = preset.window_width;
           wl = preset.window_level;
           inverted = !!preset.inverted;
           
           // Update UI controls
           wwSlider.value = ww;
           wlSlider.value = wl;
           wwNum.value = Math.round(ww);
           wlNum.value = Math.round(wl);
           document.getElementById('wwVal').textContent = Math.round(ww);
           document.getElementById('wlVal').textContent = Math.round(wl);
           
           // Clear caches and redraw
           imageCache.clear();
           mprImageCache.clear();
           mprImgs = { axial: null, sagittal: null, coronal: null };
           requestDraw();
           
           showToast(`Preset "${preset.name}" loaded successfully`, 'success', 2000);
           
         } catch (error) {
           console.error('Load preset error:', error);
           showToast(`Failed to load preset: ${error.message}`, 'error');
         } finally {
           btnLoadPreset.disabled = false;
           btnLoadPreset.innerHTML = '<i class="fas fa-list"></i> Load';
         }
       });
     }

    // Admin delete study functionality
    if (document.getElementById('btnDeleteStudy')) {
      document.getElementById('btnDeleteStudy').addEventListener('click', async function() {
        if (!currentStudy) {
          showToast('No study loaded', 'warning');
          return;
        }
        
        const confirmDelete = confirm('Delete this study? This cannot be undone.');
        
        if (!confirmDelete) return;
        
        try {
          showProgressIndicator();
          
          const response = await fetch(`/worklist/api/studies/${currentStudy}/delete/`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'X-CSRFToken': getCookie('csrftoken')
            }
          });
          
          hideProgressIndicator();
          
          if (response.ok) {
            showToast('Study deleted successfully', 'success');
            // Redirect to worklist after 2 seconds
            setTimeout(() => {
              window.location.href = '/worklist/dashboard/';
            }, 2000);
          } else {
            const error = await response.json();
            showToast(`Failed to delete study: ${error.error || 'Unknown error'}`, 'error');
          }
        } catch (error) {
          hideProgressIndicator();
          console.error('Delete error:', error);
          showToast(`Delete failed: ${error.message}`, 'error');
        }
      });
    }
  })();
  </script>
</body>
</html>