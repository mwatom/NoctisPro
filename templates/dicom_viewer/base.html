<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DICOM Viewer</title>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
  <style>
    body { margin: 0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; background: #1a1a1a; color: #fff; }
    .layout { display: grid; grid-template-columns: 80px 1fr 300px; grid-template-rows: 60px 1fr; height: 100vh; }
    .toolbar { grid-row: 1 / span 2; grid-column: 1; background: #2a2a2a; border-right: 1px solid #444; padding: 8px 6px; display: flex; flex-direction: column; gap: 6px; }
    .tool { width: 66px; height: 56px; background: #3a3a3a; border: none; border-radius: 8px; color: #fff; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 11px; }
    .tool.active { background: #0078d4; }
    .tool i { font-size: 18px; margin-bottom: 4px; }
    .topbar { grid-row: 1; grid-column: 2 / span 2; display: flex; align-items: center; gap: 12px; padding: 0 16px; background: #2a2a2a; border-bottom: 1px solid #444; }
    .btn { padding: 8px 12px; border: none; border-radius: 6px; cursor: pointer; font-size: 13px; }
    .btn-primary { background: #0078d4; color: #fff; }
    .select { padding: 8px 10px; background: #3a3a3a; border: 1px solid #555; border-radius: 6px; color: #fff; min-width: 220px; }
    .viewport { grid-row: 2; grid-column: 2; background: #000; position: relative; display: flex; align-items: center; justify-content: center; }
    .right { grid-row: 2; grid-column: 3; background: #2a2a2a; border-left: 1px solid #444; padding: 16px; overflow: auto; }
    .panel { margin-bottom: 18px; }
    .panel h3 { font-size: 15px; margin: 0 0 10px; padding-bottom: 8px; border-bottom: 1px solid #444; }
    .control { margin-bottom: 12px; }
    .control .label { display: flex; justify-content: space-between; font-size: 12px; color: #ccc; margin-bottom: 6px; }
    input[type=range] { width: 100%; }
    .overlay { position: absolute; top: 12px; left: 12px; background: rgba(0,0,0,0.6); padding: 8px 10px; border-radius: 6px; font-family: monospace; font-size: 12px; }
    .zoominfo { position: absolute; bottom: 12px; left: 12px; background: rgba(0,0,0,0.6); padding: 6px 10px; border-radius: 6px; font-family: monospace; font-size: 12px; }
    canvas { max-width: 100%; max-height: 100%; }
    .thumbs { display:grid; grid-template-columns: 1fr 1fr; gap:8px; }
    .thumbs img { width:100%; background:#000; border-radius:6px; border:1px solid #444; }
    .row-3 { display:grid; grid-template-columns: 1fr 1fr 1fr; gap:8px; }
    .muted { color:#bbb; font-size:12px; }
  </style>
</head>
<body>
  <div class="layout">
    <div class="toolbar">
      <button class="tool active" data-tool="window"><i class="fas fa-adjust"></i><span>Window</span></button>
      <button class="tool" data-tool="zoom"><i class="fas fa-search-plus"></i><span>Zoom</span></button>
      <button class="tool" data-tool="pan"><i class="fas fa-arrows-alt"></i><span>Pan</span></button>
      <button class="tool" data-tool="measure"><i class="fas fa-ruler"></i><span>Measure</span></button>
      <button class="tool" data-tool="annotate"><i class="fas fa-comment-dots"></i><span>Annotate</span></button>
      <button class="tool" data-tool="crosshair"><i class="fas fa-crosshairs"></i><span>Crosshair</span></button>
      <button class="tool" data-tool="invert"><i class="fas fa-adjust"></i><span>Invert</span></button>
      <button class="tool" data-tool="reset"><i class="fas fa-undo"></i><span>Reset</span></button>
      <button class="tool" data-tool="ai"><i class="fas fa-robot"></i><span>AI</span></button>
    </div>
    <div class="topbar">
      <button id="btnLoadLocal" class="btn btn-primary"><i class="fas fa-folder-open"></i> Load Local DICOM</button>
      <button id="btnBackWorklist" class="btn" onclick="window.location.href='{% url 'worklist:dashboard' %}'"><i class="fas fa-arrow-left"></i> Back to Worklist</button>
      {% if user.is_authenticated and (user.role == 'admin' or user.role == 'radiologist') %}
      <button id="btnWriteReport" class="btn btn-primary" style="display:none"><i class="fas fa-file-signature"></i> Write Report</button>
      {% endif %}
      <input id="localDicom" type="file" multiple webkitdirectory directory accept=".dcm,.dicom,application/dicom" style="display:none" />
      <select id="seriesSelect" class="select"><option value="">Select Series</option></select>
      <div id="patientInfo" style="margin-left:auto;color:#ccc;font-size:13px;">Patient: - | Study Date: - | Modality: -</div>
    </div>
    <div class="viewport" id="viewport">
      <canvas id="dicomCanvas"></canvas>
      <div class="overlay" id="overlay">WW: 400<br>WL: 40<br>Slice: 1/1</div>
      <div class="zoominfo" id="zoominfo">Zoom: 100%</div>
    </div>
    <div class="right">
      <div class="panel">
        <h3>Window/Level</h3>
        <div class="control"><div class="label"><span>Window Width</span><span id="wwVal">400</span></div><input id="ww" type="range" min="1" max="4000" value="400"></div>
        <div class="control"><div class="label"><span>Window Level</span><span id="wlVal">40</span></div><input id="wl" type="range" min="-1000" max="1000" value="40"></div>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;">
          <button class="btn" data-preset="lung">Lung</button>
          <button class="btn" data-preset="bone">Bone</button>
          <button class="btn" data-preset="soft">Soft</button>
          <button class="btn" data-preset="brain">Brain</button>
        </div>
      </div>
      <div class="panel">
        <h3>Navigation</h3>
        <div class="control"><div class="label"><span>Slice</span><span id="sliceVal">1</span></div><input id="slice" type="range" min="0" max="0" value="0"></div>
      </div>
      <div class="panel">
        <h3>Transform</h3>
        <div class="control"><div class="label"><span>Zoom</span><span id="zoomVal">100%</span></div><input id="zoom" type="range" min="25" max="500" value="100"></div>
      </div>
      <div class="panel">
        <h3>3D Reconstruction</h3>
        <div class="control">
          <div class="label"><span>Type</span></div>
          <select id="reconType" class="select">
            <option value="mpr">MPR (Axial/Sagittal/Coronal)</option>
            <option value="mip">MIP (Max Intensity)</option>
            <option value="bone">Bone 3D (threshold)</option>
          </select>
        </div>
        <div class="control" id="boneCtrl" style="display:none;">
          <div class="label"><span>Bone Threshold (HU)</span><span id="boneVal">300</span></div>
          <input id="boneThreshold" type="range" min="100" max="1500" value="300">
        </div>
        <div class="control">
          <button id="btnGenerateRecon" class="btn btn-primary"><i class="fas fa-cogs"></i> Generate</button>
        </div>
        <div class="muted" id="reconStatus"></div>
        <div class="row-3" id="reconViews" style="margin-top:8px; display:none;">
          <img id="viewAxial" alt="Axial"/>
          <img id="viewSagittal" alt="Sagittal"/>
          <img id="viewCoronal" alt="Coronal"/>
        </div>
      </div>
      <div class="panel">
        <h3>Image Info</h3>
        <div id="dimInfo" style="color:#ccc;font-size:12px;">Dimensions: -</div>
        <div id="spacingInfo" style="color:#ccc;font-size:12px;">Pixel Spacing: -</div>
        <div id="seriesInfo" style="color:#ccc;font-size:12px;">Series: -</div>
        <div id="institutionInfo" style="color:#ccc;font-size:12px;">Institution: -</div>
        <div id="clinicalInfo" style="color:#ccc;font-size:12px; margin-top:8px; white-space:pre-wrap;">Clinical Info: -</div>
        <div id="priorityInfo" style="color:#ccc;font-size:12px;">Priority: -</div>
      </div>
      <div class="panel">
        <h3>Measurements</h3>
        <div class="control">
          <button id="btnClearMeasurements" class="btn">Clear All</button>
        </div>
        <ul id="measurementsList" style="list-style:none;padding-left:0;margin:0;color:#ddd;font-size:12px;"></ul>
      </div>
    </div>
  </div>

  <script>
  (function(){
    const canvas = document.getElementById('dicomCanvas');
    const ctx = canvas.getContext('2d');
    const seriesSelect = document.getElementById('seriesSelect');
    const wwSlider = document.getElementById('ww');
    const wlSlider = document.getElementById('wl');
    const sliceSlider = document.getElementById('slice');
    const zoomSlider = document.getElementById('zoom');
    const btnLoadLocal = document.getElementById('btnLoadLocal');
    const inputLocal = document.getElementById('localDicom');
    const btnClearMeasurements = document.getElementById('btnClearMeasurements');
    const measurementsList = document.getElementById('measurementsList');

    const reconType = document.getElementById('reconType');
    const boneCtrl = document.getElementById('boneCtrl');
    const boneSlider = document.getElementById('boneThreshold');
    const boneVal = document.getElementById('boneVal');
    const btnGenerateRecon = document.getElementById('btnGenerateRecon');
    const reconStatus = document.getElementById('reconStatus');
    const reconViews = document.getElementById('reconViews');
    const viewAxial = document.getElementById('viewAxial');
    const viewSagittal = document.getElementById('viewSagittal');
    const viewCoronal = document.getElementById('viewCoronal');

    let currentStudy = null;
    let currentSeries = null;
    let images = [];
    let index = 0;
    let ww = 400, wl = 40, inverted = false, zoom = 1.0;
    let activeTool = 'window';
    let isDragging = false;
    let dragStart = null;
    let panOffset = { x: 0, y: 0 };
    let measureDraft = null; // {start:{x,y}, end:{x,y}}
    let measurements = []; // persisted per image id
    let annotations = [];
    let crosshair = false;

    // Map imageId -> arrays to persist while session active
    const imageIdToMeasurements = new Map();
    const imageIdToAnnotations = new Map();

    // Helper: parse pixel spacing robustly (string "0.5\\0.5", "0.5,0.5" or array)
    function parsePixelSpacing(ps){
      if (!ps) return null;
      if (Array.isArray(ps)) return ps.map(Number);
      if (typeof ps === 'string'){
        const parts = ps.split(/[\\,\s]+/).filter(Boolean);
        if (parts.length >= 2) return [parseFloat(parts[0]), parseFloat(parts[1])];
      }
      return null;
    }

    async function fallbackToDesktop(){
      try {
        const params = new URLSearchParams(window.location.search);
        const studyId = params.get('study_id') || (currentStudy && currentStudy.id);
        if (studyId){
          const resp = await fetch(`/viewer/launch-desktop/${studyId}/`);
          const j = await resp.json();
          if (j && j.fallback_url){ window.location.href = j.fallback_url; return; }
          // Desktop launched; leave page as-is
        } else {
          const resp = await fetch('/viewer/launch-desktop/', { method:'POST', headers:{'Content-Type':'application/json'}, body: '{}' });
          const j = await resp.json();
          if (j && j.fallback_url){ window.location.href = j.fallback_url; return; }
        }
      } catch (e) {
        // swallow
      }
    }

    function setCanvasSize(){
      const vp = document.getElementById('viewport');
      const rect = vp.getBoundingClientRect();
      canvas.width = Math.max(100, rect.width - 20);
      canvas.height = Math.max(100, rect.height - 20);
    }
    window.addEventListener('resize', ()=>{ setCanvasSize(); draw(); });

    function q(name){ return new URLSearchParams(window.location.search).get(name); }

    async function loadStudy(studyId){
      try {
        const r = await fetch(`/viewer/study/${studyId}/`);
        if (!r.ok) throw new Error('study fetch failed');
        const data = await r.json();
        currentStudy = data.study;
        // Enable write report button when study is known
        const wr = document.getElementById('btnWriteReport');
        if (wr && currentStudy && currentStudy.id){
          wr.style.display = '';
          wr.onclick = function(){ window.location.href = `/reports/write/${currentStudy.id}/`; };
        }
        document.getElementById('patientInfo').textContent = `Patient: ${currentStudy.patient_name} | Study Date: ${currentStudy.study_date} | Modality: ${currentStudy.modality}`;
        // Show clinical info and priority
        const clin = (currentStudy.clinical_info && currentStudy.clinical_info.trim()) ? currentStudy.clinical_info : '-';
        document.getElementById('clinicalInfo').textContent = `Clinical Info: ${clin}`;
        document.getElementById('priorityInfo').textContent = `Priority: ${currentStudy.priority ? currentStudy.priority.toUpperCase() : '-'}`;
        seriesSelect.innerHTML = '<option value="">Select Series</option>';
        (data.series_list || []).forEach(s=>{
          const opt = document.createElement('option');
          opt.value = s.id; opt.textContent = `Series ${s.series_number} - ${s.modality} (${s.image_count} images)`;
          seriesSelect.appendChild(opt);
        });
        if ((data.series_list||[]).length){
          seriesSelect.value = data.series_list[0].id;
          await loadSeries(data.series_list[0].id);
        }
      } catch (e) {
        await fallbackToDesktop();
      }
    }

    async function loadSeries(seriesId){
      try {
        const r = await fetch(`/viewer/series/${seriesId}/images/`);
        if (!r.ok) throw new Error('series fetch failed');
        const data = await r.json();
        currentSeries = data.series; images = data.images || []; index = 0;
        sliceSlider.max = Math.max(0, images.length - 1); sliceSlider.value = 0; document.getElementById('sliceVal').textContent = '1';
                 if (images.length){
           // Attempt to fetch first image with defaults to derive ww/wl from backend
           const probe = await fetch(`/viewer/image/${images[0].id}/`);
           if (probe.ok){
             const j = await probe.json();
             if (j && j.image_info){
               ww = j.image_info.default_window_width || ww;
               wl = j.image_info.default_window_level || wl;
               // Apply inversion suggestion only on first load
               if (j.windowing && typeof j.windowing.inverted === 'boolean') { inverted = j.windowing.inverted; }
             }
           }
           wwSlider.value = Math.round(ww); wlSlider.value = Math.round(wl); document.getElementById('wwVal').textContent = Math.round(ww); document.getElementById('wlVal').textContent = Math.round(wl);
         }
        // Reset view state
        zoom = 1.0; panOffset = {x:0,y:0}; activeTool = 'window'; inverted = false; crosshair = false;
        document.querySelectorAll('.tool').forEach(x=>x.classList.remove('active'));
        document.querySelector('.tool[data-tool="window"]').classList.add('active');
        setCanvasSize();
        await draw();
        await loadOverlaysForCurrentImage();
      } catch (e) {
        await fallbackToDesktop();
      }
    }

    function getCurrentImageId(){
      if (!images.length) return null;
      return images[index].id;
    }

    function getViewportPlacement(imgW, imgH){
      const scale = Math.min(canvas.width / imgW, canvas.height / imgH) * zoom;
      const w = imgW * scale, h = imgH * scale;
      const x = (canvas.width - w)/2 + panOffset.x;
      const y = (canvas.height - h)/2 + panOffset.y;
      return { scale, w, h, x, y };
    }

    async function draw(){
      if (!images.length) { ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height); return; }
      try {
        const img = images[index];
        const url = `/viewer/image/${img.id}/?ww=${ww}&wl=${wl}&invert=${inverted}`;
        const htmlImg = new Image(); htmlImg.crossOrigin = 'anonymous';
        await new Promise((resolve,reject)=>{ htmlImg.onload=resolve; htmlImg.onerror=reject; htmlImg.src=url; });
        const vp = getViewportPlacement(htmlImg.width, htmlImg.height);
        ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(htmlImg, vp.x, vp.y, vp.w, vp.h);
        drawOverlays(vp);
        document.getElementById('overlay').innerHTML = `WW: ${Math.round(ww)}<br>WL: ${Math.round(wl)}<br>Slice: ${index+1}/${images.length}`;
        document.getElementById('zoominfo').textContent = `Zoom: ${Math.round(zoom*100)}%`;
      } catch (e) {
        await fallbackToDesktop();
      }
    }

    function drawOverlays(vp){
      // Measurements (draft first)
      ctx.save();
      ctx.strokeStyle = 'yellow';
      ctx.fillStyle = 'yellow';
      ctx.lineWidth = 2;
      const toCanvas = (p)=>({
        x: vp.x + p.x * vp.scale,
        y: vp.y + p.y * vp.scale,
      });
      const drawLine = (a,b)=>{
        const A = toCanvas(a), B = toCanvas(b);
        ctx.beginPath(); ctx.moveTo(A.x, A.y); ctx.lineTo(B.x, B.y); ctx.stroke();
      };
      const drawText = (p, text)=>{
        const P = toCanvas(p);
        ctx.font = '12px monospace';
        ctx.fillStyle = 'yellow';
        ctx.fillText(text, P.x + 6, P.y - 6);
      };
      if (measureDraft && measureDraft.start && measureDraft.end){
        drawLine(measureDraft.start, measureDraft.end);
      }
      measurements.forEach(m=>{ drawLine(m.start, m.end); if (m.label) drawText(m.end, m.label); });
      // Annotations
      annotations.forEach(a=>{ drawText(a.pos, a.text); });
      // Crosshair
      if (crosshair){
        ctx.strokeStyle = 'rgba(0,255,255,0.8)';
        ctx.beginPath();
        ctx.moveTo(canvas.width/2, 0); ctx.lineTo(canvas.width/2, canvas.height);
        ctx.moveTo(0, canvas.height/2); ctx.lineTo(canvas.width, canvas.height/2);
        ctx.stroke();
      }
      ctx.restore();
    }

    function canvasToImageCoords(vp, cx, cy){
      const x = (cx - vp.x) / vp.scale;
      const y = (cy - vp.y) / vp.scale;
      return { x, y };
    }

    function imageDistance(a, b){
      const dx = b.x - a.x, dy = b.y - a.y;
      const px = Math.sqrt(dx*dx + dy*dy);
      const spacing = parsePixelSpacing(currentSeries && currentSeries.pixel_spacing);
      if (spacing && spacing.length >= 2 && isFinite(spacing[0]) && isFinite(spacing[1])){
        const mm = Math.sqrt((dx*spacing[0])**2 + (dy*spacing[1])**2);
        return { px, mm };
      }
      return { px, mm: null };
    }

    async function saveMeasurementToServer(m){
      const imageId = getCurrentImageId();
      if (!imageId) return;
      const dist = imageDistance(m.start, m.end);
      const payload = {
        image_id: imageId,
        type: 'distance',
        points: [m.start, m.end],
        value: dist.mm || dist.px,
        unit: dist.mm ? 'mm' : 'px',
        notes: ''
      };
      try {
        const r = await fetch('/viewer/measurements/save/', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
        const j = await r.json();
        if (j && j.success){
          m.label = dist.mm ? `${dist.mm.toFixed(2)} mm` : `${dist.px.toFixed(1)} px`;
        }
      } catch(e){}
    }

    async function saveAnnotationToServer(p, text){
      const imageId = getCurrentImageId();
      if (!imageId) return;
      try {
        await fetch('/viewer/annotations/save/', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ image_id: imageId, position_x: p.x, position_y: p.y, text }) });
      } catch(e){}
    }

    async function loadOverlaysForCurrentImage(){
      const imageId = getCurrentImageId();
      if (!imageId) return;
      // Load from cache or backend
      if (imageIdToMeasurements.has(imageId)) measurements = imageIdToMeasurements.get(imageId); else {
        try {
          const r = await fetch(`/viewer/measurements/${imageId}/`); const j = await r.json();
          measurements = (j.measurements||[]).map(m=>({ start: m.points[0], end: m.points[1], label: m.unit==='mm' ? `${(+m.value).toFixed(2)} mm` : `${(+m.value).toFixed(1)} px` }));
          imageIdToMeasurements.set(imageId, measurements);
        } catch(e){ measurements = []; }
      }
      if (imageIdToAnnotations.has(imageId)) annotations = imageIdToAnnotations.get(imageId); else {
        try {
          const r = await fetch(`/viewer/annotations/${imageId}/`); const j = await r.json();
          annotations = (j.annotations||[]).map(a=>({ pos: {x:a.position_x, y:a.position_y}, text: a.text }));
          imageIdToAnnotations.set(imageId, annotations);
        } catch(e){ annotations = []; }
      }
      renderMeasurementsList();
      await draw();
    }

    function renderMeasurementsList(){
      measurementsList.innerHTML = '';
      measurements.forEach((m, i)=>{
        const li = document.createElement('li');
        li.textContent = `Measurement ${i+1}: ${m.label||''}`;
        measurementsList.appendChild(li);
      });
    }

    // UI wiring
    seriesSelect.addEventListener('change', e=>{ if(e.target.value) loadSeries(e.target.value); });
    wwSlider.addEventListener('input', e=>{ ww = +e.target.value; document.getElementById('wwVal').textContent = ww; draw(); });
    wlSlider.addEventListener('input', e=>{ wl = +e.target.value; document.getElementById('wlVal').textContent = wl; draw(); });
    sliceSlider.addEventListener('input', async e=>{ index = +e.target.value; document.getElementById('sliceVal').textContent = index+1; await loadOverlaysForCurrentImage(); });
    zoomSlider.addEventListener('input', e=>{ zoom = (+e.target.value)/100; document.getElementById('zoomVal').textContent = `${e.target.value}%`; draw(); });
    document.querySelectorAll('[data-preset]').forEach(btn=>btn.addEventListener('click', ()=>{
      const p = btn.getAttribute('data-preset');
      const map = { lung:{ww:1500,wl:-600}, bone:{ww:2000,wl:300}, soft:{ww:400,wl:40}, brain:{ww:100,wl:50} };
      if (map[p]){ ww = map[p].ww; wl = map[p].wl; wwSlider.value = ww; wlSlider.value = wl; document.getElementById('wwVal').textContent = ww; document.getElementById('wlVal').textContent = wl; draw(); }
    }));
    document.querySelectorAll('.tool').forEach(t=>t.addEventListener('click', ()=>{
      const tool = t.getAttribute('data-tool');
      document.querySelectorAll('.tool').forEach(x=>x.classList.remove('active')); t.classList.add('active');
      if (tool === 'invert'){ inverted = !inverted; draw(); return; }
      if (tool === 'reset'){ zoom = 1.0; panOffset = {x:0,y:0}; zoomSlider.value = 100; document.getElementById('zoomVal').textContent = '100%'; draw(); return; }
      if (tool === 'ai'){ alert('AI analysis result: (stub) No backend connected.'); return; }
      if (tool === 'crosshair'){ crosshair = !crosshair; draw(); return; }
      activeTool = tool;
    }));

    // Mouse interactions on viewport
    const viewport = document.getElementById('viewport');
    viewport.addEventListener('mousedown', (e)=>{
      isDragging = true; dragStart = { x: e.offsetX, y: e.offsetY };
      // Start measurement draft
      if (activeTool === 'measure'){
        const vp2 = getViewportPlacement(canvas.width, canvas.height);
        measureDraft = { start: canvasToImageCoords(vp2, e.offsetX, e.offsetY), end: canvasToImageCoords(vp2, e.offsetX, e.offsetY) };
      }
    });
    viewport.addEventListener('mousemove', async (e)=>{
      if (!isDragging) return;
      const vp = getViewportPlacement(canvas.width, canvas.height);
      if (activeTool === 'window'){
        const dx = e.offsetX - dragStart.x; const dy = e.offsetY - dragStart.y; dragStart = { x: e.offsetX, y: e.offsetY };
        ww = Math.max(1, ww + dx*4); wl = wl + dy*2; wwSlider.value = Math.round(ww); wlSlider.value = Math.round(wl); document.getElementById('wwVal').textContent = Math.round(ww); document.getElementById('wlVal').textContent = Math.round(wl); await draw();
      } else if (activeTool === 'pan'){
        panOffset.x += (e.offsetX - dragStart.x); panOffset.y += (e.offsetY - dragStart.y); dragStart = { x: e.offsetX, y: e.offsetY }; await draw();
      } else if (activeTool === 'measure' && measureDraft){
        measureDraft.end = canvasToImageCoords(vp, e.offsetX, e.offsetY); await draw();
      } else if (activeTool === 'annotate'){
        // no-op while dragging
      } else if (activeTool === 'zoom'){
        const dy = e.offsetY - dragStart.y; dragStart = { x: e.offsetX, y: e.offsetY }; const factor = dy<0 ? 1.05 : 0.95; zoom = Math.min(5.0, Math.max(0.25, zoom*factor)); zoomSlider.value = Math.round(zoom*100); document.getElementById('zoomVal').textContent = `${Math.round(zoom*100)}%`; await draw();
      }
    });
    viewport.addEventListener('mouseup', async (e)=>{
      if (!isDragging) return; isDragging = false;
      const vp = getViewportPlacement(canvas.width, canvas.height);
      if (activeTool === 'measure' && measureDraft){
        measureDraft.end = canvasToImageCoords(vp, e.offsetX, e.offsetY);
        const m = { start: measureDraft.start, end: measureDraft.end };
        measureDraft = null; measurements.push(m); imageIdToMeasurements.set(getCurrentImageId(), measurements);
        await saveMeasurementToServer(m); renderMeasurementsList(); await draw();
      } else if (activeTool === 'annotate'){
        const pos = canvasToImageCoords(vp, e.offsetX, e.offsetY);
        const text = prompt('Enter annotation text:');
        if (text){ annotations.push({ pos, text }); imageIdToAnnotations.set(getCurrentImageId(), annotations); await saveAnnotationToServer(pos, text); await draw(); }
      }
    });

    // Mouse wheel slice/zoom
    document.getElementById('viewport').addEventListener('wheel', (e)=>{
      e.preventDefault();
      if (e.ctrlKey){ const delta = e.deltaY>0?0.9:1.1; zoom = Math.max(0.1, Math.min(5.0, zoom*delta)); zoomSlider.value = Math.round(zoom*100); document.getElementById('zoomVal').textContent = `${Math.round(zoom*100)}%`; draw(); }
      else { const d = e.deltaY>0?1:-1; const ni = Math.max(0, Math.min(images.length-1, index+d)); if (ni !== index){ index = ni; sliceSlider.value = index; document.getElementById('sliceVal').textContent = index+1; loadOverlaysForCurrentImage(); } }
    }, { passive:false });

    // Local DICOM upload
    btnLoadLocal.addEventListener('click', ()=> inputLocal.click());
    inputLocal.addEventListener('change', async (e)=>{
      try {
        if (!e.target.files || !e.target.files.length) return;
        reconStatus.textContent = 'Uploading DICOM files...';
        const form = new FormData();
        Array.from(e.target.files).forEach(f=> form.append('dicom_files', f));
        const resp = await fetch('/viewer/upload/', { method:'POST', body: form });
        const data = await resp.json();
        if (!data.success) throw new Error(data.error || 'Upload failed');
        reconStatus.textContent = 'Upload complete. Loading study...';
        await loadStudy(data.study_id);
        reconStatus.textContent = '';
      } catch (err){
        reconStatus.textContent = `Error: ${err.message}`;
        await fallbackToDesktop();
      } finally {
        e.target.value = '';
      }
    });

    // Recon controls
    reconType.addEventListener('change', ()=>{
      const v = reconType.value; boneCtrl.style.display = v==='bone' ? '' : 'none';
      if (v==='bone') reconViews.style.display = 'none';
    });
    boneSlider.addEventListener('input', e=> boneVal.textContent = e.target.value);

    btnGenerateRecon.addEventListener('click', async ()=>{
      try {
        if (!currentSeries || !currentSeries.id){ alert('Select a series first'); return; }
        reconStatus.textContent = 'Generating...';
        reconViews.style.display = 'none';
        const params = new URLSearchParams();
        params.set('window_width', ww);
        params.set('window_level', wl);
        params.set('inverted', inverted);
        let url = '';
        if (reconType.value === 'mpr') url = `/viewer/api/series/${currentSeries.id}/mpr/?${params.toString()}`;
        else if (reconType.value === 'mip') url = `/viewer/api/series/${currentSeries.id}/mip/?${params.toString()}`;
        else { url = `/viewer/api/series/${currentSeries.id}/bone/?threshold=${boneSlider.value}`; }
        const r = await fetch(url);
        const j = await r.json();
        if (j.error) throw new Error(j.error);
        let axial = null, sagittal = null, coronal = null;
        if (j.mpr_views){ axial = j.mpr_views.axial; sagittal = j.mpr_views.sagittal; coronal = j.mpr_views.coronal; }
        if (j.mip_views){ axial = j.mip_views.axial; sagittal = j.mip_views.sagittal; coronal = j.mip_views.coronal; }
        if (j.bone_views){ axial = j.bone_views.axial || j.bone_views.bone_axial_preview; sagittal = j.bone_views.sagittal || j.bone_views.bone_sagittal_preview; coronal = j.bone_views.coronal || j.bone_views.bone_coronal_preview; }
        if (axial && sagittal && coronal){
          viewAxial.src = axial; viewSagittal.src = sagittal; viewCoronal.src = coronal; reconViews.style.display = '';
        }
        reconStatus.textContent = 'Done'; setTimeout(()=> reconStatus.textContent = '', 1500);
      } catch (err){
        reconStatus.textContent = `Error: ${err.message}`;
        await fallbackToDesktop();
      }
    });

    // Clear measurements
    btnClearMeasurements.addEventListener('click', ()=>{
      measurements = []; imageIdToMeasurements.set(getCurrentImageId(), measurements); renderMeasurementsList(); draw();
    });

    // Init
    setCanvasSize();
    const studyId = q('study_id');
    if (studyId) loadStudy(studyId);
  })();
  </script>
</body>
</html>