<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DICOM Viewer</title>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
  <style>
    body { margin: 0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; background: #1a1a1a; color: #fff; }
    .layout { display: grid; grid-template-columns: 80px 1fr 300px; grid-template-rows: 60px 1fr; height: 100vh; }
    .toolbar { grid-row: 1 / span 2; grid-column: 1; background: #2a2a2a; border-right: 1px solid #444; padding: 8px 6px; display: flex; flex-direction: column; gap: 6px; overflow:auto; }
    .tool { width: 50px; height: 44px; background: #3a3a3a; border: none; border-radius: 8px; color: #fff; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 10px; }
    .tool.active { background: #0078d4; }
    .tool i { font-size: 16px; margin-bottom: 2px; }
    .topbar { grid-row: 1; grid-column: 2 / span 2; display: flex; align-items: center; gap: 8px; padding: 0 12px; background: #2a2a2a; border-bottom: 1px solid #444; }
    .btn { padding: 6px 10px; border: none; border-radius: 6px; cursor: pointer; font-size: 12px; }
    .btn-primary { background: #0078d4; color: #fff; }
    .select { padding: 6px 8px; background: #3a3a3a; border: 1px solid #555; border-radius: 6px; color: #fff; min-width: 180px; font-size: 12px; }
    .viewport { grid-row: 2; grid-column: 2; background: #000; position: relative; display: flex; align-items: center; justify-content: center; }
    .right { grid-row: 2; grid-column: 3; background: #2a2a2a; border-left: 1px solid #444; padding: 16px; overflow: auto; }
    .panel { margin-bottom: 18px; }
    .panel h3 { font-size: 15px; margin: 0 0 10px; padding-bottom: 8px; border-bottom: 1px solid #444; }
    .control { margin-bottom: 12px; }
    .control .label { display: flex; justify-content: space-between; font-size: 12px; color: #ccc; margin-bottom: 6px; }
    input[type=range] { width: 100%; }
    .overlay { position: absolute; top: 12px; left: 12px; background: rgba(0,0,0,0.6); padding: 8px 10px; border-radius: 6px; font-family: monospace; font-size: 12px; }
    .zoominfo { position: absolute; bottom: 12px; left: 12px; background: rgba(0,0,0,0.6); padding: 6px 10px; border-radius: 6px; font-family: monospace; font-size: 12px; }
    canvas { max-width: 100%; max-height: 100%; image-rendering: pixelated; image-rendering: crisp-edges; }
    .thumbs { display:grid; grid-template-columns: 1fr 1fr; gap:8px; }
    .thumbs img { width:100%; background:#000; border-radius:6px; border:1px solid #444; }
    .row-3 { display:grid; grid-template-columns: 1fr 1fr 1fr; gap:8px; }
    .muted { color:#bbb; font-size:12px; }
    /* 3D dropdown in toolbar */
    .tool-dropdown { position: relative; }
    .tool-dropdown-menu { position: absolute; top: 48px; left: 0; background: #2f2f2f; border: 1px solid #444; border-radius: 8px; width: 180px; display: none; flex-direction: column; overflow: hidden; z-index: 10; }
    .tool-dropdown-menu button { background: transparent; border: none; color: #fff; text-align: left; padding: 8px 10px; cursor: pointer; font-size: 12px; }
    .tool-dropdown-menu button:hover { background: #0078d4; }
    /* 3D modal */
    #threeContainer { position: fixed; inset: 0; background: rgba(0,0,0,0.95); display: none; z-index: 1000; }
    #threeMount { position: absolute; inset: 0; }
    #close3d { position: absolute; top: 12px; right: 12px; z-index: 1001; }
    /* DICOM tags modal */
    #dicomModal { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; background: rgba(0,0,0,0.8); z-index: 1200; }
    #dicomModal .modal-card { background:#1e1e1e; border:1px solid #444; padding:16px; width:70%; max-width: 960px; max-height:80%; overflow:auto; border-radius:8px; }
    #dicomModal .modal-header { display:flex; justify-content: space-between; align-items:center; margin-bottom:8px; }
  </style>
  
  <!-- Import map to resolve bare specifier used by OrbitControls -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
    }
  }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';
    // Expose for existing viewer code without mutating the import namespace
    window.THREE = THREE;
    window.OrbitControls = OrbitControls;
  </script>
</head>
<body>
  <div class="layout">
    <div class="toolbar">
      <button class="tool active" data-tool="window"><i class="fas fa-adjust"></i><span>Window</span></button>
      <button class="tool" data-tool="zoom"><i class="fas fa-search-plus"></i><span>Zoom</span></button>
      <button class="tool" data-tool="pan"><i class="fas fa-arrows-alt"></i><span>Pan</span></button>
      <button class="tool" data-tool="measure"><i class="fas fa-ruler"></i><span>Measure</span></button>
      <button class="tool" data-tool="annotate"><i class="fas fa-comment-dots"></i><span>Annotate</span></button>
      <button class="tool" data-tool="crosshair"><i class="fas fa-crosshairs"></i><span>Crosshair</span></button>
      <button class="tool" data-tool="hu"><i class="fas fa-thermometer-half"></i><span>HU</span></button>
      <button class="tool" data-tool="invert"><i class="fas fa-adjust"></i><span>Invert</span></button>
      <button class="tool" data-tool="reset"><i class="fas fa-undo"></i><span>Reset</span></button>
      <button class="tool" data-tool="fit"><i class="fas fa-compress-arrows-alt"></i><span>Fit</span></button>
      <button class="tool" data-tool="one"><i class="fas fa-expand"></i><span>1:1</span></button>
      <button class="tool" data-tool="cine"><i class="fas fa-film"></i><span>Cine</span></button>
      <button class="tool" data-tool="spyglass"><i class="fas fa-search"></i><span>Spyglass</span></button>
      <button class="tool" data-tool="align-center"><i class="fas fa-align-center"></i><span>Center</span></button>
      <button class="tool" data-tool="reload"><i class="fas fa-sync"></i><span>Reload</span></button>
      <button class="tool" data-tool="ai"><i class="fas fa-robot"></i><span>AI</span></button>
      <!-- 3D dropdown moved into toolbar -->
      <div class="tool-dropdown">
        <button id="btn3D" class="tool"><i class="fas fa-cube"></i><span>3D</span></button>
        <div id="menu3D" class="tool-dropdown-menu">
          <button data-recon="mpr"><i class="fas fa-layer-group"></i> MPR</button>
          <button data-recon="mip"><i class="fas fa-bullseye"></i> MIP</button>
          <button data-recon="bone"><i class="fas fa-bone"></i> Bone</button>
        </div>
      </div>
    </div>
    <div class="topbar">
      <button id="btnLoadLocal" class="btn btn-primary"><i class="fas fa-folder-open"></i> Load Local DICOM</button>
      <button id="btnBackWorklist" class="btn" onclick="returnToWorklist(event)"><i class="fas fa-arrow-left"></i> Back to Worklist</button>
      {% if user.is_authenticated and user.can_edit_reports %}
      <button id="btnWriteReport" class="btn btn-primary" style="display:none"><i class="fas fa-file-signature"></i> Write Report</button>
      {% endif %}
      <input id="localDicom" type="file" multiple webkitdirectory directory accept=".dcm,.dicom,application/dicom" style="display:none" />
      <select id="seriesSelect" class="select"><option value="">Select Series</option></select>
      <select id="sortSelect" class="select">
        <option value="">Sort: Instance # (asc)</option>
        <option value="inst_desc">Instance # (desc)</option>
      </select>
      <button id="btnToggleTags" class="btn"><i class="fas fa-tags"></i> Tags</button>
      <button id="btnShowDicom" class="btn"><i class="fas fa-info-circle"></i> Show DICOM</button>
      <button id="btnCapture" class="btn"><i class="fas fa-camera"></i> Capture</button>
      <div id="patientInfo" style="margin-left:auto;color:#ccc;font-size:13px;">Patient: - | Study Date: - | Modality: -</div>
    </div>
    <div class="viewport" id="viewport">
      <canvas id="dicomCanvas"></canvas>
      <div class="overlay" id="overlay">WW: 400<br>WL: 40<br>Slice: 1/1</div>
      <div class="zoominfo" id="zoominfo">Zoom: 100%</div>
    </div>
    <div class="right">
      <div class="panel">
        <h3>Window/Level</h3>
        <div class="control"><div class="label"><span>Window Width</span><span id="wwVal">400</span></div><input id="ww" type="range" min="1" max="4000" value="400"></div>
        <div class="control"><div class="label"><span>Window Level</span><span id="wlVal">40</span></div><input id="wl" type="range" min="-1000" max="1000" value="40"></div>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;">
          <button class="btn" data-preset="lung">Lung</button>
          <button class="btn" data-preset="bone">Bone</button>
          <button class="btn" data-preset="soft">Soft</button>
          <button class="btn" data-preset="brain">Brain</button>
        </div>
      </div>
      <div class="panel">
        <h3>Measurement Units</h3>
        <div class="control">
          <label class="label" for="unitSelect"><span>Display Unit</span><span id="unitVal">mm</span></label>
          <select id="unitSelect" class="select">
            <option value="mm" selected>Millimeters (mm)</option>
            <option value="cm">Centimeters (cm)</option>
          </select>
        </div>
      </div>
      <div class="panel" id="mprMeasurePanel" style="display:none;">
        <h3>MPR Measurements</h3>
        <div class="control">
          <div class="label"><span>Plane Selection</span></div>
          <select id="mprMeasurePlane" class="select">
            <option value="auto" selected>Auto (by quadrant)</option>
            <option value="axial">Axial</option>
            <option value="sagittal">Sagittal</option>
            <option value="coronal">Coronal</option>
          </select>
        </div>
        <div class="control">
          <div class="label"><span>Measurement</span></div>
          <select id="mprMeasureType" class="select">
            <option value="distance" selected>Distance</option>
          </select>
        </div>
      </div>
      <div class="panel">
        <h3>Navigation</h3>
        <div class="control"><div class="label"><span>Slice</span><span id="sliceVal">1</span></div><input id="slice" type="range" min="0" max="0" value="0"></div>
      </div>
      <div class="panel">
        <h3>Transform</h3>
        <div class="control"><div class="label"><span>Zoom</span><span id="zoomVal">100%</span></div><input id="zoom" type="range" min="25" max="500" value="100"></div>
      </div>
      <div class="panel">
        <h3>3D Reconstruction</h3>
        <div class="control">
          <div class="label"><span>Type</span></div>
          <select id="reconType" class="select">
            <option value="mpr">MPR (Axial/Sagittal/Coronal)</option>
            <option value="mip">MIP (Max Intensity)</option>
            <option value="bone">Bone 3D (threshold)</option>
          </select>
        </div>
        <div class="control" id="boneCtrl" style="display:none;">
          <div class="label"><span>Bone Threshold (HU)</span><span id="boneVal">300</span></div>
          <input id="boneThreshold" type="range" min="100" max="1500" value="300">
        </div>
        <div class="control">
          <button id="btnGenerateRecon" class="btn btn-primary"><i class="fas fa-cogs"></i> Generate</button>
        </div>
        <div class="muted" id="reconStatus"></div>
        <div class="row-3" id="reconViews" style="margin-top:8px; display:none;">
          <img id="viewAxial" alt="Axial" loading="lazy" decoding="async"/>
          <img id="viewSagittal" alt="Sagittal" loading="lazy" decoding="async"/>
          <img id="viewCoronal" alt="Coronal" loading="lazy" decoding="async"/>
        </div>
      </div>
      <div class="panel">
        <h3>Image Info</h3>
        <div id="dimInfo" style="color:#ccc;font-size:12px;">Dimensions: -</div>
        <div id="spacingInfo" style="color:#ccc;font-size:12px;">Pixel Spacing: -</div>
        <div id="seriesInfo" style="color:#ccc;font-size:12px;">Series: -</div>
        <div id="institutionInfo" style="color:#ccc;font-size:12px;">Institution: -</div>
        <div id="clinicalInfo" style="color:#ccc;font-size:12px; margin-top:8px; white-space:pre-wrap;">Clinical Info: -</div>
        <div id="priorityInfo" style="color:#ccc;font-size:12px;">Priority: -</div>
      </div>
      <div class="panel">
        <h3>Measurements</h3>
        <div class="control">
          <button id="btnClearMeasurements" class="btn">Clear All</button>
        </div>
        <ul id="measurementsList" style="list-style:none;padding-left:0;margin:0;color:#ddd;font-size:12px;"></ul>
      </div>
    </div>
  </div>

  <!-- Three.js for rotatable bone mesh (loaded only if used) -->
  <!-- Removed deprecated UMD scripts; using ES Modules via importmap -->
  <div id="threeContainer">
    <button id="close3d" class="btn">Close 3D</button>
    <div id="threeMount"></div>
  </div>
  <div id="dicomModal">
    <div class="modal-card">
      <div class="modal-header">
        <h3 style="margin:0;">DICOM Tags</h3>
        <button id="closeDicomModal" class="btn">Close</button>
      </div>
      <pre id="dicomTagsPre" style="white-space:pre-wrap; color:#ddd;"></pre>
    </div>
  </div>

  <script>
  (function(){
    const canvas = document.getElementById('dicomCanvas');
    const ctx = canvas.getContext('2d');
    const seriesSelect = document.getElementById('seriesSelect');
    const wwSlider = document.getElementById('ww');
    const wlSlider = document.getElementById('wl');
    const sliceSlider = document.getElementById('slice');
    const zoomSlider = document.getElementById('zoom');
    const btnLoadLocal = document.getElementById('btnLoadLocal');
    const inputLocal = document.getElementById('localDicom');
    const btnClearMeasurements = document.getElementById('btnClearMeasurements');
    const measurementsList = document.getElementById('measurementsList');

    const reconType = document.getElementById('reconType');
    const boneCtrl = document.getElementById('boneCtrl');
    const boneSlider = document.getElementById('boneThreshold');
    const boneVal = document.getElementById('boneVal');
    const btnGenerateRecon = document.getElementById('btnGenerateRecon');
    const reconStatus = document.getElementById('reconStatus');
    const reconViews = document.getElementById('reconViews');
    const viewAxial = document.getElementById('viewAxial');
    const viewSagittal = document.getElementById('viewSagittal');
    const viewCoronal = document.getElementById('viewCoronal');

    // 3D dropdown controls
          const btn3D = document.getElementById('btn3D');
      const menu3D = document.getElementById('menu3D');
      // Reduce initial image decode overhead for large previews
      [viewAxial, viewSagittal, viewCoronal].forEach(img=>{ if(img){ img.loading='eager'; img.decoding='async'; }});

    // Topbar extras
    const sortSelect = document.getElementById('sortSelect');
    const btnToggleTags = document.getElementById('btnToggleTags');
    const btnShowDicom = document.getElementById('btnShowDicom');
    const btnCapture = document.getElementById('btnCapture');
    const dicomModal = document.getElementById('dicomModal');
    const dicomTagsPre = document.getElementById('dicomTagsPre');
    const closeDicomModal = document.getElementById('closeDicomModal');

    let currentStudy = null;
    let currentSeries = null;
    let images = [];
    let index = 0;
    let ww = 400, wl = 40, inverted = false, zoom = 1.0;
    let defaultWw = 400, defaultWl = 40;
    let mprMode = false;
    let mprImgs = { axial: null, sagittal: null, coronal: null };
    let reconMode = null; // 'mpr' | 'mip' | 'bone' | null
    let reconImgs = []; // ordered list of image data URLs for canvas display
    let reconIndex = 0;
    // MPR plane browsing state
    let mprScroll = { axial: 0, sagittal: 0, coronal: 0, counts: { axial: 0, sagittal: 0, coronal: 0 } };
    // Crosshair linkage across planes (x: sagittal index, y: coronal index, z: axial index)
    let mprCross = { x: null, y: null, z: null };
    let showHuProbe = false;
    let huEllipse = null;
    let activeTool = 'window';
    let isDragging = false;
    let dragStart = null;
    let panOffset = { x: 0, y: 0 };
    let measureDraft = null; // {start:{x,y}, end:{x,y}}
    let measurements = []; // persisted per image id
    let annotations = [];
    let crosshair = false;
    let measureUnit = 'mm';
    let mprMeasurements = { axial: [], sagittal: [], coronal: [] };
    let mprMeasurePlaneMode = 'auto'; // 'auto' | 'axial' | 'sagittal' | 'coronal'
    let mprMeasureType = 'distance';
    const mprImageCache = new Map(); // key: series|plane|slice|ww|wl|inv -> Promise<string>|string

    // New states
    let showTagsOverlay = false;
    let currentImageTags = null;
    let cineActive = false; let cineTimer = null; let cineFps = 12;
    let spyglass = { active:false, radius:80, factor:2.0, invert:false, isPress:false, cx:0, cy:0 };
    let mprFullPlane = null; // enlarged plane key when in MPR

    // Track last viewport mapping for precise coordinate transforms
    let lastVp = null; // {x,y,scale,imgW,imgH}
    const mprRegionVps = {}; // key-> {x,y,scale,imgW,imgH,rect}

    // Map imageId -> arrays to persist while session active
    const imageIdToMeasurements = new Map();
    const imageIdToAnnotations = new Map();

    // Image cache and render scheduler to improve responsiveness
    const imageCache = new Map(); // key -> Promise<HTMLImageElement> | HTMLImageElement
    let drawScheduled = false;
    const userCanEdit = {% if user.can_edit_reports %}true{% else %}false{% endif %};
    function requestDraw(){
      if (drawScheduled) return;
      drawScheduled = true;
      requestAnimationFrame(async ()=>{ drawScheduled = false; await draw(); });
    }
    function debounce(fn, delay){
      let t; return (...args)=>{ clearTimeout(t); t = setTimeout(()=> fn(...args), delay); };
    }
    // Cancelable overlay requests
    let overlayRequestId = 0;
    function getImageKey(imageId, ww, wl, inverted){
      return `${imageId}|${Math.round(ww)}|${Math.round(wl)}|${inverted?1:0}`;
    }
    async function loadHtmlImage(src){
      return new Promise((resolve, reject)=>{ const im = new Image(); im.crossOrigin = 'anonymous'; im.decoding = 'async'; im.onload = ()=> resolve(im); im.onerror = reject; im.src = src; });
    }
    async function getImageForIndex(i){
      const imgMeta = images[i];
      if (!imgMeta) return null;
      const key = getImageKey(imgMeta.id, ww, wl, inverted);
      if (imageCache.has(key)){
        const val = imageCache.get(key);
        return typeof val.then === 'function' ? await val : val;
      }
      const url = `/viewer/image/${imgMeta.id}/?ww=${ww}&wl=${wl}&invert=${inverted}`;
      const promise = loadHtmlImage(url).then(im=>{ imageCache.set(key, im); return im; }).catch(err=>{ imageCache.delete(key); throw err; });
      imageCache.set(key, promise);
      return await promise;
    }
    function prefetchIndex(i){
      if (i < 0 || i >= images.length) return;
      const imgMeta = images[i];
      const key = getImageKey(imgMeta.id, ww, wl, inverted);
      if (imageCache.has(key)) return;
      const url = `/viewer/image/${imgMeta.id}/?ww=${ww}&wl=${wl}&invert=${inverted}`;
      const promise = loadHtmlImage(url).then(im=>{ imageCache.set(key, im); return im; }).catch(()=>{ imageCache.delete(key); });
      imageCache.set(key, promise);
    }
    function prefetchAround(center, radius=3){
      for (let o = -radius; o <= radius; o++){
        if (o === 0) continue;
        prefetchIndex(center + o);
      }
    }
    const debouncedLoadOverlaysForCurrentImage = debounce(()=>{ loadOverlaysForCurrentImage(); }, 80);

    // Helper: parse pixel spacing robustly (string "0.5\\0.5", "0.5,0.5" or array)
    function parsePixelSpacing(ps){
      if (!ps) return null;
      if (Array.isArray(ps)) return ps.map(Number);
      if (typeof ps === 'string'){
        const parts = ps.split(/[\\,\s]+/).filter(Boolean);
        if (parts.length >= 2) return [parseFloat(parts[0]), parseFloat(parts[1])];
      }
      return null;
    }

    async function fallbackToDesktop(){
      try {
        const params = new URLSearchParams(window.location.search);
        const studyId = params.get('study_id') || (currentStudy && currentStudy.id);
        if (studyId){
          const resp = await fetch(`/viewer/launch-desktop/${studyId}/`);
          const j = await resp.json();
          if (j && j.fallback_url){ window.location.href = j.fallback_url; return; }
          // Desktop launched; leave page as-is
        } else {
          const resp = await fetch('/viewer/launch-desktop/', { method:'POST', headers:{'Content-Type':'application/json'}, body: '{}' });
          const j = await resp.json();
          if (j && j.fallback_url){ window.location.href = j.fallback_url; return; }
        }
      } catch (e) {
        // swallow
      }
    }

    function setCanvasSize(){
      const vp = document.getElementById('viewport');
      const rect = vp.getBoundingClientRect();
      canvas.width = Math.max(100, rect.width - 20);
      canvas.height = Math.max(100, rect.height - 20);
    }
    window.addEventListener('resize', ()=>{ setCanvasSize(); requestDraw(); });

    function q(name){ return new URLSearchParams(window.location.search).get(name); }

    async function loadStudy(studyId){
      try {
        const r = await fetch(`/viewer/study/${studyId}/`);
        if (!r.ok) throw new Error('study fetch failed');
        const data = await r.json();
        currentStudy = data.study;
        // Enable write report button when study is known
        const wr = document.getElementById('btnWriteReport');
        if (wr && currentStudy && currentStudy.id){
          wr.style.display = '';
          wr.onclick = function(){ window.location.href = `/reports/write/${currentStudy.id}/`; };
        }
        // Mark study as in_progress when opened by editor roles
        try {
          if (userCanEdit && currentStudy && currentStudy.id){
            await fetch(`/worklist/api/study/${currentStudy.id}/update-status/`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json', 'X-CSRFToken': getCookie('csrftoken') },
              body: JSON.stringify({ status: 'in_progress' }),
              credentials: 'same-origin'
            });
          }
        } catch (_) { /* non-blocking */ }
        document.getElementById('patientInfo').textContent = `Patient: ${currentStudy.patient_name} | Study Date: ${currentStudy.study_date} | Modality: ${currentStudy.modality}`;
        // Show clinical info and priority
        const clin = (currentStudy.clinical_info && currentStudy.clinical_info.trim()) ? currentStudy.clinical_info : '-';
        document.getElementById('clinicalInfo').textContent = `Clinical Info: ${clin}`;
        document.getElementById('priorityInfo').textContent = `Priority: ${currentStudy.priority ? currentStudy.priority.toUpperCase() : '-'}`;
        seriesSelect.innerHTML = '<option value="">Select Series</option>';
        (data.series_list || []).forEach(s=>{
          const opt = document.createElement('option');
          opt.value = s.id; opt.textContent = `Series ${s.series_number} - ${s.modality} (${s.image_count} images)`;
          seriesSelect.appendChild(opt);
        });
        if ((data.series_list||[]).length){
          seriesSelect.value = data.series_list[0].id;
          await loadSeries(data.series_list[0].id);
        }
      } catch (e) {
        await fallbackToDesktop();
      }
    }

    async function loadSeries(seriesId){
      try {
        const r = await fetch(`/viewer/series/${seriesId}/images/`);
        if (!r.ok) throw new Error('series fetch failed');
        const data = await r.json();
        currentSeries = data.series; images = data.images || []; index = 0;
        imageCache.clear();
        sliceSlider.max = Math.max(0, images.length - 1); sliceSlider.value = 0; document.getElementById('sliceVal').textContent = '1';
        if (images.length){
          const probe = await fetch(`/viewer/api/image/${images[0].id}/display/`);
          if (probe.ok){
            const j = await probe.json();
            if (j && j.image_info){
              ww = j.image_info.default_window_width || ww;
              wl = j.image_info.default_window_level || wl;
              defaultWw = ww; defaultWl = wl;
              if (j.windowing && typeof j.windowing.inverted === 'boolean') { inverted = j.windowing.inverted; }
            }
          }
          wwSlider.value = Math.round(ww); wlSlider.value = Math.round(wl); document.getElementById('wwVal').textContent = Math.round(ww); document.getElementById('wlVal').textContent = Math.round(wl);
        }
        // Reset view state
        zoom = 1.0; panOffset = {x:0,y:0}; activeTool = 'window'; crosshair = false; mprMode = false; mprImgs = {axial:null,sagittal:null,coronal:null}; reconMode = null; reconImgs = []; reconIndex = 0;
        mprCross = { x: null, y: null, z: null }; // reset crosshair linkage
        mprMeasurements = { axial: [], sagittal: [], coronal: [] };
        mprImageCache.clear();
        const enterMpr = document.getElementById('btnEnterMpr');
        const exitMpr = document.getElementById('btnExitMpr');
        if (enterMpr) enterMpr.style.display = images.length ? '' : 'none';
        if (exitMpr) exitMpr.style.display = 'none';
        document.querySelectorAll('.tool').forEach(x=>x.classList.remove('active'));
        document.querySelector('.tool[data-tool="window"]').classList.add('active');
        setCanvasSize();
        await draw();
        await loadOverlaysForCurrentImage();
        // Prefetch neighbors
        prefetchAround(0, 3);
        // Warm up MPR mid-slices so first MPR is instant
        try { warmupMpr(); } catch(e) {}
      } catch (e) {
        await fallbackToDesktop();
      }
    }

    function getCurrentImageId(){
      if (!images.length) return null;
      return images[index].id;
    }

    function getViewportPlacement(imgW, imgH){
      const scale = Math.min(canvas.width / imgW, canvas.height / imgH) * zoom;
      const w = imgW * scale, h = imgH * scale;
      const x = (canvas.width - w)/2 + panOffset.x;
      const y = (canvas.height - h)/2 + panOffset.y;
      return { scale, w, h, x, y };
    }

    async function draw(){
      if (!images.length && reconImgs.length===0) { ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height); return; }
      if (mprMode){
        try{
          // Enlarge one plane if set
          if (mprFullPlane){
            // Ensure image for that plane is current
            if (!mprImgs[mprFullPlane]){
              try {
                const img = await getMprImage(currentSeries.id, mprFullPlane, mprScroll[mprFullPlane] || 0);
                mprImgs[mprFullPlane] = img;
              } catch(e){}
            }
            ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
            const imgSrc = mprImgs[mprFullPlane];
            if (imgSrc){
                             const im = await loadImage(imgSrc);
               const scale = Math.min(canvas.width / im.width, canvas.height / im.height);
               const dw = im.width * scale, dh = im.height * scale;
               const dx = (canvas.width - dw)/2, dy = (canvas.height - dh)/2;
               if (ctx.imageSmoothingEnabled !== false) ctx.imageSmoothingEnabled = false; ctx.drawImage(im, dx, dy, dw, dh);
               mprRegionVps[mprFullPlane] = { x: dx, y: dy, scale: scale, imgW: im.width, imgH: im.height, rect: {x:0,y:0,w:canvas.width,h:canvas.height} };
               if (huEllipse && huEllipse.mode==='mpr' && huEllipse.plane===mprFullPlane){ drawEllipseOverlay(mprFullPlane); }
               // Draw linked crosshair on enlarged plane (only if enabled)
               if (crosshair) { drawMprCrosshairOverlay(mprFullPlane, dx, dy, scale, im.width, im.height); }
            }
            document.getElementById('overlay').innerHTML = `MPR (${mprFullPlane.toUpperCase()}) | WW: ${Math.round(ww)}<br>WL: ${Math.round(wl)}`;
            document.getElementById('zoominfo').textContent = `MPR`;
            return;
          }
          // Ensure counts and initial mid-slice indices are loaded
          if (!mprImgs.axial || !mprImgs.sagittal || !mprImgs.coronal){
            const params = new URLSearchParams(); params.set('window_width', ww); params.set('window_level', wl); params.set('inverted', inverted);
            const r = await fetch(`/viewer/api/series/${currentSeries.id}/mpr/?${params.toString()}`);
            const j = await r.json();
            if (j && j.mpr_views){ mprImgs = j.mpr_views; }
            if (j && j.counts){
              mprScroll.counts = j.counts;
              mprScroll.axial = Math.floor((j.counts.axial||0)/2);
              mprScroll.sagittal = Math.floor((j.counts.sagittal||0)/2);
              mprScroll.coronal = Math.floor((j.counts.coronal||0)/2);
              if (mprCross.x === null || mprCross.y === null || mprCross.z === null){
                mprCross = {
                  x: mprScroll.sagittal,
                  y: mprScroll.coronal,
                  z: mprScroll.axial
                };
              }
              // Immediately request exact mid slices for all planes
              await Promise.all([
                getMprImage(currentSeries.id, 'axial', mprScroll.axial).then(img=>{ mprImgs.axial = img; }).catch(()=>{}),
                getMprImage(currentSeries.id, 'sagittal', mprScroll.sagittal).then(img=>{ mprImgs.sagittal = img; }).catch(()=>{}),
                getMprImage(currentSeries.id, 'coronal', mprScroll.coronal).then(img=>{ mprImgs.coronal = img; }).catch(()=>{})
              ]);
              prefetchMprSlices('axial', mprScroll.axial);
              prefetchMprSlices('sagittal', mprScroll.sagittal);
              prefetchMprSlices('coronal', mprScroll.coronal);
            }
          }
          ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
          const halfW = Math.floor(canvas.width/2), halfH = Math.floor(canvas.height/2);
          const regions = [
            { x: 0, y: 0, w: halfW, h: halfH, key: 'sagittal' },
            { x: halfW, y: 0, w: canvas.width - halfW, h: halfH, key: 'coronal' },
            { x: 0, y: halfH, w: halfW, h: canvas.height - halfH, key: 'axial' },
            { x: halfW, y: halfH, w: canvas.width - halfW, h: canvas.height - halfH, key: 'empty' },
          ];
          // Crosshair dividing lines
          ctx.save();
          ctx.strokeStyle = 'rgba(0,255,255,0.8)';
          ctx.beginPath();
          ctx.moveTo(halfW, 0); ctx.lineTo(halfW, canvas.height);
          ctx.moveTo(0, halfH); ctx.lineTo(canvas.width, halfH);
          ctx.stroke();
          ctx.restore();
          // Draw regions using available images immediately, then refresh asynchronously
          for (const reg of regions){
            if (reg.key === 'empty') continue;
            const imgSrc = mprImgs[reg.key];
            if (imgSrc){
                         const im = await loadImage(imgSrc);
               const scale = Math.min(reg.w / im.width, reg.h / im.height);
               const dw = im.width * scale, dh = im.height * scale;
               const dx = reg.x + (reg.w - dw)/2, dy = reg.y + (reg.h - dh)/2;
               // Hint to use low quality interpolation for speed
               if (ctx.imageSmoothingEnabled !== false) ctx.imageSmoothingEnabled = false;
               ctx.drawImage(im, dx, dy, dw, dh);
              // Save mapping for tools
              mprRegionVps[reg.key] = { x: dx, y: dy, scale: scale, imgW: im.width, imgH: im.height, rect: reg };
              // Draw plane label and slice index
              ctx.save();
              ctx.fillStyle = 'rgba(0,0,0,0.5)';
              ctx.fillRect(dx + 8, dy + 8, 150, 22);
              ctx.fillStyle = '#0ff';
              ctx.font = '12px monospace';
              ctx.fillText(`${reg.key.toUpperCase()} ${ (mprScroll[reg.key]||0) + 1 }/${ mprScroll.counts[reg.key]||0 }`, dx + 12, dy + 24);
              ctx.restore();
              // Draw measurement overlays for this plane
              ctx.save();
              ctx.strokeStyle = 'yellow'; ctx.fillStyle = 'yellow'; ctx.lineWidth = 2;
              const planeMeasures = mprMeasurements[reg.key] || [];
              for (const m of planeMeasures){
                const x1 = dx + m.start.x * scale, y1 = dy + m.start.y * scale;
                const x2 = dx + m.end.x * scale, y2 = dy + m.end.y * scale;
                ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
                if (m.label){ ctx.font='12px monospace'; ctx.fillText(m.label, x2 + 6, y2 - 6); }
              }
              // Draft line if belongs to this plane
              if (measureDraft && measureDraft.plane === reg.key && measureDraft.start && measureDraft.end){
                const x1 = dx + measureDraft.start.x * scale, y1 = dy + measureDraft.start.y * scale;
                const x2 = dx + measureDraft.end.x * scale, y2 = dy + measureDraft.end.y * scale;
                ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
              }
              ctx.restore();
              // Draw HU ellipse overlay if belongs to this plane
              if (huEllipse && huEllipse.mode==='mpr' && huEllipse.plane===reg.key){
                drawEllipseOverlay(reg.key);
              }
              // Draw linked crosshair overlay for this plane (only if enabled)
              if (crosshair) { drawMprCrosshairOverlay(reg.key, dx, dy, scale, im.width, im.height); }
            }
            // Fetch updated slice without blocking draw
            (async ()=>{
              try {
                const img = await getMprImage(currentSeries.id, reg.key, mprScroll[reg.key] || 0);
                mprImgs[reg.key] = img; requestAnimationFrame(()=>draw());
              } catch(e){}
            })();
          }
          document.getElementById('overlay').innerHTML = `MPR | WW: ${Math.round(ww)}<br>WL: ${Math.round(wl)}`;
          document.getElementById('zoominfo').textContent = `MPR`;
          return;
        } catch(e){ /* fallback to normal draw below */ }
      }
      if (reconMode && reconImgs.length){
        try {
          ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
          if (reconMode === 'mip' || reconMode === 'bone'){
            // Draw 3-plane grid similar to MPR using the three recon previews
            const imgs = [];
            for (let i=0;i<3;i++){ if (reconImgs[i]) { try { imgs[i] = await loadImage(reconImgs[i]); } catch(e){ imgs[i] = null; } } }
            const halfW = Math.floor(canvas.width/2), halfH = Math.floor(canvas.height/2);
            const regions = [
              { x: 0, y: 0, w: halfW, h: halfH, key: 'sagittal', im: imgs[1] },
              { x: halfW, y: 0, w: canvas.width - halfW, h: halfH, key: 'coronal', im: imgs[2] },
              { x: 0, y: halfH, w: halfW, h: canvas.height - halfH, key: 'axial', im: imgs[0] },
              { x: halfW, y: halfH, w: canvas.width - halfW, h: canvas.height - halfH, key: 'empty', im: null },
            ];
            // Crosshair dividing lines
            ctx.save(); ctx.strokeStyle = 'rgba(0,255,255,0.8)'; ctx.beginPath(); ctx.moveTo(halfW, 0); ctx.lineTo(halfW, canvas.height); ctx.moveTo(0, halfH); ctx.lineTo(canvas.width, halfH); ctx.stroke(); ctx.restore();
            for (const reg of regions){
              if (!reg.im) continue;
              const im = reg.im;
              const scale = Math.min(reg.w / im.width, reg.h / im.height);
              const dw = im.width * scale, dh = im.height * scale;
              const dx = reg.x + (reg.w - dw)/2 + panOffset.x; const dy = reg.y + (reg.h - dh)/2 + panOffset.y;
              ctx.imageSmoothingEnabled = false;
              ctx.drawImage(im, dx, dy, dw, dh);
              // Label
              ctx.save(); ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(dx + 8, dy + 8, 150, 22); ctx.fillStyle = '#0ff'; ctx.font = '12px monospace'; ctx.fillText(`${reg.key.toUpperCase()}`, dx + 12, dy + 24); ctx.restore();
            }
            document.getElementById('overlay').innerHTML = `${reconMode.toUpperCase()} | 3-Plane`;
            document.getElementById('zoominfo').textContent = `${reconMode.toUpperCase()}`;
            return;
          } else {
            const im = await loadImage(reconImgs[reconIndex]);
            const scale = Math.min(canvas.width / im.width, canvas.height / im.height) * zoom;
            const dw = im.width * scale, dh = im.height * scale;
            const dx = (canvas.width - dw)/2 + panOffset.x; const dy = (canvas.height - dh)/2 + panOffset.y;
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(im, dx, dy, dw, dh);
            lastVp = { x: dx, y: dy, scale: scale, imgW: im.width, imgH: im.height };
            document.getElementById('overlay').innerHTML = `${reconMode.toUpperCase()} | View ${reconIndex+1}/${reconImgs.length}`;
            document.getElementById('zoominfo').textContent = `Zoom: ${Math.round(zoom*100)}%`;
            return;
          }
        } catch(e){}
      }
      try {
        const htmlImg = await getImageForIndex(index);
        const vp = getViewportPlacement(htmlImg.width, htmlImg.height);
        ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
                 if (ctx.imageSmoothingEnabled !== false) ctx.imageSmoothingEnabled = false;
         ctx.drawImage(htmlImg, vp.x, vp.y, vp.w, vp.h);
        lastVp = { x: vp.x, y: vp.y, scale: vp.scale, imgW: htmlImg.width, imgH: htmlImg.height };
        drawOverlays(vp);
        if (huEllipse && huEllipse.mode==='series') drawEllipseOverlay();
        // Spyglass lens on top
        if (spyglass.active && spyglass.isPress && lastVp){
          ctx.save();
          const r = Math.max(20, spyglass.radius);
          // Clip circle
          ctx.beginPath(); ctx.arc(spyglass.cx, spyglass.cy, r, 0, Math.PI*2); ctx.clip();
          // Compute anchor image coords under cursor
          const imgPt = canvasToImageCoords(lastVp, spyglass.cx, spyglass.cy);
          const factor = Math.max(1.2, spyglass.factor);
          const scale2 = lastVp.scale * factor;
          const dw2 = lastVp.imgW * scale2, dh2 = lastVp.imgH * scale2;
          const dx2 = spyglass.cx - (imgPt.x * scale2);
          const dy2 = spyglass.cy - (imgPt.y * scale2);
          ctx.imageSmoothingEnabled = false;
          ctx.drawImage(htmlImg, dx2, dy2, dw2, dh2);
          if (spyglass.invert){
            // Invert only inside lens
            const imgData = ctx.getImageData(spyglass.cx - r, spyglass.cy - r, r*2, r*2);
            const d = imgData.data; for (let i=0;i<d.length;i+=4){ d[i]=255-d[i]; d[i+1]=255-d[i+1]; d[i+2]=255-d[i+2]; }
            ctx.putImageData(imgData, spyglass.cx - r, spyglass.cy - r);
          }
          ctx.restore();
          // Lens ring and info
          ctx.save(); ctx.strokeStyle = '#0ff'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(spyglass.cx, spyglass.cy, r, 0, Math.PI*2); ctx.stroke(); ctx.restore();
          document.getElementById('overlay').innerHTML = `WW: ${Math.round(ww)}<br>WL: ${Math.round(wl)}<br>Slice: ${index+1}/${images.length}<br>Spyglass x:${Math.round(imgPt.x)} y:${Math.round(imgPt.y)} mag:${factor.toFixed(1)}x`;
        }
        if (showTagsOverlay && currentImageTags){
          const lines = [];
          const t = currentImageTags;
          if (t.patient_name) lines.push(`Patient: ${t.patient_name}`);
          if (t.study_date) lines.push(`Study: ${t.study_date}`);
          if (t.series_number !== undefined) lines.push(`Series#: ${t.series_number}`);
          if (images[index] && images[index].instance_number !== undefined) lines.push(`Instance#: ${images[index].instance_number}`);
          if (t.slice_thickness) lines.push(`Slice Thk: ${t.slice_thickness}`);
          if (t.pixel_spacing) lines.push(`Pix Spacing: ${t.pixel_spacing}`);
          ctx.save();
          ctx.fillStyle = 'rgba(0,0,0,0.6)';
          ctx.fillRect(canvas.width - 260, 12, 248, lines.length*16 + 10);
          ctx.fillStyle = '#ddd'; ctx.font = '12px monospace';
          lines.forEach((ln, i)=> ctx.fillText(ln, canvas.width - 250, 28 + i*16));
          ctx.restore();
        }
        document.getElementById('overlay').innerHTML = `WW: ${Math.round(ww)}<br>WL: ${Math.round(wl)}<br>Slice: ${index+1}/${images.length}`;
        document.getElementById('zoominfo').textContent = `Zoom: ${Math.round(zoom*100)}%`;
        // Opportunistically prefetch neighbors
        prefetchAround(index, 3);
      } catch (e) {
        await fallbackToDesktop();
      }
    }

    function drawMprCrosshairOverlay(planeKey, dx, dy, scale, imgW, imgH){
      if (mprCross.x === null || mprCross.y === null || mprCross.z === null) return;
      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,0,0.9)';
      ctx.lineWidth = 1;
      if (planeKey === 'axial'){
        const cx = dx + mprCross.x * scale;
        const cy = dy + mprCross.y * scale;
        ctx.beginPath();
        ctx.moveTo(cx, dy); ctx.lineTo(cx, dy + imgH * scale);
        ctx.moveTo(dx, cy); ctx.lineTo(dx + imgW * scale, cy);
        ctx.stroke();
      } else if (planeKey === 'sagittal'){
        // sagittal image axes: x=height(y), y=depth(z)
        const cx = dx + mprCross.y * scale; // height index across width
        const cy = dy + mprCross.z * scale; // depth index across height
        ctx.beginPath();
        ctx.moveTo(cx, dy); ctx.lineTo(cx, dy + imgH * scale);
        ctx.moveTo(dx, cy); ctx.lineTo(dx + imgW * scale, cy);
        ctx.stroke();
      } else if (planeKey === 'coronal'){
        // coronal image axes: x=width(x), y=depth(z)
        const cx = dx + mprCross.x * scale;
        const cy = dy + mprCross.z * scale;
        ctx.beginPath();
        ctx.moveTo(cx, dy); ctx.lineTo(cx, dy + imgH * scale);
        ctx.moveTo(dx, cy); ctx.lineTo(dx + imgW * scale, cy);
        ctx.stroke();
      }
      ctx.restore();
    }

    function drawOverlays(vp){
      // Measurements (draft first)
      ctx.save();
      ctx.strokeStyle = 'yellow';
      ctx.fillStyle = 'yellow';
      ctx.lineWidth = 2;
      const toCanvas = (p)=>({
        x: vp.x + p.x * vp.scale,
        y: vp.y + p.y * vp.scale,
      });
      const drawLine = (a,b)=>{
        const A = toCanvas(a), B = toCanvas(b);
        ctx.beginPath(); ctx.moveTo(A.x, A.y); ctx.lineTo(B.x, B.y); ctx.stroke();
      };
      const drawText = (p, text)=>{
        const P = toCanvas(p);
        ctx.font = '12px monospace';
        ctx.fillStyle = 'yellow';
        ctx.fillText(text, P.x + 6, P.y - 6);
      };
      if (measureDraft && measureDraft.start && measureDraft.end){
        drawLine(measureDraft.start, measureDraft.end);
      }
      measurements.forEach(m=>{ drawLine(m.start, m.end); if (m.label) drawText(m.end, m.label); });
      // Annotations
      annotations.forEach(a=>{ drawText(a.pos, a.text); });
      // Crosshair
      if (crosshair){
        ctx.strokeStyle = 'rgba(0,255,255,0.8)';
        ctx.beginPath();
        ctx.moveTo(canvas.width/2, 0); ctx.lineTo(canvas.width/2, canvas.height);
        ctx.moveTo(0, canvas.height/2); ctx.lineTo(canvas.width, canvas.height/2);
        ctx.stroke();
      }
      ctx.restore();
    }

    function drawEllipseOverlay(planeKey){
      ctx.save();
      ctx.strokeStyle = '#00ff88';
      ctx.lineWidth = 2;
      let mapping;
      if (huEllipse && huEllipse.mode==='mpr'){
        mapping = mprRegionVps[planeKey||huEllipse.plane];
      } else {
        mapping = lastVp;
      }
      if (!mapping) { ctx.restore(); return; }
      const { x, y, scale } = mapping;
      const cx = x + huEllipse.cx * scale;
      const cy = y + huEllipse.cy * scale;
      const rx = huEllipse.rx * scale;
      const ry = huEllipse.ry * scale;
      ctx.beginPath();
      ctx.ellipse(cx, cy, Math.abs(rx), Math.abs(ry), 0, 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }

    function canvasToImageCoords(vp, cx, cy){
      const x = (cx - vp.x) / vp.scale;
      const y = (cy - vp.y) / vp.scale;
      return { x, y };
    }

    function imageDistance(a, b){
      const dx = b.x - a.x, dy = b.y - a.y;
      const px = Math.sqrt(dx*dx + dy*dy);
      const spacing = parsePixelSpacing(currentSeries && currentSeries.pixel_spacing);
      if (spacing && spacing.length >= 2 && isFinite(spacing[0]) && isFinite(spacing[1])){
        const mm = Math.sqrt((dx*spacing[0])**2 + (dy*spacing[1])**2);
        const value = (measureUnit === 'cm') ? (mm/10.0) : mm;
        const unit = (measureUnit === 'cm') ? 'cm' : 'mm';
        return { px, mm, value, unit };
      }
      return { px, mm: null, value: px, unit: 'px' };
    }

    function mprImageDistance(planeKey, a, b){
      const dx = b.x - a.x, dy = b.y - a.y;
      const px = Math.sqrt(dx*dx + dy*dy);
      const ps = parsePixelSpacing(currentSeries && currentSeries.pixel_spacing) || [1,1];
      const st = (currentSeries && +currentSeries.slice_thickness) || 1.0;
      let sx = 1.0, sy = 1.0;
      if (planeKey === 'axial') { sx = ps[0]; sy = ps[1]; }
      else if (planeKey === 'sagittal') { sx = ps[0]; sy = st; }
      else if (planeKey === 'coronal') { sx = ps[1]; sy = st; }
      const mm = Math.sqrt((dx*sx)**2 + (dy*sy)**2);
      const value = (measureUnit === 'cm') ? (mm/10.0) : mm;
      const unit = (measureUnit === 'cm') ? 'cm' : 'mm';
      return { px, mm, value, unit };
    }

    async function saveMeasurementToServer(m){
      const imageId = getCurrentImageId();
      if (!imageId) return;
      const dist = imageDistance(m.start, m.end);
      const payload = {
        image_id: imageId,
        type: 'distance',
        points: [m.start, m.end],
        value: (dist.mm ? (measureUnit==='cm' ? (dist.mm/10.0) : dist.mm) : dist.px),
        unit: (dist.mm ? measureUnit : 'px'),
        notes: ''
      };
      try {
        const r = await fetch('/viewer/measurements/save/', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
        const j = await r.json();
        if (j && j.success){
          if (dist.mm){
            const mm = dist.mm; const cm = mm/10.0;
            m.label = (measureUnit==='cm') ? `${cm.toFixed(2)} cm` : `${mm.toFixed(2)} mm`;
          } else { m.label = `${dist.px.toFixed(1)} px`; }
        }
      } catch(e){}
    }

    async function saveAnnotationToServer(p, text){
      const imageId = getCurrentImageId();
      if (!imageId) return;
      try {
        await fetch('/viewer/annotations/save/', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ image_id: imageId, position_x: p.x, position_y: p.y, text }) });
      } catch(e){}
    }

    async function loadOverlaysForCurrentImage(){
      const reqId = ++overlayRequestId;
      const imageId = getCurrentImageId();
      if (!imageId) return;
      const tasks = [];
      if (imageIdToMeasurements.has(imageId)) {
        measurements = imageIdToMeasurements.get(imageId);
      } else {
        tasks.push(
          (async ()=>{
            try {
              const r = await fetch(`/viewer/measurements/${imageId}/`); const j = await r.json();
              measurements = (j.measurements||[]).map(m=>({ start: m.points[0], end: m.points[1], label: m.unit==='mm' ? `${(+m.value).toFixed(2)} mm` : `${(+m.value).toFixed(1)} px` }));
              imageIdToMeasurements.set(imageId, measurements);
            } catch(e){ measurements = []; }
          })()
        );
      }
      if (imageIdToAnnotations.has(imageId)) {
        annotations = imageIdToAnnotations.get(imageId);
      } else {
        tasks.push(
          (async ()=>{
            try {
              const r = await fetch(`/viewer/annotations/${imageId}/`); const j = await r.json();
              annotations = (j.annotations||[]).map(a=>({ pos: {x:a.position_x, y:a.position_y}, text: a.text }));
              imageIdToAnnotations.set(imageId, annotations);
            } catch(e){ annotations = []; }
          })()
        );
      }
      if (showTagsOverlay){
        tasks.push(
          (async ()=>{
            try {
              const r = await fetch(`/viewer/api/image/${imageId}/data/`); const j = await r.json();
              currentImageTags = {
                patient_name: j.patient_name || j.image_info?.patient_name,
                study_date: j.study_date || j.image_info?.study_date,
                series_number: j.series?.series_number ?? j.series_number,
                slice_thickness: j.series?.slice_thickness ?? j.slice_thickness,
                pixel_spacing: j.series?.pixel_spacing ?? j.pixel_spacing
              };
            } catch(e){ currentImageTags = null; }
          })()
        );
      } else {
        currentImageTags = null;
      }
      if (tasks.length) { try { await Promise.all(tasks); } catch(e){} }
      // If a newer overlay request superseded this one or image changed, skip applying
      if (reqId !== overlayRequestId || imageId !== getCurrentImageId()) return;
      renderMeasurementsList();
      requestDraw();
    }

    function renderMeasurementsList(){
      measurementsList.innerHTML = '';
      measurements.forEach((m, i)=>{
        const li = document.createElement('li');
        li.textContent = `Measurement ${i+1}: ${m.label||''}`;
        measurementsList.appendChild(li);
      });
    }

    // UI wiring
    seriesSelect.addEventListener('change', e=>{ if(e.target.value) loadSeries(e.target.value); });
    wwSlider.addEventListener('input', e=>{ ww = +e.target.value; document.getElementById('wwVal').textContent = ww; imageCache.clear(); mprImageCache.clear(); mprImgs = { axial:null, sagittal:null, coronal:null }; requestDraw(); });
    wlSlider.addEventListener('input', e=>{ wl = +e.target.value; document.getElementById('wlVal').textContent = wl; imageCache.clear(); mprImageCache.clear(); mprImgs = { axial:null, sagittal:null, coronal:null }; requestDraw(); });
    sliceSlider.addEventListener('input', e=>{ index = +e.target.value; document.getElementById('sliceVal').textContent = index+1; requestDraw(); debouncedLoadOverlaysForCurrentImage(); prefetchAround(index, 3); });
    zoomSlider.addEventListener('input', e=>{ zoom = (+e.target.value)/100; document.getElementById('zoomVal').textContent = `${e.target.value}%`; requestDraw(); });
    document.querySelectorAll('[data-preset]').forEach(btn=>btn.addEventListener('click', ()=>{
      const p = btn.getAttribute('data-preset');
      const map = { lung:{ww:1500,wl:-600}, bone:{ww:2000,wl:300}, soft:{ww:400,wl:40}, brain:{ww:100,wl:50} };
      if (map[p]){ ww = map[p].ww; wl = map[p].wl; wwSlider.value = ww; wlSlider.value = wl; document.getElementById('wwVal').textContent = ww; document.getElementById('wlVal').textContent = wl; imageCache.clear(); mprImageCache.clear(); mprImgs = { axial:null, sagittal:null, coronal:null }; requestDraw(); }
    }));
    document.querySelectorAll('.tool').forEach(t=>t.addEventListener('click', ()=>{
      const tool = t.getAttribute('data-tool');
      document.querySelectorAll('.tool').forEach(x=>x.classList.remove('active')); t.classList.add('active');
      if (tool === 'invert'){ inverted = !inverted; imageCache.clear(); mprImageCache.clear(); mprImgs = { axial:null, sagittal:null, coronal:null }; requestDraw(); return; }
      if (tool === 'reset'){ zoom = 1.0; panOffset = {x:0,y:0}; zoomSlider.value = 100; document.getElementById('zoomVal').textContent = '100%'; requestDraw(); return; }
      if (tool === 'fit'){ panOffset = {x:0,y:0}; zoom = 1.0; zoomSlider.value = 100; document.getElementById('zoomVal').textContent = '100%'; requestDraw(); return; }
      if (tool === 'one'){
        if (lastVp){
          const baseFit = Math.min(canvas.width / lastVp.imgW, canvas.height / lastVp.imgH);
          zoom = 1 / baseFit; zoomSlider.value = Math.min(500, Math.max(25, Math.round(zoom*100))); document.getElementById('zoomVal').textContent = `${Math.round(zoom*100)}%`; panOffset={x:0,y:0}; requestDraw();
        }
        return;
      }
      if (tool === 'cine'){
        cineActive = !cineActive;
        if (cineActive){
          if (cineTimer) clearInterval(cineTimer);
          cineTimer = setInterval(()=>{
            if (!images.length) return; index = (index + 1) % images.length; sliceSlider.value = index; document.getElementById('sliceVal').textContent = index+1; requestDraw(); debouncedLoadOverlaysForCurrentImage();
          }, Math.max(30, Math.round(1000/cineFps)));
        } else { if (cineTimer) { clearInterval(cineTimer); cineTimer = null; } }
        return;
      }
      if (tool === 'spyglass'){ spyglass.active = !spyglass.active; requestDraw(); return; }
      if (tool === 'align-center'){ panOffset = {x:0,y:0}; requestDraw(); return; }
      if (tool === 'reload'){ ww = defaultWw; wl = defaultWl; inverted = false; panOffset={x:0,y:0}; zoom=1.0; wwSlider.value = Math.round(ww); wlSlider.value = Math.round(wl); document.getElementById('wwVal').textContent = Math.round(ww); document.getElementById('wlVal').textContent = Math.round(wl); zoomSlider.value=100; document.getElementById('zoomVal').textContent='100%'; imageCache.clear(); mprImageCache.clear(); mprImgs = { axial:null, sagittal:null, coronal:null }; requestDraw(); return; }
      if (tool === 'ai'){ console.info('AI analysis: stub'); return; }
      if (tool === 'crosshair'){ if (activeTool === 'crosshair'){ crosshair = false; activeTool = 'window'; } else { activeTool = 'crosshair'; crosshair = true; } requestDraw(); return; }
      if (tool === 'hu'){ showHuProbe = true; huEllipse = null; requestDraw(); return; }
             if (tool === 'measure') { showHuProbe = false; if (mprMode) document.getElementById('mprMeasurePanel').style.display=''; }
      // remove old inline MPR toggle from tool button; handled by 3D dropdown now
             if (tool === 'mpr'){
         return; // no-op
       }
       if (mprMode){
         // In MPR, toggle measure panel visibility based on tool
         document.getElementById('mprMeasurePanel').style.display = (tool === 'measure') ? '' : document.getElementById('mprMeasurePanel').style.display;
         return;
       }
       activeTool = tool;
     }));

    // Mouse interactions on viewport
    const viewport = document.getElementById('viewport');
    viewport.addEventListener('mousedown', (e)=>{
      isDragging = true; dragStart = { x: e.offsetX, y: e.offsetY };
      // Start measurement draft
      if (activeTool === 'measure'){
        if (mprMode){
          const halfW = Math.floor(canvas.width/2), halfH = Math.floor(canvas.height/2);
          const mx = e.offsetX, my = e.offsetY;
          let plane = null; if (mx < halfW && my < halfH) plane='sagittal'; else if (mx>=halfW && my<halfH) plane='coronal'; else if (mx<halfW && my>=halfH) plane='axial';
          if (mprFullPlane) plane = mprFullPlane;
          if (mprMeasurePlaneMode !== 'auto') plane = mprMeasurePlaneMode;
          if (plane && mprRegionVps[plane]){
            const vpR = mprRegionVps[plane];
            // Ignore clicks outside the image bounds within region
            if (mx < vpR.x || mx > vpR.x + vpR.imgW * vpR.scale || my < vpR.y || my > vpR.y + vpR.imgH * vpR.scale) {
              return;
            }
            const imgPt = canvasToImageCoords(vpR, e.offsetX, e.offsetY);
            measureDraft = { plane, start: imgPt, end: imgPt };
          }
        } else {
          const vp2 = lastVp || { x:0, y:0, scale:1 };
          measureDraft = { start: canvasToImageCoords(vp2, e.offsetX, e.offsetY), end: canvasToImageCoords(vp2, e.offsetX, e.offsetY) };
        }
      }
      if (mprMode && activeTool === 'crosshair'){
        const halfW = Math.floor(canvas.width/2), halfH = Math.floor(canvas.height/2);
        const mx = e.offsetX, my = e.offsetY;
        let plane = null; if (mx < halfW && my < halfH) plane='sagittal'; else if (mx>=halfW && my<halfH) plane='coronal'; else if (mx<halfW && my>=halfH) plane='axial';
        if (plane && mprRegionVps[plane]){
          const vpR = mprRegionVps[plane];
          // Ignore clicks outside the image bounds within region
          if (mx < vpR.x || mx > vpR.x + vpR.imgW * vpR.scale || my < vpR.y || my > vpR.y + vpR.imgH * vpR.scale) {
            return;
          }
          const imgPt = canvasToImageCoords(vpR, mx, my);
          // Update crosshair global coordinates and plane slices
          if (plane === 'axial'){
            mprCross.x = Math.round(imgPt.x);
            mprCross.y = Math.round(imgPt.y);
            // Update orthogonal planes to intersect this point
            mprScroll.sagittal = Math.max(0, Math.min((mprScroll.counts.sagittal||1)-1, mprCross.x));
            mprScroll.coronal = Math.max(0, Math.min((mprScroll.counts.coronal||1)-1, mprCross.y));
          } else if (plane === 'sagittal'){
            // sagittal image: x->height(y), y->depth(z)
            mprCross.y = Math.round(imgPt.x);
            mprCross.z = Math.round(imgPt.y);
            mprScroll.axial = Math.max(0, Math.min((mprScroll.counts.axial||1)-1, mprCross.z));
            // coronal slice corresponds to height index
            mprScroll.coronal = Math.max(0, Math.min((mprScroll.counts.coronal||1)-1, mprCross.y));
          } else if (plane === 'coronal'){
            // coronal image: x->width(x), y->depth(z)
            mprCross.x = Math.round(imgPt.x);
            mprCross.z = Math.round(imgPt.y);
            mprScroll.axial = Math.max(0, Math.min((mprScroll.counts.axial||1)-1, mprCross.z));
            // sagittal slice corresponds to width index
            mprScroll.sagittal = Math.max(0, Math.min((mprScroll.counts.sagittal||1)-1, mprCross.x));
          }
          draw();
        }
      }
      if (showHuProbe){
        if (mprMode){
          // determine plane by quadrant
          const halfW = Math.floor(canvas.width/2), halfH = Math.floor(canvas.height/2);
          const mx = e.offsetX, my = e.offsetY;
          let plane = null; if (mx < halfW && my < halfH) plane='sagittal'; else if (mx>=halfW && my<halfH) plane='coronal'; else if (mx<halfW && my>=halfH) plane='axial';
          if (plane && mprRegionVps[plane]){
            const vpR = mprRegionVps[plane];
            const imgPt = canvasToImageCoords(vpR, e.offsetX, e.offsetY);
            huEllipse = { mode:'mpr', plane, slice: (mprScroll[plane]||0), cx: imgPt.x, cy: imgPt.y, rx: 1, ry: 1 };
          }
        } else if (lastVp){
          const imgPt = canvasToImageCoords(lastVp, e.offsetX, e.offsetY);
          huEllipse = { mode:'series', cx: imgPt.x, cy: imgPt.y, rx: 1, ry: 1 };
        }
        draw();
      }
      if (spyglass.active){ spyglass.isPress = true; spyglass.cx = e.offsetX; spyglass.cy = e.offsetY; draw(); }
    });
    viewport.addEventListener('mousemove', async (e)=>{
      if (!isDragging) { if (spyglass.active && spyglass.isPress){ spyglass.cx = e.offsetX; spyglass.cy = e.offsetY; requestDraw(); } return; }
      const vp = lastVp || { x:0, y:0, scale:1 };
      if (activeTool === 'window'){
        const dx = e.offsetX - dragStart.x; const dy = e.offsetY - dragStart.y; dragStart = { x: e.offsetX, y: e.offsetY };
        ww = Math.max(1, ww + dx*4); wl = wl + dy*2; wwSlider.value = Math.round(ww); wlSlider.value = Math.round(wl); document.getElementById('wwVal').textContent = Math.round(ww); document.getElementById('wlVal').textContent = Math.round(wl); requestDraw();
      } else if (activeTool === 'pan'){
        panOffset.x += (e.offsetX - dragStart.x); panOffset.y += (e.offsetY - dragStart.y); dragStart = { x: e.offsetX, y: e.offsetY }; requestDraw();
      } else if (activeTool === 'measure' && measureDraft){
        if (mprMode && measureDraft.plane && mprRegionVps[measureDraft.plane]){
          const vpR = mprRegionVps[measureDraft.plane];
          measureDraft.end = canvasToImageCoords(vpR, e.offsetX, e.offsetY);
        } else {
          measureDraft.end = canvasToImageCoords(vp, e.offsetX, e.offsetY);
        }
        requestDraw();
      } else if (activeTool === 'annotate'){
        // no-op while dragging
      } else if (activeTool === 'zoom'){
        const dy = e.offsetY - dragStart.y; dragStart = { x: e.offsetX, y: e.offsetY }; const factor = dy<0 ? 1.05 : 0.95; zoom = Math.min(5.0, Math.max(0.25, zoom*factor)); zoomSlider.value = Math.round(zoom*100); document.getElementById('zoomVal').textContent = `${Math.round(zoom*100)}%`; requestDraw();
      } else if (mprMode && activeTool === 'crosshair'){
        const halfW = Math.floor(canvas.width/2), halfH = Math.floor(canvas.height/2);
        const mx = e.offsetX, my = e.offsetY;
        let plane = null; if (mx < halfW && my < halfH) plane='sagittal'; else if (mx>=halfW && my<halfH) plane='coronal'; else if (mx<halfW && my>=halfH) plane='axial';
        if (mprFullPlane) plane = mprFullPlane;
        if (plane && mprRegionVps[plane]){
          const vpR = mprRegionVps[plane];
          // Ignore clicks outside the image bounds within region
          if (mx < vpR.x || mx > vpR.x + vpR.imgW * vpR.scale || my < vpR.y || my > vpR.y + vpR.imgH * vpR.scale) {
            return;
          }
          const imgPt = canvasToImageCoords(vpR, mx, my);
          // Update crosshair global coordinates and plane slices
          if (plane === 'axial'){
            mprCross.x = Math.round(imgPt.x);
            mprCross.y = Math.round(imgPt.y);
            // Update orthogonal planes to intersect this point
            mprScroll.sagittal = Math.max(0, Math.min((mprScroll.counts.sagittal||1)-1, mprCross.x));
            mprScroll.coronal = Math.max(0, Math.min((mprScroll.counts.coronal||1)-1, mprCross.y));
          } else if (plane === 'sagittal'){
            // sagittal image: x->height(y), y->depth(z)
            mprCross.y = Math.round(imgPt.x);
            mprCross.z = Math.round(imgPt.y);
            mprScroll.axial = Math.max(0, Math.min((mprScroll.counts.axial||1)-1, mprCross.z));
            // coronal slice corresponds to height index
            mprScroll.coronal = Math.max(0, Math.min((mprScroll.counts.coronal||1)-1, mprCross.y));
          } else if (plane === 'coronal'){
            // coronal image: x->width(x), y->depth(z)
            mprCross.x = Math.round(imgPt.x);
            mprCross.z = Math.round(imgPt.y);
            mprScroll.axial = Math.max(0, Math.min((mprScroll.counts.axial||1)-1, mprCross.z));
            // sagittal slice corresponds to width index
            mprScroll.sagittal = Math.max(0, Math.min((mprScroll.counts.sagittal||1)-1, mprCross.x));
          }
          requestDraw();
        }
      } else if (showHuProbe && huEllipse){
        if (huEllipse.mode==='mpr' && mprRegionVps[huEllipse.plane]){
          const vpR = mprRegionVps[huEllipse.plane];
          const cur = canvasToImageCoords(vpR, e.offsetX, e.offsetY);
          huEllipse.rx = Math.abs(cur.x - huEllipse.cx);
          huEllipse.ry = Math.abs(cur.y - huEllipse.cy);
          requestDraw();
        } else if (lastVp && huEllipse.mode==='series'){
          const cur = canvasToImageCoords(lastVp, e.offsetX, e.offsetY);
          huEllipse.rx = Math.abs(cur.x - huEllipse.cx);
          huEllipse.ry = Math.abs(cur.y - huEllipse.cy);
          requestDraw();
        }
      }
    });
    // HU probe on mousemove in MPR when enabled
    viewport.addEventListener('mousemove', async (e)=>{
      if (!mprMode || !showHuProbe || (huEllipse && (huEllipse.rx>1 || huEllipse.ry>1))) return;
      // Determine which plane region the mouse is in
      const halfW = Math.floor(canvas.width/2), halfH = Math.floor(canvas.height/2);
      const mx = e.offsetX, my = e.offsetY;
      let plane = null; if (mx < halfW && my < halfH) plane='sagittal'; else if (mx>=halfW && my<halfH) plane='coronal'; else if (mx<halfW && my>=halfH) plane='axial';
      if (mprFullPlane) plane = mprFullPlane;
      if (!plane || !mprRegionVps[plane]) return;
      try {
        const vpR = mprRegionVps[plane];
        const imgPt = canvasToImageCoords(vpR, mx, my);
        const px = Math.max(0, Math.min(vpR.imgW-1, imgPt.x));
        const py = Math.max(0, Math.min(vpR.imgH-1, imgPt.y));
        // Query HU from backend
        const q = new URLSearchParams();
        q.set('mode','mpr'); q.set('series_id', currentSeries.id); q.set('plane', plane);
        q.set('slice', mprScroll[plane]||0); q.set('x', Math.floor(px)); q.set('y', Math.floor(py));
        try {
          const resp = await fetch(`/viewer/api/hu/?${q.toString()}`);
          const j = await resp.json();
          if (j && typeof j.hu === 'number'){
            document.getElementById('overlay').innerHTML = `HU (${plane}): ${j.hu} @ x:${Math.floor(px)} y:${Math.floor(py)} slice:${(mprScroll[plane]||0)+1}/${mprScroll.counts[plane]||0}`;
          }
        } catch(e){}
      } catch(e){}
    });
    viewport.addEventListener('mouseup', async (e)=>{
      if (!isDragging) return; isDragging = false;
      const vp = lastVp || { x:0, y:0, scale:1 };
      if (activeTool === 'measure' && measureDraft){
        if (mprMode && measureDraft.plane && mprRegionVps[measureDraft.plane]){
          const vpR = mprRegionVps[measureDraft.plane];
          measureDraft.end = canvasToImageCoords(vpR, e.offsetX, e.offsetY);
          const plane = measureDraft.plane;
          const m = { plane, start: measureDraft.start, end: measureDraft.end };
          const dist = mprImageDistance(plane, m.start, m.end);
          if (dist.mm){
            const mm = dist.mm; const cm = mm/10.0;
            m.label = (measureUnit==='cm') ? `${cm.toFixed(2)} cm` : `${mm.toFixed(2)} mm`;
          } else { m.label = `${dist.px.toFixed(1)} px`; }
          mprMeasurements[plane].push(m);
          measureDraft = null; await draw();
        } else {
          measureDraft.end = canvasToImageCoords(vp, e.offsetX, e.offsetY);
          const m = { start: measureDraft.start, end: measureDraft.end };
          measureDraft = null; measurements.push(m); imageIdToMeasurements.set(getCurrentImageId(), measurements);
          await saveMeasurementToServer(m); renderMeasurementsList(); await draw();
        }
      } else if (activeTool === 'annotate'){
        const pos = canvasToImageCoords(vp, e.offsetX, e.offsetY);
        const text = '';
        if (text){ annotations.push({ pos, text }); imageIdToAnnotations.set(getCurrentImageId(), annotations); await saveAnnotationToServer(pos, text); await draw(); }
      } else if (showHuProbe && huEllipse){
        // Submit ROI to backend
        try {
          const qp = new URLSearchParams();
          qp.set('shape','ellipse');
          if (huEllipse.mode==='series'){
            qp.set('mode','series');
            qp.set('image_id', String(getCurrentImageId()));
          } else {
            qp.set('mode','mpr');
            qp.set('series_id', String(currentSeries.id));
            qp.set('plane', huEllipse.plane);
            qp.set('slice', String(huEllipse.slice||0));
          }
          qp.set('cx', Math.round(huEllipse.cx));
          qp.set('cy', Math.round(huEllipse.cy));
          qp.set('rx', Math.max(1, Math.round(huEllipse.rx)));
          qp.set('ry', Math.max(1, Math.round(huEllipse.ry)));
          const r = await fetch(`/viewer/api/hu/?${qp.toString()}`);
          const j = await r.json();
          if (j && j.stats){
            const s = j.stats; // mean, std, min, max, n
            document.getElementById('overlay').innerHTML = `HU ROI (ellipse): mean ${s.mean.toFixed(1)}, sd ${s.std.toFixed(1)}, min ${s.min.toFixed(0)}, max ${s.max.toFixed(0)} (n=${s.n})`;
          }
        } catch(e){}
        await draw();
      }
      if (spyglass.active){ spyglass.isPress = false; }
    });
    // Double-click enlarge/restore MPR plane
    viewport.addEventListener('dblclick', async (e)=>{
      if (!mprMode) return;
      if (mprFullPlane) { mprFullPlane = null; await draw(); return; }
      const halfW = Math.floor(canvas.width/2), halfH = Math.floor(canvas.height/2);
      const mx = e.offsetX, my = e.offsetY;
      let plane = null; if (mx < halfW && my < halfH) plane='sagittal'; else if (mx>=halfW && my<halfH) plane='coronal'; else if (mx<halfW && my>=halfH) plane='axial';
      if (plane) { mprFullPlane = plane; await draw(); }
    });

    // Mouse wheel slice/zoom
    document.getElementById('viewport').addEventListener('wheel', async (e)=>{
      e.preventDefault();
      if (spyglass.active && spyglass.isPress){
        const d = e.deltaY>0 ? -10 : 10; spyglass.radius = Math.max(20, Math.min(300, spyglass.radius + d)); requestDraw(); return;
      }
      if (reconMode && reconImgs.length){
        const d = e.deltaY>0 ? 1 : -1;
        reconIndex = Math.max(0, Math.min(reconImgs.length-1, reconIndex + d));
        requestDraw();
        return;
      }
      if (mprMode){
        // Determine which quadrant and scroll that plane
        const halfW = Math.floor(canvas.width/2), halfH = Math.floor(canvas.height/2);
        const mx = e.offsetX, my = e.offsetY; const d = e.deltaY>0 ? 1 : -1;
        let plane = null;
        if (mx < halfW && my < halfH) plane = 'sagittal';
        else if (mx >= halfW && my < halfH) plane = 'coronal';
        else if (mx < halfW && my >= halfH) plane = 'axial';
        else plane = null; // bottom-right empty
        if (mprFullPlane) plane = mprFullPlane;
        if (!plane) return;
        const count = (mprScroll.counts[plane]||1);
        const cur = (mprScroll[plane]||0);
        const ni = Math.max(0, Math.min(count-1, cur + d));
                 if (ni !== cur){
           mprScroll[plane] = ni;
           // keep crosshair in sync with the scrolled plane axis
           if (plane === 'axial') mprCross.z = ni; else if (plane === 'sagittal') mprCross.x = ni; else if (plane === 'coronal') mprCross.y = ni;
           prefetchMprSlices(plane, ni);
           await draw();
         }
        return;
      }
      if (e.ctrlKey){ const delta = e.deltaY>0?0.9:1.1; zoom = Math.max(0.1, Math.min(5.0, zoom*delta)); zoomSlider.value = Math.round(zoom*100); document.getElementById('zoomVal').textContent = `${Math.round(zoom*100)}%`; requestDraw(); }
      else { const d = e.deltaY>0?1:-1; const ni = Math.max(0, Math.min(images.length-1, index+d)); if (ni !== index){ index = ni; sliceSlider.value = index; document.getElementById('sliceVal').textContent = index+1; requestDraw(); debouncedLoadOverlaysForCurrentImage(); prefetchAround(index, 3); } }
    }, { passive:false });

    // Local DICOM upload
    btnLoadLocal.addEventListener('click', ()=> inputLocal.click());
    inputLocal.addEventListener('change', async (e)=>{
      try {
        const files = e.target.files ? Array.from(e.target.files) : [];
        if (!files.length) return;
        reconStatus.textContent = 'Uploading DICOM files...';
        const CHUNK_SIZE = 80;
        const MAX_PARALLEL = 2;
        const chunks = [];
        for (let i=0; i<files.length; i+=CHUNK_SIZE){ chunks.push(files.slice(i, i+CHUNK_SIZE)); }
        let current = 0; let lastStudyId = null; let errors = 0;
        async function uploadChunk(chunk){
          const form = new FormData();
          chunk.forEach(f=> form.append('dicom_files', f));
          const resp = await fetch('/viewer/upload/', { method:'POST', body: form });
          const data = await resp.json();
          if (!data.success){ errors++; return; }
          current += chunk.length;
          if (!lastStudyId && data.study_id) lastStudyId = data.study_id;
          reconStatus.textContent = `Uploading... ${current}/${files.length}`;
        }
        let idx = 0;
        const workers = Array.from({length: Math.min(MAX_PARALLEL, chunks.length)}).map(async ()=>{
          while (true){ const i = idx++; if (i >= chunks.length) break; await uploadChunk(chunks[i]); }
        });
        await Promise.all(workers);
        if (errors > 0 && current === 0) throw new Error('Upload failed');
        reconStatus.textContent = 'Upload complete. Loading study...';
        if (lastStudyId) { await loadStudy(lastStudyId); }
        reconStatus.textContent = '';
      } catch (err){
        reconStatus.textContent = `Error: ${err.message}`;
        await fallbackToDesktop();
      } finally {
        e.target.value = '';
      }
    });

    // Recon controls
    reconType.addEventListener('change', ()=>{
      const v = reconType.value; boneCtrl.style.display = v==='bone' ? '' : 'none';
    });
    boneSlider.addEventListener('input', e=> boneVal.textContent = e.target.value);

    // Extracted function so both dropdown and button can trigger
    async function generateReconstruction(kind){
      try {
        if (!currentSeries || !currentSeries.id){ console.warn('Select a series first'); return; }
        reconStatus.textContent = 'Generating...';
        reconMode = null; reconImgs = []; reconIndex = 0; panOffset = {x:0,y:0}; zoom = 1.0;
        const params = new URLSearchParams();
        params.set('window_width', ww);
        params.set('window_level', wl);
        params.set('inverted', inverted);
        let url = '';
        const type = kind || reconType.value;
        if (type === 'mpr') url = `/viewer/api/series/${currentSeries.id}/mpr/?${params.toString()}`;
        else if (type === 'mip') url = `/viewer/api/series/${currentSeries.id}/mip/?quality=high&${params.toString()}`;
        else { url = `/viewer/api/series/${currentSeries.id}/bone/?threshold=${boneSlider.value}&mesh=true&quality=high`; }
        const r = await fetch(url);
        const j = await r.json();
        if (j.error) throw new Error(j.error);
        if (j.mpr_views){ reconMode = 'mpr'; reconImgs = [j.mpr_views.axial, j.mpr_views.sagittal, j.mpr_views.coronal]; mprMode = true; document.getElementById('mprMeasurePanel').style.display=''; if (j.counts){ mprScroll.counts = j.counts; mprScroll.axial = Math.floor((j.counts.axial||0)/2); mprScroll.sagittal = Math.floor((j.counts.sagittal||0)/2); mprScroll.coronal = Math.floor((j.counts.coronal||0)/2); mprCross = { x: mprScroll.sagittal, y: mprScroll.coronal, z: mprScroll.axial }; prefetchMprSlices('axial', mprScroll.axial); prefetchMprSlices('sagittal', mprScroll.sagittal); prefetchMprSlices('coronal', mprScroll.coronal); } }
                 if (j.mip_views){ reconMode = 'mip'; reconImgs = [j.mip_views.axial, j.mip_views.sagittal, j.mip_views.coronal]; document.getElementById('mprMeasurePanel').style.display='none'; mprMode = true; mprFullPlane = null; mprScroll.counts = j.counts || mprScroll.counts; }
         if (j.bone_views){ reconMode = 'bone'; reconImgs = [j.bone_views.axial || j.bone_views.bone_axial_preview, j.bone_views.sagittal || j.bone_views.bone_sagittal_preview, j.bone_views.coronal || j.bone_views.bone_coronal_preview]; document.getElementById('mprMeasurePanel').style.display='none'; mprMode = true; mprFullPlane = null; if (j.mesh) showBone3D(j.mesh); }
         reconImgs = reconImgs.filter(Boolean);
         reconIndex = 0;
         await draw();
         reconStatus.textContent = 'Done'; setTimeout(()=> reconStatus.textContent = '', 1500);
       } catch (err){
         reconStatus.textContent = `Error: ${err.message}`;
         await fallbackToDesktop();
       }
     }
 
           btnGenerateRecon.addEventListener('click', ()=>{ generateReconstruction(); });

      // Worklist navigation that prefers returning to the original/mother worklist window
      function returnToWorklist(e){
        try {
          const targetUrl = '{% url 'worklist:dashboard' %}';
          if (window.opener && !window.opener.closed) {
            try { window.opener.location.href = targetUrl; } catch(err) {}
            window.close();
            return false;
          }
          if (window.top && window.top !== window){
            try { window.top.location.href = targetUrl; return false; } catch(err) {}
          }
          window.location.href = targetUrl;
          return false;
        } catch(_) { window.location.href = '{% url 'worklist:dashboard' %}'; return false; }
      }

    // Preload MPR mid-slices after series load to avoid UI stall on first click
    function warmupMpr(){
      if (!currentSeries || !currentSeries.id) return;
      const params = new URLSearchParams(); params.set('window_width', ww); params.set('window_level', wl); params.set('inverted', inverted);
      fetch(`/viewer/api/series/${currentSeries.id}/mpr/?${params.toString()}`)
        .then(r=>r.json())
        .then(j=>{ if (j && j.counts) { mprScroll.counts = j.counts; mprScroll.axial = Math.floor((j.counts.axial||0)/2); mprScroll.sagittal = Math.floor((j.counts.sagittal||0)/2); mprScroll.coronal = Math.floor((j.counts.coronal||0)/2); prefetchMprSlices('axial', mprScroll.axial); prefetchMprSlices('sagittal', mprScroll.sagittal); prefetchMprSlices('coronal', mprScroll.coronal);} })
        .catch(()=>{});
    }
 
     // 3D dropdown interactions
     btn3D.addEventListener('click', ()=>{
       menu3D.style.display = (menu3D.style.display === 'flex') ? 'none' : 'flex';
       if (menu3D.style.display === '' || menu3D.style.display === 'none') menu3D.style.display = 'flex';
     });
           menu3D.addEventListener('click', (e)=>{
        const btn = e.target.closest('button[data-recon]');
        if (!btn) return;
        const kind = btn.getAttribute('data-recon');
        menu3D.style.display = 'none';
        generateReconstruction(kind);
      });
     // Close dropdown when clicking outside
     document.addEventListener('click', (e)=>{
       if (!menu3D.contains(e.target) && e.target !== btn3D) menu3D.style.display = 'none';
     });
 
     // Clear measurements
     btnClearMeasurements.addEventListener('click', ()=>{
       if (mprMode){ mprMeasurements.axial = []; mprMeasurements.sagittal = []; mprMeasurements.coronal = []; draw(); }
       else { measurements = []; imageIdToMeasurements.set(getCurrentImageId(), measurements); renderMeasurementsList(); draw(); }
     });

     // Sorting
     sortSelect.addEventListener('change', async ()=>{
       if (!images || !images.length) return;
       const mode = sortSelect.value;
       if (mode === 'inst_desc') images.sort((a,b)=> (b.instance_number||0) - (a.instance_number||0));
       else images.sort((a,b)=> (a.instance_number||0) - (b.instance_number||0));
       index = 0; sliceSlider.max = Math.max(0, images.length - 1); sliceSlider.value = 0; document.getElementById('sliceVal').textContent = '1';
       await loadOverlaysForCurrentImage();
     });

     // Toggle tags overlay
     btnToggleTags.addEventListener('click', async ()=>{
       showTagsOverlay = !showTagsOverlay; await loadOverlaysForCurrentImage();
     });

     // Show DICOM modal
     btnShowDicom.addEventListener('click', async ()=>{
       try {
         const imageId = getCurrentImageId(); if (!imageId) return;
         const r = await fetch(`/viewer/api/image/${imageId}/data/`); const j = await r.json();
         dicomTagsPre.textContent = JSON.stringify(j, null, 2);
         dicomModal.style.display = 'flex';
       } catch(e){}
     });
     closeDicomModal.addEventListener('click', ()=>{ dicomModal.style.display = 'none'; });
     dicomModal.addEventListener('click', (e)=>{ if (e.target === dicomModal) dicomModal.style.display = 'none'; });

     // Capture canvas
     btnCapture.addEventListener('click', ()=>{
       try {
         const url = canvas.toDataURL('image/jpeg', 0.92);
         const a = document.createElement('a'); a.href = url; a.download = `dicom_capture_${Date.now()}.jpg`; document.body.appendChild(a); a.click(); document.body.removeChild(a);
       } catch(e){}
     });

    // Utils
    function loadImage(src){
      return new Promise((res, rej)=>{ const im = new Image(); im.decoding='async'; im.onload=()=>res(im); im.onerror=rej; im.src=src; });
    }
    function mprKey(seriesId, plane, sliceIndex, wwVal, wlVal, inv){
      return `${seriesId}|${plane}|${sliceIndex}|${Math.round(wwVal)}|${Math.round(wlVal)}|${inv?1:0}`;
    }
    async function getMprImage(seriesId, plane, sliceIndex){
      const key = mprKey(seriesId, plane, sliceIndex, ww, wl, inverted);
      if (mprImageCache.has(key)){
        const val = mprImageCache.get(key);
        return (typeof val?.then === 'function') ? await val : val;
      }
      const url = `/viewer/api/series/${seriesId}/mpr/?plane=${encodeURIComponent(plane)}&slice=${sliceIndex}&window_width=${Math.round(ww)}&window_level=${Math.round(wl)}&inverted=${inverted}`;
      const pending = fetch(url)
        .then(r=>{ if(!r.ok) throw new Error('mpr fetch failed'); return r.json(); })
        .then(j=>{ if(!j || !j.image) throw new Error('no mpr image'); return j.image; })
        .then(img=>{ mprImageCache.set(key, img); return img; })
        .catch(err=>{ mprImageCache.delete(key); throw err; });
      mprImageCache.set(key, pending);
      return await pending;
    }
    function prefetchMprSlices(plane, centerSlice, radius=3){
      if (!currentSeries || !mprScroll || !mprScroll.counts) return;
      const total = Math.max(0, (mprScroll.counts[plane]||0));
      if (!total) return;
      for (let o = -radius; o <= radius; o++){
        if (o === 0) continue;
        const s = centerSlice + o;
        if (s < 0 || s >= total) continue;
        const key = mprKey(currentSeries.id, plane, s, ww, wl, inverted);
        if (mprImageCache.has(key)) continue;
        // Fire-and-forget; cache will store promise/result
        getMprImage(currentSeries.id, plane, s).catch(()=>{});
      }
    }
    
    // 3D viewer for bone mesh
    let three = { renderer:null, scene:null, camera:null, controls:null };
    function disposeSceneObjects(){
      if (!three.scene) return;
      const toRemove = [];
      three.scene.traverse(obj=>{ if (obj.isMesh) {
        if (obj.geometry) obj.geometry.dispose();
        if (obj.material) {
          if (Array.isArray(obj.material)) obj.material.forEach(m=>m.dispose()); else obj.material.dispose();
        }
        toRemove.push(obj);
      }});
      toRemove.forEach(obj=> three.scene.remove(obj));
    }
    let threeAnimId = null;
    function showBone3D(meshData){
      try {
        const container = document.getElementById('threeContainer');
        const mount = document.getElementById('threeMount');
        container.style.display = 'block';
        // init three only once
        if (!three.renderer){
          three.renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer:false, powerPreference:'high-performance' });
          three.renderer.setSize(mount.clientWidth, mount.clientHeight);
          mount.appendChild(three.renderer.domElement);
          three.scene = new THREE.Scene();
          three.scene.background = new THREE.Color(0x000000);
          three.camera = new THREE.PerspectiveCamera(45, mount.clientWidth/mount.clientHeight, 0.1, 10000);
          three.camera.position.set(0, 0, 400);
          three.controls = new window.OrbitControls(three.camera, three.renderer.domElement);
          const light1 = new THREE.DirectionalLight(0xffffff, 1.0); light1.position.set(1,1,1); three.scene.add(light1);
          const light2 = new THREE.AmbientLight(0x444444); three.scene.add(light2);
          const onResize3D = ()=>{
            if (!three.renderer) return;
            three.renderer.setSize(mount.clientWidth, mount.clientHeight);
            three.camera.aspect = mount.clientWidth/mount.clientHeight; three.camera.updateProjectionMatrix();
          };
          window.addEventListener('resize', onResize3D, { passive: true });
          three._onResize3D = onResize3D;
        } else {
          disposeSceneObjects();
        }
        // build geometry
        const vertices = new Float32Array(meshData.vertices.flat());
        const indices = new Uint32Array(meshData.faces.flat());
        const geom = new THREE.BufferGeometry();
        geom.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
        geom.setIndex(new THREE.BufferAttribute(indices, 1));
        geom.computeVertexNormals();
        const material = new THREE.MeshPhongMaterial({ color: 0xdddddd, specular: 0x111111, shininess: 30 });
        const mesh = new THREE.Mesh(geom, material);
        // center & scale
        geom.computeBoundingSphere();
        const bs = geom.boundingSphere; if (bs){ mesh.position.sub(bs.center); const target = 150; const s = bs.radius>0 ? target/bs.radius : 1; mesh.scale.setScalar(s); }
        three.scene.add(mesh);
        // animate (single RAF loop)
        if (threeAnimId) cancelAnimationFrame(threeAnimId);
        const animate = ()=>{ if (!three.renderer || container.style.display === 'none') return; three.controls.update(); three.renderer.render(three.scene, three.camera); threeAnimId = requestAnimationFrame(animate); };
        animate();
        document.getElementById('close3d').onclick = ()=>{ 
          if (threeAnimId) { cancelAnimationFrame(threeAnimId); threeAnimId = null; }
          disposeSceneObjects();
          if (three._onResize3D) { window.removeEventListener('resize', three._onResize3D); }
          container.style.display='none'; 
        };
      } catch(e){ console.warn('3D setup failed', e); }
    }
 
     // Init
     setCanvasSize();
     const studyId = q('study_id');
     if (studyId) loadStudy(studyId);

     // Unit selector wiring
     const unitSelect = document.getElementById('unitSelect');
     const unitVal = document.getElementById('unitVal');
     if (unitSelect){
             unitSelect.addEventListener('change', ()=>{
        measureUnit = unitSelect.value === 'cm' ? 'cm' : 'mm';
        unitVal.textContent = measureUnit;
        // Recompute labels for current measurements (series view)
        measurements = (measurements||[]).map(m=>{
          if (m && m.start && m.end){
            const dist = imageDistance(m.start, m.end);
            if (dist.mm){
              const mm = dist.mm; const cm = mm/10.0;
              m.label = (measureUnit==='cm') ? `${cm.toFixed(2)} cm` : `${mm.toFixed(2)} mm`;
            }
          }
          return m;
        });
        // Recompute MPR measurement labels
        ['axial','sagittal','coronal'].forEach(plane=>{
          mprMeasurements[plane] = (mprMeasurements[plane]||[]).map(m=>{
            if (m && m.start && m.end){
              const dist = mprImageDistance(plane, m.start, m.end);
              if (dist.mm){
                const mm = dist.mm; const cm = mm/10.0;
                m.label = (measureUnit==='cm') ? `${cm.toFixed(2)} cm` : `${mm.toFixed(2)} mm`;
              }
            }
            return m;
          });
        });
        renderMeasurementsList();
        requestDraw();
      });
     }

     document.getElementById('mprMeasurePlane').addEventListener('change', (e)=>{ mprMeasurePlaneMode = e.target.value; });
     document.getElementById('mprMeasureType').addEventListener('change', (e)=>{ mprMeasureType = e.target.value; });
   })();
  </script>
</body>
</html>