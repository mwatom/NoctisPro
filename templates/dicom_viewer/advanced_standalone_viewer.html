{% extends 'base.html' %}

{% block title %}Advanced DICOM Viewer - Noctis Pro PACS{% endblock %}

{% block extra_css %}
<style>
    /* Main viewer container */
    .viewer-container {
        background: #1a1a1a;
        height: 100vh;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        color: white;
    }

    /* Header bar */
    .viewer-header {
        background: linear-gradient(135deg, #2c2c2c 0%, #1f1f1f 100%);
        border-bottom: 1px solid #404040;
        padding: 12px 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        z-index: 100;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    .viewer-title {
        display: flex;
        align-items: center;
        color: #ffffff;
        gap: 12px;
    }

    .viewer-title h3 {
        margin: 0;
        font-weight: 600;
        font-size: 18px;
    }

    .header-actions {
        display: flex;
        align-items: center;
        gap: 12px;
    }

    .header-btn {
        background: #0078d4;
        border: none;
        border-radius: 6px;
        color: white;
        padding: 10px 16px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 14px;
    }

    .header-btn:hover {
        background: #106ebe;
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(16, 120, 190, 0.4);
    }

    /* Main layout */
    .viewer-main {
        display: flex;
        flex: 1;
        overflow: hidden;
    }

    /* Left toolbar */
    .toolbar {
        background: #2a2a2a;
        border-right: 1px solid #404040;
        width: 80px;
        padding: 10px 5px;
        display: flex;
        flex-direction: column;
        gap: 8px;
        align-items: center;
    }

    .tool-button {
        width: 70px;
        height: 50px;
        background: #444;
        border: none;
        border-radius: 5px;
        color: white;
        cursor: pointer;
        transition: all 0.2s ease;
        font-size: 10px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 2px;
    }

    .tool-button:hover {
        background: #555;
    }

    .tool-button.active {
        background: #0078d4;
    }

    .tool-icon {
        font-size: 16px;
    }

    /* Center viewport */
    .viewport-container {
        flex: 1;
        display: flex;
        flex-direction: column;
        background: #000;
        position: relative;
    }

    .viewport-top-bar {
        background: #333;
        border-bottom: 1px solid #555;
        padding: 8px 20px;
        display: flex;
        align-items: center;
        gap: 20px;
    }

    .patient-info {
        color: #ccc;
        font-size: 14px;
    }

    .viewport {
        flex: 1;
        position: relative;
        overflow: hidden;
    }

    #dicomCanvas {
        display: block;
        background: #000;
        cursor: crosshair;
    }

    /* Overlay labels */
    .overlay-label {
        position: absolute;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 8px 12px;
        border-radius: 4px;
        font-family: monospace;
        font-size: 12px;
        pointer-events: none;
        z-index: 10;
    }

    .wl-label {
        top: 10px;
        left: 10px;
        line-height: 1.4;
    }

    .zoom-label {
        bottom: 10px;
        left: 10px;
    }

    /* Right panel */
    .right-panel {
        width: 280px;
        background: #2a2a2a;
        border-left: 1px solid #404040;
        overflow-y: auto;
        padding: 20px;
    }

    .panel-section {
        margin-bottom: 25px;
    }

    .panel-title {
        font-size: 14px;
        font-weight: bold;
        color: white;
        margin-bottom: 15px;
        padding-bottom: 8px;
        border-bottom: 1px solid #404040;
    }

    .control-group {
        margin-bottom: 15px;
    }

    .control-label {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
        color: #ccc;
        font-size: 12px;
    }

    .control-value {
        color: #fff;
        font-weight: bold;
    }

    .slider {
        width: 100%;
        height: 4px;
        border-radius: 2px;
        background: #444;
        outline: none;
        -webkit-appearance: none;
    }

    .slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: #0078d4;
        cursor: pointer;
    }

    .preset-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
        margin-top: 10px;
    }

    .preset-btn {
        background: #444;
        border: none;
        border-radius: 4px;
        color: white;
        padding: 8px 4px;
        font-size: 11px;
        cursor: pointer;
        transition: background 0.2s;
    }

    .preset-btn:hover {
        background: #555;
    }

    .measurements-list {
        background: #444;
        border: 1px solid #555;
        border-radius: 4px;
        max-height: 200px;
        overflow-y: auto;
        padding: 8px;
    }

    .measurement-item {
        padding: 4px 0;
        border-bottom: 1px solid #555;
        font-size: 12px;
        color: #ccc;
    }

    .measurement-item:last-child {
        border-bottom: none;
    }

    /* Loading indicator */
    .loading-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        opacity: 0;
        visibility: hidden;
        transition: all 0.3s ease;
    }

    .loading-overlay.show {
        opacity: 1;
        visibility: visible;
    }

    .loading-spinner {
        width: 40px;
        height: 40px;
        border: 3px solid #333;
        border-top: 3px solid #0078d4;
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    /* Measurement overlays */
    .measurement-line {
        position: absolute;
        pointer-events: none;
        z-index: 5;
    }

    .annotation-text {
        position: absolute;
        background: rgba(0, 0, 0, 0.8);
        color: yellow;
        padding: 4px 8px;
        border-radius: 3px;
        font-size: 12px;
        pointer-events: none;
        z-index: 5;
    }

    /* Crosshair */
    .crosshair {
        position: absolute;
        pointer-events: none;
        z-index: 5;
    }

    .crosshair-line {
        background: cyan;
        opacity: 0.7;
    }

    .crosshair-h {
        height: 1px;
        width: 100%;
        top: 50%;
        left: 0;
    }

    .crosshair-v {
        width: 1px;
        height: 100%;
        left: 50%;
        top: 0;
    }
</style>
{% endblock %}

{% block content %}
<div class="viewer-container">
    <!-- Header -->
    <div class="viewer-header">
        <div class="viewer-title">
            <i class="fas fa-cube"></i>
            <h3>Advanced DICOM Viewer</h3>
        </div>
        <div class="header-actions">
            <button class="header-btn" onclick="loadDicomFiles()">
                <i class="fas fa-folder-open"></i>
                Load DICOM Files
            </button>
            <select id="backendStudySelect" class="header-btn" style="background: #404040; border: 1px solid #555;">
                <option value="">Select Study from Backend</option>
            </select>
        </div>
    </div>

    <!-- Main layout -->
    <div class="viewer-main">
        <!-- Left toolbar -->
        <div class="toolbar">
            <button class="tool-button active" data-tool="windowing" title="Window/Level (W)">
                <div class="tool-icon">üîÑ</div>
                <div>Window</div>
            </button>
            <button class="tool-button" data-tool="zoom" title="Zoom (Z)">
                <div class="tool-icon">üîç</div>
                <div>Zoom</div>
            </button>
            <button class="tool-button" data-tool="pan" title="Pan (P)">
                <div class="tool-icon">‚úã</div>
                <div>Pan</div>
            </button>
            <button class="tool-button" data-tool="measure" title="Measure (M)">
                <div class="tool-icon">üìè</div>
                <div>Measure</div>
            </button>
            <button class="tool-button" data-tool="annotate" title="Annotate (A)">
                <div class="tool-icon">üìù</div>
                <div>Annotate</div>
            </button>
            <button class="tool-button" data-tool="crosshair" title="Crosshair (C)">
                <div class="tool-icon">‚úö</div>
                <div>Crosshair</div>
            </button>
            <button class="tool-button" data-tool="invert" title="Invert (I)">
                <div class="tool-icon">‚ö´</div>
                <div>Invert</div>
            </button>
            <button class="tool-button" data-tool="reset" title="Reset View (R)">
                <div class="tool-icon">üîÑ</div>
                <div>Reset</div>
            </button>
            <button class="tool-button" data-tool="ai" title="AI Analysis">
                <div class="tool-icon">ü§ñ</div>
                <div>AI</div>
            </button>
            <button class="tool-button" data-tool="3d" title="3D Reconstruction">
                <div class="tool-icon">üßä</div>
                <div>3D</div>
            </button>
        </div>

        <!-- Center viewport -->
        <div class="viewport-container">
            <div class="viewport-top-bar">
                <div class="patient-info" id="patientInfo">
                    Patient: - | Study Date: - | Modality: -
                </div>
            </div>
            
            <div class="viewport">
                <canvas id="dicomCanvas"></canvas>
                
                <!-- Overlay labels -->
                <div class="overlay-label wl-label" id="wlLabel">
                    WW: 400<br>
                    WL: 40<br>
                    Slice: 1/1
                </div>
                
                <div class="overlay-label zoom-label" id="zoomLabel">
                    Zoom: 100%
                </div>

                <!-- Crosshair overlay -->
                <div class="crosshair" id="crosshair" style="display: none;">
                    <div class="crosshair-line crosshair-h"></div>
                    <div class="crosshair-line crosshair-v"></div>
                </div>

                <!-- Loading overlay -->
                <div class="loading-overlay" id="loadingOverlay">
                    <div class="loading-spinner"></div>
                </div>
            </div>
        </div>

        <!-- Right panel -->
        <div class="right-panel">
            <!-- Window/Level Controls -->
            <div class="panel-section">
                <div class="panel-title">Window/Level</div>
                
                <div class="control-group">
                    <div class="control-label">
                        <span>Window Width</span>
                        <span class="control-value" id="wwValue">400</span>
                    </div>
                    <input type="range" class="slider" id="wwSlider" min="1" max="4000" value="400">
                </div>
                
                <div class="control-group">
                    <div class="control-label">
                        <span>Window Level</span>
                        <span class="control-value" id="wlValue">40</span>
                    </div>
                    <input type="range" class="slider" id="wlSlider" min="-1000" max="1000" value="40">
                </div>

                <div class="preset-grid">
                    <button class="preset-btn" data-preset="lung">Lung</button>
                    <button class="preset-btn" data-preset="bone">Bone</button>
                    <button class="preset-btn" data-preset="soft">Soft</button>
                    <button class="preset-btn" data-preset="brain">Brain</button>
                </div>
            </div>

            <!-- Navigation Controls -->
            <div class="panel-section">
                <div class="panel-title">Image Navigation</div>
                
                <div class="control-group">
                    <div class="control-label">
                        <span>Slice</span>
                        <span class="control-value" id="sliceValue">1</span>
                    </div>
                    <input type="range" class="slider" id="sliceSlider" min="0" max="0" value="0">
                </div>
            </div>

            <!-- Transform Controls -->
            <div class="panel-section">
                <div class="panel-title">Transform</div>
                
                <div class="control-group">
                    <div class="control-label">
                        <span>Zoom</span>
                        <span class="control-value" id="zoomValue">100%</span>
                    </div>
                    <input type="range" class="slider" id="zoomSlider" min="25" max="500" value="100">
                </div>
            </div>

            <!-- Image Info -->
            <div class="panel-section">
                <div class="panel-title">Image Info</div>
                <div id="imageInfoPanel">
                    <div style="margin-bottom: 8px; color: #ccc; font-size: 12px;">
                        <strong>Dimensions:</strong> <span id="imageDimensions">-</span>
                    </div>
                    <div style="margin-bottom: 8px; color: #ccc; font-size: 12px;">
                        <strong>Pixel Spacing:</strong> <span id="pixelSpacing">-</span>
                    </div>
                    <div style="margin-bottom: 8px; color: #ccc; font-size: 12px;">
                        <strong>Series:</strong> <span id="seriesDescription">-</span>
                    </div>
                    <div style="margin-bottom: 8px; color: #ccc; font-size: 12px;">
                        <strong>Institution:</strong> <span id="institutionName">-</span>
                    </div>
                </div>
            </div>

            <!-- Measurements -->
            <div class="panel-section">
                <div class="panel-title">Measurements</div>
                <button class="preset-btn" onclick="clearMeasurements()" style="width: 100%; margin-bottom: 10px;">
                    Clear All
                </button>
                <div class="measurements-list" id="measurementsList">
                    <!-- Measurements will be populated here -->
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Hidden file input -->
<input type="file" id="dicomFileInput" multiple accept=".dcm,.dicom" style="display: none;">

<!-- CSRF Token -->
{% csrf_token %}

{% endblock %}

{% block extra_js %}
<script>
// Global variables
let dicomData = [];
let currentFileIndex = 0;
let currentTool = 'windowing';
let windowLevel = { width: 400, center: 40 };
let zoomLevel = 1.0;
let panOffset = { x: 0, y: 0 };
let inverted = false;
let crosshairEnabled = false;

// Measurement and annotation data
let measurements = [];
let annotations = [];
let currentMeasurement = null;
let isDrawing = false;

// Canvas and viewport management
let canvas, ctx;
let dragStart = null;
let imageData = null;
let viewLimits = null;

// Initialize the viewer
document.addEventListener('DOMContentLoaded', function() {
    initializeViewer();
    setupEventListeners();
    loadBackendStudies();
});

function initializeViewer() {
    canvas = document.getElementById('dicomCanvas');
    ctx = canvas.getContext('2d');
    
    // Set canvas size
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    // Clear canvas
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
}

function resizeCanvas() {
    const viewport = document.querySelector('.viewport');
    canvas.width = viewport.clientWidth;
    canvas.height = viewport.clientHeight;
    
    // Redraw if we have data
    if (dicomData.length > 0) {
        updateDisplay();
    }
}

function setupEventListeners() {
    // Tool buttons
    document.querySelectorAll('.tool-button').forEach(button => {
        button.addEventListener('click', function() {
            const tool = this.dataset.tool;
            handleToolClick(tool);
        });
    });

    // Window/Level sliders
    document.getElementById('wwSlider').addEventListener('input', function() {
        windowLevel.width = parseInt(this.value);
        document.getElementById('wwValue').textContent = this.value;
        updateDisplay();
    });

    document.getElementById('wlSlider').addEventListener('input', function() {
        windowLevel.center = parseInt(this.value);
        document.getElementById('wlValue').textContent = this.value;
        updateDisplay();
    });

    // Slice navigation
    document.getElementById('sliceSlider').addEventListener('input', function() {
        currentFileIndex = parseInt(this.value);
        document.getElementById('sliceValue').textContent = currentFileIndex + 1;
        updateDisplay();
    });

    // Zoom slider
    document.getElementById('zoomSlider').addEventListener('input', function() {
        zoomLevel = parseInt(this.value) / 100;
        document.getElementById('zoomValue').textContent = this.value + '%';
        updateDisplay();
    });

    // Preset buttons
    document.querySelectorAll('.preset-btn[data-preset]').forEach(button => {
        button.addEventListener('click', function() {
            const preset = this.dataset.preset;
            applyWindowPreset(preset);
        });
    });

    // Canvas mouse events
    canvas.addEventListener('mousedown', handleMouseDown);
    canvas.addEventListener('mousemove', handleMouseMove);
    canvas.addEventListener('mouseup', handleMouseUp);
    canvas.addEventListener('wheel', handleWheel);
    canvas.addEventListener('contextmenu', e => e.preventDefault());

    // Keyboard shortcuts
    document.addEventListener('keydown', handleKeyDown);
}

function handleToolClick(tool) {
    // Update active tool
    document.querySelectorAll('.tool-button').forEach(btn => btn.classList.remove('active'));
    
    if (tool === 'reset') {
        resetView();
    } else if (tool === 'invert') {
        inverted = !inverted;
        updateDisplay();
    } else if (tool === 'crosshair') {
        crosshairEnabled = !crosshairEnabled;
        updateCrosshair();
    } else if (tool === 'ai') {
        showAIAnalysis();
    } else if (tool === '3d') {
        show3DReconstruction();
    } else {
        currentTool = tool;
        document.querySelector(`[data-tool="${tool}"]`).classList.add('active');
    }
    
    // Update cursor
    updateCanvasCursor();
}

function updateCanvasCursor() {
    const cursors = {
        'windowing': 'crosshair',
        'zoom': 'zoom-in',
        'pan': 'move',
        'measure': 'crosshair',
        'annotate': 'text'
    };
    
    canvas.style.cursor = cursors[currentTool] || 'default';
}

function handleMouseDown(e) {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    dragStart = { x, y };
    
    if (currentTool === 'measure') {
        startMeasurement(x, y);
    } else if (currentTool === 'annotate') {
        addAnnotation(x, y);
    }
}

function handleMouseMove(e) {
    if (!dragStart) return;
    
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const dx = x - dragStart.x;
    const dy = y - dragStart.y;
    
    if (currentTool === 'windowing') {
        // Window/Level adjustment
        windowLevel.width = Math.max(1, windowLevel.width + dx * 2);
        windowLevel.center = Math.max(-1000, Math.min(1000, windowLevel.center + dy * 2));
        
        updateWindowLevelControls();
        updateDisplay();
        
        dragStart = { x, y };
    } else if (currentTool === 'zoom') {
        // Zoom adjustment
        const zoomDelta = 1 + dy * 0.01;
        zoomLevel = Math.max(0.1, Math.min(5.0, zoomLevel * zoomDelta));
        
        updateZoomControls();
        updateDisplay();
        
        dragStart = { x, y };
    } else if (currentTool === 'pan') {
        // Pan adjustment
        panOffset.x += dx;
        panOffset.y += dy;
        
        updateDisplay();
        
        dragStart = { x, y };
    } else if (currentTool === 'measure' && currentMeasurement) {
        // Update current measurement
        currentMeasurement.end = canvasToImageCoords(x, y);
        updateDisplay();
    }
}

function handleMouseUp(e) {
    if (currentTool === 'measure' && currentMeasurement) {
        finishMeasurement();
    }
    
    dragStart = null;
}

function handleWheel(e) {
    e.preventDefault();
    
    if (e.ctrlKey) {
        // Zoom
        const zoomDelta = e.deltaY > 0 ? 0.9 : 1.1;
        zoomLevel = Math.max(0.1, Math.min(5.0, zoomLevel * zoomDelta));
        updateZoomControls();
        updateDisplay();
    } else {
        // Slice navigation
        const direction = e.deltaY > 0 ? 1 : -1;
        navigateSlice(direction);
    }
}

function handleKeyDown(e) {
    // Tool shortcuts
    const toolKeys = {
        'KeyW': 'windowing',
        'KeyZ': 'zoom',
        'KeyP': 'pan',
        'KeyM': 'measure',
        'KeyA': 'annotate',
        'KeyC': 'crosshair',
        'KeyI': 'invert',
        'KeyR': 'reset'
    };
    
    if (toolKeys[e.code]) {
        e.preventDefault();
        handleToolClick(toolKeys[e.code]);
    }
    
    // Arrow keys for slice navigation
    if (e.code === 'ArrowUp' || e.code === 'ArrowDown') {
        e.preventDefault();
        const direction = e.code === 'ArrowUp' ? -1 : 1;
        navigateSlice(direction);
    }
}

function loadDicomFiles() {
    document.getElementById('dicomFileInput').click();
}

document.getElementById('dicomFileInput').addEventListener('change', function(e) {
    const files = Array.from(e.target.files);
    if (files.length > 0) {
        processDicomFiles(files);
    }
});

async function processDicomFiles(files) {
    showLoading(true);
    
    try {
        dicomData = [];
        
        for (let i = 0; i < files.length; i++) {
            const file = files[i];
            const dicomInfo = await parseDicomFile(file);
            if (dicomInfo) {
                dicomData.push(dicomInfo);
            }
        }
        
        if (dicomData.length > 0) {
            // Sort by instance number if available
            dicomData.sort((a, b) => {
                const aInstance = a.tags['Instance Number'] || 0;
                const bInstance = b.tags['Instance Number'] || 0;
                return parseInt(aInstance) - parseInt(bInstance);
            });
            
            currentFileIndex = 0;
            setupSliceNavigation();
            await updateDisplay();
            updateImageInfo();
        }
    } catch (error) {
        console.error('Error processing DICOM files:', error);
        alert('Error processing DICOM files: ' + error.message);
    } finally {
        showLoading(false);
    }
}

async function parseDicomFile(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const arrayBuffer = e.target.result;
                const dicomInfo = extractDicomInfo(arrayBuffer);
                dicomInfo.file = file;
                resolve(dicomInfo);
            } catch (error) {
                console.error('Error parsing DICOM file:', file.name, error);
                resolve(null);
            }
        };
        reader.onerror = () => reject(new Error('Failed to read file'));
        reader.readAsArrayBuffer(file);
    });
}

function extractDicomInfo(arrayBuffer) {
    const dataView = new DataView(arrayBuffer);
    const tags = {};
    
    // Skip DICOM preamble (128 bytes) and DICM prefix (4 bytes)
    let offset = 132;
    
    // Read DICOM tags
    while (offset < arrayBuffer.byteLength - 8) {
        try {
            const group = dataView.getUint16(offset, true);
            const element = dataView.getUint16(offset + 2, true);
            const vr = String.fromCharCode(dataView.getUint8(offset + 4), dataView.getUint8(offset + 5));
            
            let valueLength;
            let valueOffset;
            
            if (['OB', 'OD', 'OF', 'OL', 'OW', 'SQ', 'UC', 'UN', 'UR', 'UT'].includes(vr)) {
                valueLength = dataView.getUint32(offset + 8, true);
                valueOffset = offset + 12;
            } else {
                valueLength = dataView.getUint16(offset + 6, true);
                valueOffset = offset + 8;
            }
            
            // Extract common tags
            const tagKey = `${group.toString(16).padStart(4, '0')},${element.toString(16).padStart(4, '0')}`;
            
            if (group === 0x0010 && element === 0x0010) { // Patient Name
                tags['Patient Name'] = extractStringValue(dataView, valueOffset, valueLength);
            } else if (group === 0x0008 && element === 0x0020) { // Study Date
                tags['Study Date'] = extractStringValue(dataView, valueOffset, valueLength);
            } else if (group === 0x0008 && element === 0x0060) { // Modality
                tags['Modality'] = extractStringValue(dataView, valueOffset, valueLength);
            } else if (group === 0x0020 && element === 0x0013) { // Instance Number
                tags['Instance Number'] = extractStringValue(dataView, valueOffset, valueLength);
            } else if (group === 0x0008 && element === 0x103e) { // Series Description
                tags['Series Description'] = extractStringValue(dataView, valueOffset, valueLength);
            } else if (group === 0x0028 && element === 0x0010) { // Rows
                tags['Rows'] = dataView.getUint16(valueOffset, true);
            } else if (group === 0x0028 && element === 0x0011) { // Columns
                tags['Columns'] = dataView.getUint16(valueOffset, true);
            } else if (group === 0x0028 && element === 0x0030) { // Pixel Spacing
                const spacingStr = extractStringValue(dataView, valueOffset, valueLength);
                tags['Pixel Spacing'] = spacingStr.split('\\').map(s => parseFloat(s));
            } else if (group === 0x0028 && element === 0x1050) { // Window Center
                tags['Window Center'] = parseFloat(extractStringValue(dataView, valueOffset, valueLength));
            } else if (group === 0x0028 && element === 0x1051) { // Window Width
                tags['Window Width'] = parseFloat(extractStringValue(dataView, valueOffset, valueLength));
            }
            
            offset = valueOffset + valueLength;
            if (valueLength % 2 === 1) offset++; // DICOM uses even byte boundaries
            
        } catch (error) {
            break;
        }
    }
    
    return {
        tags: tags,
        width: tags['Columns'] || 512,
        height: tags['Rows'] || 512,
        pixelSpacing: tags['Pixel Spacing'] || [1.0, 1.0],
        defaultWindowWidth: tags['Window Width'] || 400,
        defaultWindowLevel: tags['Window Center'] || 40
    };
}

function extractStringValue(dataView, offset, length) {
    let value = '';
    for (let i = 0; i < length; i++) {
        const char = dataView.getUint8(offset + i);
        if (char === 0) break;
        value += String.fromCharCode(char);
    }
    return value.trim();
}

async function updateDisplay() {
    if (dicomData.length === 0) return;
    
    const currentDicom = dicomData[currentFileIndex];
    
    // Clear canvas
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    try {
        // Get processed image data from server
        const imageDataUrl = await getProcessedImageData(currentDicom);
        
        if (imageDataUrl) {
            await drawImageToCanvas(imageDataUrl);
        }
        
        // Draw overlays
        drawMeasurements();
        drawAnnotations();
        updateOverlayLabels();
        
    } catch (error) {
        console.error('Error updating display:', error);
        
        // Show error message
        ctx.fillStyle = 'red';
        ctx.font = '16px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Error loading DICOM image', canvas.width / 2, canvas.height / 2);
    }
}

async function getProcessedImageData(dicomInfo) {
    if (!dicomInfo.file) return null;
    
    try {
        // Upload file and get processed image
        const formData = new FormData();
        formData.append('dicom_file', dicomInfo.file);
        
        const uploadResponse = await fetch('{% url "dicom_viewer:upload_dicom" %}', {
            method: 'POST',
            body: formData,
            headers: {
                'X-CSRFToken': getCsrfToken()
            }
        });
        
        if (!uploadResponse.ok) {
            throw new Error('Failed to upload DICOM file');
        }
        
        const uploadData = await uploadResponse.json();
        
        if (uploadData.images && uploadData.images.length > 0) {
            const imageId = uploadData.images[0].id;
            
            // Get processed image with current windowing
            const displayUrl = `{% url 'dicom_viewer:api_dicom_image_display' 0 %}`.replace('0', imageId) + 
                             `?window_width=${windowLevel.width}&window_level=${windowLevel.center}&inverted=${inverted}`;
            
            const displayResponse = await fetch(displayUrl);
            
            if (!displayResponse.ok) {
                throw new Error('Failed to get processed image');
            }
            
            const displayData = await displayResponse.json();
            return displayData.image_data;
        }
        
        return null;
    } catch (error) {
        console.error('Error getting processed image data:', error);
        return null;
    }
}

function drawImageToCanvas(imageDataUrl) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = function() {
            // Calculate image position and size with zoom and pan
            const imageWidth = img.width * zoomLevel;
            const imageHeight = img.height * zoomLevel;
            const x = (canvas.width - imageWidth) / 2 + panOffset.x;
            const y = (canvas.height - imageHeight) / 2 + panOffset.y;
            
            // Draw image
            ctx.drawImage(img, x, y, imageWidth, imageHeight);
            
            // Store image bounds for coordinate conversion
            imageData = {
                x, y, width: imageWidth, height: imageHeight,
                originalWidth: img.width, originalHeight: img.height
            };
            
            resolve();
        };
        img.onerror = reject;
        img.src = imageDataUrl;
    });
}

function canvasToImageCoords(canvasX, canvasY) {
    if (!imageData) return { x: canvasX, y: canvasY };
    
    const imageX = (canvasX - imageData.x) * (imageData.originalWidth / imageData.width);
    const imageY = (canvasY - imageData.y) * (imageData.originalHeight / imageData.height);
    
    return { x: imageX, y: imageY };
}

function imageToCanvasCoords(imageX, imageY) {
    if (!imageData) return { x: imageX, y: imageY };
    
    const canvasX = imageData.x + imageX * (imageData.width / imageData.originalWidth);
    const canvasY = imageData.y + imageY * (imageData.height / imageData.originalHeight);
    
    return { x: canvasX, y: canvasY };
}

function startMeasurement(x, y) {
    const imageCoords = canvasToImageCoords(x, y);
    currentMeasurement = {
        start: imageCoords,
        end: imageCoords
    };
    isDrawing = true;
}

function finishMeasurement() {
    if (currentMeasurement) {
        measurements.push(currentMeasurement);
        updateMeasurementsList();
        saveMeasurements();
        currentMeasurement = null;
        isDrawing = false;
    }
}

function addAnnotation(x, y) {
    const text = prompt('Enter annotation text:');
    if (text && text.trim()) {
        const imageCoords = canvasToImageCoords(x, y);
        annotations.push({
            position: imageCoords,
            text: text.trim()
        });
        updateDisplay();
        saveMeasurements();
    }
}

function drawMeasurements() {
    ctx.strokeStyle = 'red';
    ctx.lineWidth = 2;
    ctx.fillStyle = 'red';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
    
    // Draw saved measurements
    measurements.forEach((measurement, index) => {
        const start = imageToCanvasCoords(measurement.start.x, measurement.start.y);
        const end = imageToCanvasCoords(measurement.end.x, measurement.end.y);
        
        // Draw line
        ctx.beginPath();
        ctx.moveTo(start.x, start.y);
        ctx.lineTo(end.x, end.y);
        ctx.stroke();
        
        // Calculate and display distance
        const distance = calculateDistance(measurement.start, measurement.end);
        const midX = (start.x + end.x) / 2;
        const midY = (start.y + end.y) / 2;
        
        // Draw text background
        const textMetrics = ctx.measureText(distance.formatted);
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(midX - textMetrics.width / 2 - 4, midY - 8, textMetrics.width + 8, 16);
        
        // Draw text
        ctx.fillStyle = 'red';
        ctx.fillText(distance.formatted, midX, midY + 4);
    });
    
    // Draw current measurement being drawn
    if (currentMeasurement && isDrawing) {
        const start = imageToCanvasCoords(currentMeasurement.start.x, currentMeasurement.start.y);
        const end = imageToCanvasCoords(currentMeasurement.end.x, currentMeasurement.end.y);
        
        ctx.strokeStyle = 'yellow';
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(start.x, start.y);
        ctx.lineTo(end.x, end.y);
        ctx.stroke();
        ctx.setLineDash([]);
    }
}

function drawAnnotations() {
    ctx.fillStyle = 'yellow';
    ctx.font = '12px Arial';
    ctx.textAlign = 'left';
    
    annotations.forEach(annotation => {
        const pos = imageToCanvasCoords(annotation.position.x, annotation.position.y);
        
        // Draw text background
        const textMetrics = ctx.measureText(annotation.text);
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(pos.x, pos.y - 12, textMetrics.width + 8, 16);
        
        // Draw text
        ctx.fillStyle = 'yellow';
        ctx.fillText(annotation.text, pos.x + 4, pos.y);
    });
}

function calculateDistance(start, end) {
    const pixelDistance = Math.sqrt((end.x - start.x) ** 2 + (end.y - start.y) ** 2);
    
    const currentDicom = dicomData[currentFileIndex];
    const pixelSpacing = currentDicom.pixelSpacing;
    
    if (pixelSpacing && pixelSpacing.length >= 2) {
        const avgSpacing = (pixelSpacing[0] + pixelSpacing[1]) / 2;
        const distanceMm = pixelDistance * avgSpacing;
        const distanceCm = distanceMm / 10;
        
        return {
            pixel: pixelDistance,
            mm: distanceMm,
            cm: distanceCm,
            formatted: `${distanceMm.toFixed(1)} mm / ${distanceCm.toFixed(2)} cm`
        };
    }
    
    return {
        pixel: pixelDistance,
        formatted: `${pixelDistance.toFixed(1)} px`
    };
}

function updateMeasurementsList() {
    const list = document.getElementById('measurementsList');
    list.innerHTML = '';
    
    measurements.forEach((measurement, index) => {
        const distance = calculateDistance(measurement.start, measurement.end);
        const item = document.createElement('div');
        item.className = 'measurement-item';
        item.textContent = `Measurement ${index + 1}: ${distance.formatted}`;
        list.appendChild(item);
    });
}

function clearMeasurements() {
    measurements = [];
    annotations = [];
    currentMeasurement = null;
    isDrawing = false;
    updateMeasurementsList();
    updateDisplay();
    saveMeasurements();
}

async function saveMeasurements() {
    try {
        await fetch('{% url "dicom_viewer:api_measurements_standalone" %}', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCsrfToken()
            },
            body: JSON.stringify({
                measurements: measurements,
                annotations: annotations
            })
        });
    } catch (error) {
        console.error('Error saving measurements:', error);
    }
}

function navigateSlice(direction) {
    const newIndex = currentFileIndex + direction;
    if (newIndex >= 0 && newIndex < dicomData.length) {
        currentFileIndex = newIndex;
        document.getElementById('sliceSlider').value = currentFileIndex;
        document.getElementById('sliceValue').textContent = currentFileIndex + 1;
        updateDisplay();
    }
}

function setupSliceNavigation() {
    const slider = document.getElementById('sliceSlider');
    slider.max = dicomData.length - 1;
    slider.value = currentFileIndex;
    document.getElementById('sliceValue').textContent = currentFileIndex + 1;
}

function updateWindowLevelControls() {
    document.getElementById('wwSlider').value = windowLevel.width;
    document.getElementById('wwValue').textContent = Math.round(windowLevel.width);
    document.getElementById('wlSlider').value = windowLevel.center;
    document.getElementById('wlValue').textContent = Math.round(windowLevel.center);
}

function updateZoomControls() {
    const zoomPercent = Math.round(zoomLevel * 100);
    document.getElementById('zoomSlider').value = zoomPercent;
    document.getElementById('zoomValue').textContent = zoomPercent + '%';
}

function updateOverlayLabels() {
    document.getElementById('wlLabel').innerHTML = 
        `WW: ${Math.round(windowLevel.width)}<br>WL: ${Math.round(windowLevel.center)}<br>Slice: ${currentFileIndex + 1}/${dicomData.length}`;
    
    document.getElementById('zoomLabel').textContent = `Zoom: ${Math.round(zoomLevel * 100)}%`;
}

function updateImageInfo() {
    if (dicomData.length === 0) return;
    
    const currentDicom = dicomData[currentFileIndex];
    const tags = currentDicom.tags;
    
    // Update patient info
    document.getElementById('patientInfo').textContent = 
        `Patient: ${tags['Patient Name'] || 'N/A'} | Study Date: ${tags['Study Date'] || 'N/A'} | Modality: ${tags['Modality'] || 'N/A'}`;
    
    // Update image info panel
    document.getElementById('imageDimensions').textContent = `${currentDicom.width} x ${currentDicom.height}`;
    
    const pixelSpacing = currentDicom.pixelSpacing;
    if (pixelSpacing && pixelSpacing.length >= 2) {
        document.getElementById('pixelSpacing').textContent = `${pixelSpacing[0]}\\${pixelSpacing[1]}`;
    } else {
        document.getElementById('pixelSpacing').textContent = 'N/A';
    }
    
    document.getElementById('seriesDescription').textContent = tags['Series Description'] || 'N/A';
    document.getElementById('institutionName').textContent = tags['Institution Name'] || 'N/A';
}

function applyWindowPreset(preset) {
    const presets = {
        'lung': { width: 1500, center: -600 },
        'bone': { width: 2000, center: 300 },
        'soft': { width: 400, center: 40 },
        'brain': { width: 100, center: 50 }
    };
    
    if (presets[preset]) {
        windowLevel = presets[preset];
        updateWindowLevelControls();
        updateDisplay();
    }
}

function resetView() {
    zoomLevel = 1.0;
    panOffset = { x: 0, y: 0 };
    updateZoomControls();
    updateDisplay();
}

function updateCrosshair() {
    const crosshair = document.getElementById('crosshair');
    crosshair.style.display = crosshairEnabled ? 'block' : 'none';
}

function showAIAnalysis() {
    alert('AI Analysis: This feature would connect to an AI service for automated diagnosis assistance.');
}

function show3DReconstruction() {
    alert('3D Reconstruction: This feature would generate 3D models from the DICOM series.');
}

function showLoading(show) {
    const overlay = document.getElementById('loadingOverlay');
    if (show) {
        overlay.classList.add('show');
    } else {
        overlay.classList.remove('show');
    }
}

async function loadBackendStudies() {
    try {
        const response = await fetch('{% url "dicom_viewer:api_realtime_studies" %}');
        if (response.ok) {
            const data = await response.json();
            const select = document.getElementById('backendStudySelect');
            
            // Clear existing options except first
            while (select.children.length > 1) {
                select.removeChild(select.lastChild);
            }
            
            // Add studies
            data.studies.forEach(study => {
                const option = document.createElement('option');
                option.value = study.id;
                option.textContent = `${study.patient_name} - ${study.study_date} (${study.modality})`;
                select.appendChild(option);
            });
        }
    } catch (error) {
        console.error('Error loading backend studies:', error);
    }
}

// Handle backend study selection
document.getElementById('backendStudySelect').addEventListener('change', function() {
    const studyId = this.value;
    if (studyId) {
        window.location.href = `{% url 'dicom_viewer:view_study' 0 %}`.replace('0', studyId);
    }
});

function getCsrfToken() {
    return document.querySelector('[name=csrfmiddlewaretoken]').value;
}
</script>
{% endblock %}