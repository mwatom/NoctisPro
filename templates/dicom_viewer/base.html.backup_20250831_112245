<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DICOM Viewer</title>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
  <style>
    :root {
      --primary-bg: #0a0a0a;
      --secondary-bg: #1a1a1a;
      --card-bg: #252525;
      --card-surface: #252525;
      --header-bg: #333333;
      --border-color: #404040;
      --accent-color: #00d4ff;
      --text-primary: #ffffff;
      --text-secondary: #b3b3b3;
      --text-muted: #666666;
      --success-color: #00ff88;
      --warning-color: #ffaa00;
      --danger-color: #ff4444;
      --urgent-color: #ff0066;
      --scheduled-color: #4a90e2;
      --in-progress-color: #f5a623;
      --completed-color: #7ed321;
      --cancelled-color: #d0021b;
    }
    html, body { margin: 0; padding: 0; height: 100%; width: 100%; overflow: hidden; }
    body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: var(--primary-bg); color: var(--text-primary); }
    .main-container { height: 100vh; width: 100vw; position: fixed; top: 0; left: 0; overflow: hidden; }
    .layout { display: grid; grid-template-columns: 82px 1fr 320px; grid-template-rows: 60px 1fr; height: 100%; width: 100%; }
    .toolbar { grid-row: 1 / span 2; grid-column: 1; background: var(--secondary-bg); border-right: 1px solid var(--border-color); padding: 8px 6px; display: flex; flex-direction: column; gap: 6px; overflow:auto; }
    .tool { width: 52px; height: 46px; background: var(--card-bg); border: 1px solid var(--border-color); border-radius: 2px; color: var(--text-primary); cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 9px; transition: all 0.2s ease; font-weight: 500; position: relative; }
    .tool.active { background: var(--accent-color); color: var(--primary-bg); border-color: var(--accent-color); box-shadow: 0 0 8px rgba(0, 212, 255, 0.3); }
    .tool:hover:not(.active) { background: var(--accent-color); color: var(--primary-bg); border-color: var(--accent-color); transform: translateY(-1px); box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); }
    .tool:disabled { opacity: 0.5; cursor: not-allowed; pointer-events: none; }
    .tool i { font-size: 16px; margin-bottom: 2px; }
    .topbar { grid-row: 1; grid-column: 2 / span 2; display: flex; align-items: center; gap: 8px; padding: 0 16px; background: var(--header-bg); border-bottom: 1px solid var(--border-color); }
    .btn { padding: 3px 8px; border: 1px solid var(--border-color); border-radius: 2px; cursor: pointer; font-size: 10px; background: var(--card-bg); color: var(--text-primary); transition: all 0.2s ease; font-weight: 500; display: inline-flex; align-items: center; gap: 3px; text-decoration: none; min-width: 60px; justify-content: center; }
    .btn:hover:not(:disabled) { background: var(--accent-color); color: var(--primary-bg); border-color: var(--accent-color); transform: translateY(-1px); box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); }
    .btn:disabled { opacity: 0.6; cursor: not-allowed; pointer-events: none; }
    .btn-primary { background: var(--accent-color); color: var(--primary-bg); border-color: var(--accent-color); }
    .btn-primary:hover:not(:disabled) { background: #00b8d4; border-color: #00b8d4; }
    .btn-danger { background: var(--danger-color); color: var(--text-primary); border-color: var(--danger-color); }
    .btn-danger:hover:not(:disabled) { background: #ff6666; border-color: #ff6666; transform: translateY(-1px); box-shadow: 0 2px 4px rgba(255, 68, 68, 0.3); }
    
    .btn-control { padding: 3px 8px; border: 1px solid var(--border-color); border-radius: 2px; cursor: pointer; font-size: 10px; background: var(--card-bg); color: var(--text-primary); transition: all 0.2s ease; font-weight: 500; display: inline-flex; align-items: center; gap: 3px; text-decoration: none; min-width: 80px; justify-content: center; }
    .btn-control:hover:not(:disabled) { background: var(--accent-color); color: var(--primary-bg); border-color: var(--accent-color); transform: translateY(-1px); box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); }
    .btn-control:disabled { opacity: 0.6; cursor: not-allowed; pointer-events: none; }
    .select { padding: 4px 6px; background: var(--secondary-bg); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); min-width: 160px; font-size: 10px; }
    .select:focus { outline: none; border-color: var(--accent-color); box-shadow: 0 0 0 1px var(--accent-color); }
    .viewport { grid-row: 2; grid-column: 2; background: #000000; position: relative; display: flex; align-items: center; justify-content: center; overflow: hidden; }
    .right { grid-row: 2; grid-column: 3; background: var(--secondary-bg); border-left: 1px solid var(--border-color); padding: 16px; overflow-y: auto; overflow-x: hidden; }
    .panel { background: var(--card-surface); border: 1px solid var(--border-color); border-radius: 8px; padding: 12px; margin-bottom: 16px; }
    .panel h3 { font-size: 12px; margin: 0 0 12px; padding-bottom: 8px; border-bottom: 1px solid var(--border-color); letter-spacing: .3px; color: var(--accent-color); font-weight: 600; text-transform: uppercase; }
    .control { margin-bottom: 12px; }
    .control .label { display: flex; justify-content: space-between; font-size: 11px; color: var(--text-secondary); margin-bottom: 6px; font-weight: 500; }
    input[type=range] { width: 100%; accent-color: var(--accent-color); height: 4px; background: var(--border-color); border-radius: 2px; }
    input[type=number] { width: 100%; padding: 6px 8px; background: var(--secondary-bg); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 11px; }
    input[type=number]:focus { outline: none; border-color: var(--accent-color); box-shadow: 0 0 0 1px var(--accent-color); }
    .overlay { position: absolute; top: 12px; left: 12px; background: rgba(0,0,0,0.8); padding: 8px 12px; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 11px; border: 1px solid var(--border-color); }
    .zoominfo { position: absolute; bottom: 12px; left: 12px; background: rgba(0,0,0,0.8); padding: 6px 10px; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 11px; border: 1px solid var(--border-color); }
    canvas { max-width: 100%; max-height: 100%; image-rendering: pixelated; image-rendering: crisp-edges; display: block; }
    .thumbs { display:grid; grid-template-columns: 1fr 1fr; gap:8px; }
    .thumbs img { width:100%; background:#000; border-radius:6px; border:1px solid var(--border-color); }
    .row-3 { display:grid; grid-template-columns: 1fr 1fr 1fr; gap:8px; }
    .muted { color:var(--text-muted); font-size:11px; padding:4px 0; }
    /* 3D dropdown in toolbar */
    .tool-dropdown { position: relative; }
    .tool-dropdown-menu { position: absolute; top: 48px; left: 0; background: var(--card-surface); border: 1px solid var(--border-color); border-radius: 6px; width: 180px; display: none; flex-direction: column; overflow: hidden; z-index: 10; box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
    .tool-dropdown-menu button { background: transparent; border: none; color: var(--text-primary); text-align: left; padding: 8px 12px; cursor: pointer; font-size: 11px; transition: all 0.2s ease; font-weight: 500; }
    .tool-dropdown-menu button:hover { background: var(--accent-color); color: var(--primary-bg); }
    /* 3D modal */
    #threeContainer { position: fixed; inset: 0; background: rgba(0,0,0,0.95); display: none; z-index: 1000; overflow: hidden; }
    #threeMount { position: absolute; inset: 0; overflow: hidden; }
    #close3d { position: absolute; top: 12px; right: 12px; z-index: 1001; background: var(--card-surface); border: 1px solid var(--border-color); color: var(--text-primary); padding: 8px 12px; border-radius: 4px; cursor: pointer; transition: all 0.2s ease; }
    #close3d:hover { background: var(--border-color); }
    /* DICOM tags modal */
    #dicomModal { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; background: rgba(0,0,0,0.8); z-index: 1200; overflow: hidden; }
    #dicomModal .modal-card { background:var(--card-surface); border:1px solid var(--border-color); padding:20px; width:70%; max-width: 960px; max-height:80%; overflow-y:auto; overflow-x:hidden; border-radius:8px; box-shadow: 0 8px 24px rgba(0,0,0,0.4); }
    #dicomModal .modal-header { display:flex; justify-content: space-between; align-items:center; margin-bottom:12px; border-bottom: 1px solid var(--border-color); padding-bottom: 12px; }
    #dicomModal h3 { color: var(--accent-color); font-weight: 600; margin: 0; text-transform: uppercase; font-size: 12px; }
    #dicomModal #dicomTagsPre { background: var(--secondary-bg); border: 1px solid var(--border-color); border-radius: 4px; padding: 12px; color: var(--text-secondary); font-family: 'Courier New', monospace; font-size: 11px; }
    
    /* Print modal */
    #printModal { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; background: rgba(0,0,0,0.8); z-index: 1300; overflow: hidden; }
    #printModal .modal-card { background:var(--card-surface); border:1px solid var(--border-color); padding:20px; width:500px; max-height:80%; overflow-y:auto; overflow-x:hidden; border-radius:8px; box-shadow: 0 8px 24px rgba(0,0,0,0.4); }
    #printModal .modal-header { display:flex; justify-content: space-between; align-items:center; margin-bottom:16px; border-bottom: 1px solid var(--border-color); padding-bottom: 12px; }
    #printModal h3 { color: var(--accent-color); font-weight: 600; margin: 0; text-transform: uppercase; font-size: 12px; }
    #printModal .form-group { margin-bottom: 16px; }
    #printModal .form-group label { display: block; margin-bottom: 6px; font-size: 11px; color: var(--text-secondary); font-weight: 500; }
    #printModal .form-group select, #printModal .form-group input { width: 100%; padding: 8px; background: var(--secondary-bg); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 11px; }
    #printModal .form-group select:focus, #printModal .form-group input:focus { outline: none; border-color: var(--accent-color); box-shadow: 0 0 0 1px var(--accent-color); }
    #printModal .btn-group { display: flex; gap: 8px; justify-content: flex-end; margin-top: 20px; }
  </style>
  
  <!-- Three.js CDN for 3D functionality -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r160/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>
  
  <!-- Performance optimization: Image preloader and cache -->
  <script>
    class ImagePreloader {
      constructor() {
        this.cache = new Map();
        this.preloadQueue = [];
        this.isPreloading = false;
        this.maxCacheSize = 100;
      }
      
      async preloadImage(url) {
        if (this.cache.has(url)) {
          return this.cache.get(url);
        }
        
        return new Promise((resolve) => {
          const img = new Image();
          img.onload = () => {
            if (this.cache.size >= this.maxCacheSize) {
              const firstKey = this.cache.keys().next().value;
              this.cache.delete(firstKey);
            }
            this.cache.set(url, img);
            resolve(img);
          };
          img.onerror = () => resolve(null);
          img.src = url;
        });
      }
      
      async preloadNextImages(currentIndex, images, count = 3) {
        const preloadPromises = [];
        for (let i = 1; i <= count && currentIndex + i < images.length; i++) {
          const nextImage = images[currentIndex + i];
          if (nextImage && nextImage.url) {
            preloadPromises.push(this.preloadImage(nextImage.url));
          }
        }
        return Promise.all(preloadPromises);
      }
    }
    
    const imagePreloader = new ImagePreloader();
  </script>
</head>
<body>
  <div class="main-container">
    <div class="layout">
    <div class="toolbar">
      <button type="button" class="tool active" data-tool="window"><i class="fas fa-adjust"></i><span>Window</span></button>
      <button type="button" class="tool" data-tool="zoom"><i class="fas fa-search-plus"></i><span>Zoom</span></button>
      <button type="button" class="tool" data-tool="pan"><i class="fas fa-arrows-alt"></i><span>Pan</span></button>
      <button type="button" class="tool" data-tool="measure"><i class="fas fa-ruler"></i><span>Measure</span></button>
      <button type="button" class="tool" data-tool="annotate"><i class="fas fa-comment-dots"></i><span>Annotate</span></button>
      <button type="button" class="tool" data-tool="crosshair"><i class="fas fa-crosshairs"></i><span>Crosshair</span></button>
      <button type="button" class="tool" data-tool="hu"><i class="fas fa-thermometer-half"></i><span>HU</span></button>
      <button type="button" class="tool" data-tool="invert"><i class="fas fa-adjust"></i><span>Invert</span></button>
      <button type="button" class="tool" data-tool="reset"><i class="fas fa-undo"></i><span>Reset</span></button>
      <button type="button" class="tool" data-tool="fit"><i class="fas fa-compress-arrows-alt"></i><span>Fit</span></button>
      <button type="button" class="tool" data-tool="one"><i class="fas fa-expand"></i><span>1:1</span></button>
      <button type="button" class="tool" data-tool="cine"><i class="fas fa-film"></i><span>Cine</span></button>
      <button type="button" class="tool" data-tool="spyglass"><i class="fas fa-search"></i><span>Spyglass</span></button>
      <button type="button" class="tool" data-tool="align-center"><i class="fas fa-align-center"></i><span>Center</span></button>
      <button type="button" class="tool" data-tool="reload"><i class="fas fa-sync"></i><span>Reload</span></button>
      <button type="button" class="tool" data-tool="ai"><i class="fas fa-robot"></i><span>AI</span></button>
      <!-- 3D dropdown moved into toolbar -->
      <div class="tool-dropdown">
        <button type="button" id="btn3D" class="tool"><i class="fas fa-cube"></i><span>3D</span></button>
        <div id="menu3D" class="tool-dropdown-menu">
          <button type="button" data-recon="mpr"><i class="fas fa-layer-group"></i> MPR</button>
          <button type="button" data-recon="mip"><i class="fas fa-bullseye"></i> MIP</button>
          <button type="button" data-recon="bone"><i class="fas fa-bone"></i> Bone</button>
        </div>
      </div>
    </div>
    <div class="topbar">
      <button type="button" id="btnLoadLocal" class="btn-control"><i class="fas fa-folder-open"></i> Load Local DICOM</button>
      <a id="btnBackWorklist" class="btn" href="{% url 'worklist:dashboard' %}" onclick="return returnToWorklist(event)"><i class="fas fa-arrow-left"></i> Back to Worklist</a>
      {% if user.is_authenticated and user.can_edit_reports %}
      <button type="button" id="btnWriteReport" class="btn-control" style="display:none"><i class="fas fa-file-signature"></i> Write Report</button>
      {% endif %}
      <input id="localDicom" type="file" multiple webkitdirectory directory accept=".dcm,.dicom,application/dicom" style="display:none" />
      <select id="seriesSelect" class="select"><option value="">Select Series</option></select>
      <select id="sortSelect" class="select">
        <option value="">Sort: Instance # (asc)</option>
        <option value="inst_desc">Instance # (desc)</option>
      </select>
      <button type="button" id="btnToggleTags" class="btn"><i class="fas fa-tags"></i> Tags</button>
      <button type="button" id="btnShowDicom" class="btn"><i class="fas fa-info-circle"></i> Show DICOM</button>
      <button type="button" id="btnCapture" class="btn"><i class="fas fa-camera"></i> Capture</button>
      <button type="button" id="btnPrint" class="btn"><i class="fas fa-print"></i> Print</button>
      
      {% if user.is_superuser %}
      <button type="button" id="btnDeleteStudy" class="btn btn-danger" style="margin-left: auto;"><i class="fas fa-trash"></i> Delete Study</button>
      {% endif %}
      <div id="patientInfo" style="margin-left:auto;color:#ccc;font-size:13px;">Patient: - | Study Date: - | Modality: -</div>
    </div>
    <div class="viewport" id="viewport">
      <canvas id="dicomCanvas"></canvas>
      <div class="overlay" id="overlay">WW: 400<br>WL: 40<br>Slice: 1/1</div>
      <div class="zoominfo" id="zoominfo">Zoom: 100%</div>
    </div>
    <div class="right">
      <div class="panel">
        <h3>Window/Level</h3>
        <div class="control"><div class="label"><span>Window Width</span><span id="wwVal">400</span></div><input id="ww" type="range" min="1" max="4000" value="400"></div>
        <div class="control"><input id="wwNum" type="number" min="1" max="4000" step="1" value="400"></div>
        <div class="control"><div class="label"><span>Window Level</span><span id="wlVal">40</span></div><input id="wl" type="range" min="-1000" max="1000" value="40"></div>
        <div class="control"><input id="wlNum" type="number" min="-1000" max="1000" step="1" value="40"></div>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:6px;">
          <button type="button" class="btn" data-preset="lung">Lung</button>
          <button type="button" class="btn" data-preset="bone">Bone</button>
          <button type="button" class="btn" data-preset="soft">Soft</button>
          <button type="button" class="btn" data-preset="brain">Brain</button>
        </div>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:6px;margin-top:8px;">
          <button type="button" id="btnSavePreset" class="btn"><i class="fas fa-bookmark"></i> Save</button>
          <button type="button" id="btnLoadPreset" class="btn"><i class="fas fa-list"></i> Load</button>
        </div>
      </div>
      <div class="panel">
        <h3>Measurement Units</h3>
        <div class="control">
          <label class="label" for="unitSelect"><span>Display Unit</span><span id="unitVal">mm</span></label>
          <select id="unitSelect" class="select">
            <option value="mm" selected>Millimeters (mm)</option>
            <option value="cm">Centimeters (cm)</option>
          </select>
        </div>
      </div>
      <div class="panel" id="mprMeasurePanel" style="display:none;">
        <h3>MPR Measurements</h3>
        <div class="control">
          <div class="label"><span>Plane Selection</span></div>
          <select id="mprMeasurePlane" class="select">
            <option value="auto" selected>Auto (by quadrant)</option>
            <option value="axial">Axial</option>
            <option value="sagittal">Sagittal</option>
            <option value="coronal">Coronal</option>
          </select>
        </div>
        <div class="control">
          <div class="label"><span>Measurement</span></div>
          <select id="mprMeasureType" class="select">
            <option value="distance" selected>Distance</option>
          </select>
        </div>
      </div>
      <div class="panel">
        <h3>Navigation</h3>
        <div class="control"><div class="label"><span>Slice</span><span id="sliceVal">1</span></div><input id="slice" type="range" min="0" max="0" value="0"></div>
      </div>
      <div class="panel">
        <h3>Transform</h3>
        <div class="control"><div class="label"><span>Zoom</span><span id="zoomVal">100%</span></div><input id="zoom" type="range" min="25" max="500" value="100"></div>
      </div>
      <div class="panel">
        <h3>3D Reconstruction</h3>
        <div class="control">
          <div class="label"><span>Type</span></div>
          <select id="reconType" class="select">
            <option value="mpr">MPR (Axial/Sagittal/Coronal)</option>
            <option value="mip">MIP (Max Intensity)</option>
            <option value="bone">Bone 3D (threshold)</option>
          </select>
        </div>
        <div class="control" id="boneCtrl" style="display:none;">
          <div class="label"><span>Bone Threshold (HU)</span><span id="boneVal">300</span></div>
          <input id="boneThreshold" type="range" min="100" max="1500" value="300">
        </div>
        <div class="control">
          <button type="button" id="btnGenerateRecon" class="btn-control"><i class="fas fa-cogs"></i> Generate</button>
        </div>
        <div class="muted" id="reconStatus"></div>
        <div class="row-3" id="reconViews" style="margin-top:8px; display:none;">
          <img id="viewAxial" alt="Axial" loading="lazy" decoding="async"/>
          <img id="viewSagittal" alt="Sagittal" loading="lazy" decoding="async"/>
          <img id="viewCoronal" alt="Coronal" loading="lazy" decoding="async"/>
        </div>
      </div>
      <div class="panel">
        <h3>Image Info</h3>
        <div id="dimInfo" style="color:var(--text-secondary);font-size:11px;margin-bottom:4px;">Dimensions: -</div>
        <div id="spacingInfo" style="color:var(--text-secondary);font-size:11px;margin-bottom:4px;">Pixel Spacing: -</div>
        <div id="seriesInfo" style="color:var(--text-secondary);font-size:11px;margin-bottom:4px;">Series: -</div>
        <div id="institutionInfo" style="color:var(--text-secondary);font-size:11px;margin-bottom:4px;">Institution: -</div>
        <div id="clinicalInfo" style="color:var(--text-secondary);font-size:11px; margin-top:8px; white-space:pre-wrap;padding:6px;background:var(--secondary-bg);border:1px solid var(--border-color);border-radius:4px;">Clinical Info: -</div>
        <div id="priorityInfo" style="color:var(--text-secondary);font-size:11px;margin-top:4px;">Priority: -</div>
      </div>
      <div class="panel">
        <h3>Measurements</h3>
        <div class="control">
          <button type="button" id="btnClearMeasurements" class="btn">Clear All</button>
        </div>
        <ul id="measurementsList" style="list-style:none;padding-left:0;margin:0;color:var(--text-secondary);font-size:11px;"></ul>
      </div>
    </div>
  </div>
  </div>

  <!-- Three.js for rotatable bone mesh (loaded only if used) -->
  <!-- Removed deprecated UMD scripts; using ES Modules via importmap -->
  <div id="threeContainer" role="dialog" aria-modal="true">
    <button type="button" id="close3d" class="btn">Close 3D</button>
    <div id="threeMount"></div>
  </div>
  <div id="dicomModal">
    <div  role="dialog" aria-modal="true">
      <div  role="dialog" aria-modal="true">
        <h3 style="margin:0;">DICOM Tags</h3>
        <button type="button" id="closeDicomModal" class="btn">Close</button>
      </div>
      <pre id="dicomTagsPre" style="white-space:pre-wrap; color:#ddd;"></pre>
    </div>
  </div>

  <!-- Print Modal -->
  <div id="printModal">
    <div  role="dialog" aria-modal="true">
      <div  role="dialog" aria-modal="true">
        <h3>Print DICOM Image</h3>
        <button type="button" id="closePrintModal" class="btn">Close</button>
      </div>
      <form id="printForm">
        <div class="form-group">
          <label for="printMedium">Print Medium:</label>
          <select id="printMedium" name="print_medium">
            <option value="paper">📄 Paper</option>
            <option value="film">🎞️ Medical Film</option>
          </select>
        </div>
        <div class="form-group">
          <label for="layoutType">Layout:</label>
          <select id="layoutType" name="layout_type">
            <option value="single">Single Image</option>
            <option value="quad">Quad Layout (4 images)</option>
            <option value="comparison">Side-by-Side Comparison</option>
            <option value="film_standard">Film Standard (minimal text)</option>
          </select>
          <div class="form-text" id="layoutDescription">One image per page with full details</div>
        </div>
        <div class="form-group">
          <label for="printerSelect">Printer:</label>
          <select id="printerSelect" name="printer_name">
            <option value="">Loading printers...</option>
          </select>
          <div class="form-text" id="printerHelp" style="font-size: 10px; color: var(--text-muted); margin-top: 4px;">
            🖨️ Client printers automatically detected. Server printers marked with 🖥️.
          </div>
        </div>
        <div class="form-group">
          <label for="paperSize">Paper/Film Size:</label>
          <select id="paperSize" name="paper_size">
            <option value="A4">A4 (210 × 297 mm)</option>
            <option value="Letter">Letter (8.5 × 11 in)</option>
            <option value="FILM_14X17">Film 14" × 17"</option>
            <option value="FILM_11X14">Film 11" × 14"</option>
          </select>
        </div>
        <div class="form-group" id="paperTypeGroup">
          <label for="paperType">Paper Type:</label>
          <select id="paperType" name="paper_type">
            <option value="glossy">🌟 Glossy Photo Paper</option>
            <option value="matte">Matte Paper</option>
            <option value="plain">Plain Paper</option>
            <option value="film">Medical Film</option>
          </select>
        </div>
        <div class="form-group">
          <label for="printQuality">Print Quality:</label>
          <select id="printQuality" name="print_quality">
            <option value="high">High Quality (1200 DPI)</option>
            <option value="normal">Normal Quality (600 DPI)</option>
            <option value="draft">Draft Quality (300 DPI)</option>
          </select>
        </div>
        <div class="form-group">
          <label for="copies">Number of Copies:</label>
          <input type="number" id="copies" name="copies" value="1" min="1" max="10">
        </div>
        <div class="btn-group">
          <button type="button" id="cancelPrint" class="btn">Cancel</button>
          <button type="submit" id="submitPrint" class="btn btn-primary">
            <i class="fas fa-print"></i> Print Image
          </button>
        </div>
      </form>
    </div>
  </div>

  <script>
  (function(){
    const canvas = document.getElementById('dicomCanvas');
    const ctx = canvas.getContext('2d');
    const seriesSelect = document.getElementById('seriesSelect');
    const wwSlider = document.getElementById('ww');
    const wlSlider = document.getElementById('wl');
    const wwNum = document.getElementById('wwNum');
    const wlNum = document.getElementById('wlNum');
    const sliceSlider = document.getElementById('slice');
    const zoomSlider = document.getElementById('zoom');
    const btnLoadLocal = document.getElementById('btnLoadLocal');
    const inputLocal = document.getElementById('localDicom');
    const btnClearMeasurements = document.getElementById('btnClearMeasurements');
    const measurementsList = document.getElementById('measurementsList');

    const reconType = document.getElementById('reconType');
    const boneCtrl = document.getElementById('boneCtrl');
    const boneSlider = document.getElementById('boneThreshold');
    const boneVal = document.getElementById('boneVal');
    const btnGenerateRecon = document.getElementById('btnGenerateRecon');
    const reconStatus = document.getElementById('reconStatus');
    const reconViews = document.getElementById('reconViews');
    const viewAxial = document.getElementById('viewAxial');
    const viewSagittal = document.getElementById('viewSagittal');
    const viewCoronal = document.getElementById('viewCoronal');

    // 3D dropdown controls
    const btn3D = document.getElementById('btn3D');
    const menu3D = document.getElementById('menu3D');
    
    // 3D dropdown functionality - Fixed with better state management
    if (btn3D && menu3D) {
      let dropdownOpen = false;
      
      btn3D.addEventListener('click', (e) => {
        e.stopPropagation();
        dropdownOpen = !dropdownOpen;
        menu3D.style.display = dropdownOpen ? 'flex' : 'none';
        btn3D.classList.toggle('active', dropdownOpen);
      });
      
      menu3D.addEventListener('click', (e) => {
        e.stopPropagation();
        const button = e.target.closest('button');
        if (button && button.dataset.recon) {
          const reconType = button.dataset.recon;
          try {
            generateReconstruction(reconType);
            showToast(`Starting ${reconType.toUpperCase()} reconstruction`, 'info');
          } catch (error) {
            console.error('3D reconstruction error:', error);
            showToast(`Failed to start ${reconType.toUpperCase()} reconstruction`, 'error');
          }
          dropdownOpen = false;
          menu3D.style.display = 'none';
          btn3D.classList.remove('active');
        }
      });
      
      // Close dropdown when clicking outside
      document.addEventListener('click', (e) => {
        if (!btn3D.contains(e.target) && !menu3D.contains(e.target)) {
          dropdownOpen = false;
          menu3D.style.display = 'none';
          btn3D.classList.remove('active');
        }
      });
    }
    
    // Reduce initial image decode overhead for large previews
    [viewAxial, viewSagittal, viewCoronal].forEach(img=>{ if(img){ img.loading='eager'; img.decoding='async'; }});

    // Topbar extras
    const sortSelect = document.getElementById('sortSelect');
    const btnToggleTags = document.getElementById('btnToggleTags');
    const btnShowDicom = document.getElementById('btnShowDicom');
    const btnCapture = document.getElementById('btnCapture');
    const dicomModal = document.getElementById('dicomModal');
    const dicomTagsPre = document.getElementById('dicomTagsPre');
    const closeDicomModal = document.getElementById('closeDicomModal');
    const btnSavePreset = document.getElementById('btnSavePreset');
    const btnLoadPreset = document.getElementById('btnLoadPreset');
    
    
    
    // Capture button handler - Fixed with proper error handling
    if (btnCapture) {
      btnCapture.addEventListener('click', () => {
        try {
          if (!canvas || !canvas.getContext) {
            showToast('Canvas not available for capture', 'error');
            return;
          }
          
          // Create a download link for the current canvas
          const link = document.createElement('a');
          link.download = `dicom_capture_${Date.now()}.png`;
          link.href = canvas.toDataURL('image/png', 1.0);
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          showToast('Image captured successfully', 'success');
        } catch (error) {
          console.error('Capture error:', error);
          showToast('Failed to capture image', 'error');
        }
      });
    }
    
    // Show DICOM tags button handler - Fixed with better error handling
    if (btnShowDicom) {
      btnShowDicom.addEventListener('click', async () => {
        try {
          const imageId = getCurrentImageId();
          if (!imageId) {
            showToast('No image loaded', 'error');
            return;
          }
          
          showProgressIndicator();
          const response = await fetch(`/dicom-viewer/api/image/${imageId}/data/`);
          
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }
          
          const data = await response.json();
          hideProgressIndicator();
          
          if (data && Object.keys(data).length > 0) {
            dicomTagsPre.textContent = JSON.stringify(data, null, 2);
            dicomModal.style.display = 'flex';
            showToast('DICOM tags loaded successfully', 'success');
          } else {
            showToast('No DICOM tags available', 'warning');
          }
        } catch (error) {
          hideProgressIndicator();
          console.error('DICOM tags error:', error);
          showToast(`Failed to load DICOM tags: ${error.message}`, 'error');
        }
      });
    }

    let currentStudy = null;
    let currentSeries = null;
    let images = [];
    let index = 0;
    let ww = 400, wl = 40, inverted = false, zoom = 1.0;
    let defaultWw = 400, defaultWl = 40;
    let mprMode = false;
    let mprImgs = { axial: null, sagittal: null, coronal: null };
    let reconMode = null; // 'mpr' | 'mip' | 'bone' | null
    let reconImgs = []; // ordered list of image data URLs for canvas display
    let reconIndex = 0;
    // MPR plane browsing state
    let mprScroll = { axial: 0, sagittal: 0, coronal: 0, counts: { axial: 0, sagittal: 0, coronal: 0 } };
    // Crosshair linkage across planes (x: sagittal index, y: coronal index, z: axial index)
    let mprCross = { x: null, y: null, z: null };
    let showHuProbe = false;
    let huEllipse = null;
    let activeTool = 'window';
    let isDragging = false;
    let dragStart = null;
    let panOffset = { x: 0, y: 0 };
    let measureDraft = null; // {start:{x,y}, end:{x,y}}
    let measurements = []; // persisted per image id
    let annotations = [];
    let crosshair = false;
    let measureUnit = 'mm';
    let mprMeasurements = { axial: [], sagittal: [], coronal: [] };
    let mprMeasurePlaneMode = 'auto'; // 'auto' | 'axial' | 'sagittal' | 'coronal'
    let mprMeasureType = 'distance';
    const mprImageCache = new Map(); // key: series|plane|slice|ww|wl|inv -> Promise<string>|string

    // New states
    let showTagsOverlay = false;
    let currentImageTags = null;
    let cineActive = false; let cineTimer = null; let cineFps = 12;
    let spyglass = { active:false, radius:80, factor:2.0, invert:false, isPress:false, cx:0, cy:0 };
    let mprFullPlane = null; // enlarged plane key when in MPR

    // Track last viewport mapping for precise coordinate transforms
    let lastVp = null; // {x,y,scale,imgW,imgH}
    const mprRegionVps = {}; // key-> {x,y,scale,imgW,imgH,rect}

    // Map imageId -> arrays to persist while session active
    const imageIdToMeasurements = new Map();
    const imageIdToAnnotations = new Map();

    // Image cache and render scheduler to improve responsiveness
    const imageCache = new Map(); // key -> Promise<HTMLImageElement> | HTMLImageElement
    let drawScheduled = false;
    const userCanEdit = {% if user.can_edit_reports %}true{% else %}false{% endif %};
    
    // Progress indicator functions
    function showProgressIndicator() {
      const overlay = document.createElement('div');
      overlay.id = 'progressOverlay';
      overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 9999;
      `;
      overlay.innerHTML = `
        <div style="background: var(--card-surface); padding: 20px; border-radius: 8px; text-align: center;">
          <div style="margin-bottom: 10px;">🔄 Processing...</div>
          <div style="font-size: 12px; color: var(--text-secondary);">Please wait while the reconstruction is being generated</div>
        </div>
      `;
      document.body.appendChild(overlay);
    }
    
    function hideProgressIndicator() {
      const overlay = document.getElementById('progressOverlay');
      if (overlay) {
        overlay.remove();
      }
    }
    
    // Toast notification system
    function showToast(message, type = 'info', duration = 3000) {
      const toast = document.createElement('div');
      toast.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: var(--card-surface);
        border: 1px solid var(--border-color);
        border-left: 4px solid var(--accent-color);
        color: var(--text-primary);
        padding: 8px 12px;
        border-radius: 3px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        z-index: 2000;
        font-size: 11px;
        max-width: 280px;
        transform: translateX(100%);
        transition: transform 0.3s ease;
        opacity: 0.95;
      `;
      
      if (type === 'error') {
        toast.style.borderLeftColor = 'var(--danger-color)';
      } else if (type === 'success') {
        toast.style.borderLeftColor = 'var(--success-color)';
      } else if (type === 'warning') {
        toast.style.borderLeftColor = 'var(--warning-color)';
      }
      
      toast.innerHTML = `${message}`;
      document.body.appendChild(toast);
      
      // Slide in
      setTimeout(() => {
        toast.style.transform = 'translateX(0)';
      }, 10);
      
      // Auto-remove
      setTimeout(() => {
        toast.style.transform = 'translateX(100%)';
        setTimeout(() => {
          if (toast.parentNode) {
            toast.remove();
          }
        }, 300);
      }, duration);
    }
    function requestDraw(){
      if (drawScheduled) return;
      drawScheduled = true;
      requestAnimationFrame(async ()=>{ drawScheduled = false; await draw(); });
    }
    function debounce(fn, delay){
      let t; return (...args)=>{ clearTimeout(t); t = setTimeout(()=> fn(...args), delay); };
    }
    // Cancelable overlay requests
    let overlayRequestId = 0;
    function getImageKey(imageId, ww, wl, inverted){
      return `${imageId}|${Math.round(ww)}|${Math.round(wl)}|${inverted?1:0}`;
    }
    async function loadHtmlImage(src){
      return new Promise((resolve, reject)=>{ const im = new Image(); im.crossOrigin = 'anonymous'; im.decoding = 'async'; im.onload = ()=> resolve(im); im.onerror = reject; im.src = src; });
    }
    async function getImageForIndex(i){
      const imgMeta = images[i];
      if (!imgMeta) return null;
      const key = getImageKey(imgMeta.id, ww, wl, inverted);
      if (imageCache.has(key)){
        const val = imageCache.get(key);
        return typeof val.then === 'function' ? await val : val;
      }
      const url = `/dicom-viewer/image/${imgMeta.id}/?ww=${ww}&wl=${wl}&invert=${inverted}`;
      console.log(`Loading image: ${url}`); // Debug log
      const promise = loadHtmlImage(url).then(im=>{ imageCache.set(key, im); return im; }).catch(err=>{ console.error('Image load error:', err); imageCache.delete(key); throw err; });
      imageCache.set(key, promise);
      return await promise;
    }
    function prefetchIndex(i){
      if (i < 0 || i >= images.length) return;
      const imgMeta = images[i];
      const key = getImageKey(imgMeta.id, ww, wl, inverted);
      if (imageCache.has(key)) return;
      const url = `/dicom-viewer/image/${imgMeta.id}/?ww=${ww}&wl=${wl}&invert=${inverted}`;
      const promise = loadHtmlImage(url).then(im=>{ imageCache.set(key, im); return im; }).catch(()=>{ imageCache.delete(key); });
      imageCache.set(key, promise);
    }
    function prefetchAround(center, radius=3){
      for (let o = -radius; o <= radius; o++){
        if (o === 0) continue;
        prefetchIndex(center + o);
      }
    }
    const debouncedLoadOverlaysForCurrentImage = debounce(()=>{ loadOverlaysForCurrentImage(); }, 80);
    
    async function loadOverlaysForCurrentImage() {
      const imageId = getCurrentImageId();
      if (!imageId) return;
      
      // Load measurements for current image
      const savedMeasurements = imageIdToMeasurements.get(imageId);
      if (savedMeasurements) {
        measurements = savedMeasurements;
        renderMeasurementsList();
      } else {
        measurements = [];
        renderMeasurementsList();
      }
      
      // Load annotations for current image
      const savedAnnotations = imageIdToAnnotations.get(imageId);
      if (savedAnnotations) {
        annotations = savedAnnotations;
      } else {
        annotations = [];
      }
    }

    // Helper: parse pixel spacing robustly (string "0.5\\0.5", "0.5,0.5" or array)
    function parsePixelSpacing(ps){
      if (!ps) return null;
      if (Array.isArray(ps)) return ps.map(Number);
      if (typeof ps === 'string'){
        const parts = ps.split(/[\\,\s]+/).filter(Boolean);
        if (parts.length >= 2) return [parseFloat(parts[0]), parseFloat(parts[1])];
      }
      return null;
    }

    async function fallbackToDesktop(){
      try {
        const params = new URLSearchParams(window.location.search);
        const studyId = params.get('study_id') || (currentStudy && currentStudy.id);
        if (studyId){
          const resp = await fetch(`/dicom-viewer/launch-desktop/${studyId}/`);
          const j = await resp.json();
          if (j && j.fallback_url){ window.location.href = j.fallback_url; return; }
          // Desktop launched; leave page as-is
        } else {
          const resp = await fetch('/dicom-viewer/launch-desktop/', { method:'POST', headers:{'Content-Type':'application/json'}, body: '{}' });
          const j = await resp.json();
          if (j && j.fallback_url){ window.location.href = j.fallback_url; return; }
        }
      } catch (e) {
        // swallow
      }
    }

    // Canvas sizing - Fixed with proper error handling and validation
    function setCanvasSize(){
      try {
        const vp = document.getElementById('viewport');
        if (!vp) {
          console.error('Viewport element not found');
          return;
        }
        
        const rect = vp.getBoundingClientRect();
        const newWidth = Math.max(100, Math.floor(rect.width - 20));
        const newHeight = Math.max(100, Math.floor(rect.height - 20));
        
        // Only update if dimensions actually changed to avoid unnecessary redraws
        if (canvas.width !== newWidth || canvas.height !== newHeight) {
          canvas.width = newWidth;
          canvas.height = newHeight;
          canvas.style.maxWidth = '100%';
          canvas.style.maxHeight = '100%';
          
          // Ensure canvas context is preserved
          if (!canvas.getContext) {
            console.error('Canvas context not available');
            return;
          }
          
          // Clear canvas after resize
          const ctx = canvas.getContext('2d');
          ctx.fillStyle = '#000000';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          console.log(`Canvas resized to ${newWidth}x${newHeight}`);
        }
      } catch (error) {
        console.error('Canvas resize error:', error);
      }
    }
    
    // Debounced resize handler to prevent excessive redraws
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        setCanvasSize();
        requestDraw();
      }, 100);
    });

    function q(name){ return new URLSearchParams(window.location.search).get(name); }
    
    function getCookie(name){
      const value = `; ${document.cookie}`;
      const parts = value.split(`; ${name}=`);
      if (parts.length === 2) {
        const token = parts.pop().split(';').shift();
        return token && token.trim() ? token : null;
      }
      return null;
    }

    async function loadAvailableStudies(){
      try {
        console.log('Loading available studies...');
        const r = await fetch('/dicom-viewer/web/');
        if (r.ok) {
          // This would redirect to the index page, but for now just populate series selector
          seriesSelect.innerHTML = '<option value="">Load a study first or use "Load Local DICOM"</option>';
        }
      } catch (e) {
        console.warn('Could not load available studies:', e);
        seriesSelect.innerHTML = '<option value="">Use "Load Local DICOM" to get started</option>';
      }
    }

    async function loadStudy(studyId){
      try {
        console.log(`Loading study ID: ${studyId}`);
        const r = await fetch(`/dicom-viewer/study/${studyId}/`);
        if (!r.ok) {
          console.error(`Study fetch failed: ${r.status} ${r.statusText}`);
          throw new Error(`study fetch failed: ${r.status} ${r.statusText}`);
        }
        const data = await r.json();
        console.log('Study data loaded:', data);
        currentStudy = data.study;
        // Enable write report button when study is known
        const wr = document.getElementById('btnWriteReport');
        if (wr && currentStudy && currentStudy.id){
          wr.style.display = '';
          wr.onclick = function(){ window.location.href = `/reports/write/${currentStudy.id}/`; };
        }
        // Mark study as in_progress when opened by editor roles
        try {
          if (userCanEdit && currentStudy && currentStudy.id){
            const headers = { 'Content-Type': 'application/json' };
            const csrfToken = getCookie('csrftoken');
            if (csrfToken) {
              headers['X-CSRFToken'] = csrfToken;
            }
            await fetch(`/worklist/api/study/${currentStudy.id}/update-status/`, {
              method: 'POST',
              headers: headers,
              body: JSON.stringify({ status: 'in_progress' }),
              credentials: 'same-origin'
            });
          }
        } catch (_) { /* non-blocking */ }
        // Update patient info in topbar
        const patientInfoEl = document.getElementById('patientInfo');
        if (patientInfoEl) {
          const patientName = currentStudy.patient_name || 'Unknown Patient';
          const studyDate = currentStudy.study_date || 'Unknown Date';
          const modality = currentStudy.modality || 'Unknown Modality';
          patientInfoEl.textContent = `Patient: ${patientName} | Study Date: ${studyDate} | Modality: ${modality}`;
        }
        
        // Show clinical info and priority in sidebar
        const clinicalInfoEl = document.getElementById('clinicalInfo');
        const priorityInfoEl = document.getElementById('priorityInfo');
        
        if (clinicalInfoEl) {
          const clin = (currentStudy.clinical_info && currentStudy.clinical_info.trim()) ? currentStudy.clinical_info : '-';
          clinicalInfoEl.textContent = `Clinical Info: ${clin}`;
        }
        
        if (priorityInfoEl) {
          priorityInfoEl.textContent = `Priority: ${currentStudy.priority ? currentStudy.priority.toUpperCase() : '-'}`;
        }
        
        console.log('Patient details updated:', { patientName: currentStudy.patient_name, studyDate: currentStudy.study_date, modality: currentStudy.modality });
        seriesSelect.innerHTML = '<option value="">Select Series</option>';
        (data.series_list || []).forEach(s=>{
          const opt = document.createElement('option');
          opt.value = s.id; opt.textContent = `Series ${s.series_number} - ${s.modality} (${s.image_count} images)`;
          seriesSelect.appendChild(opt);
        });
        if ((data.series_list||[]).length){
          seriesSelect.value = data.series_list[0].id;
          await loadSeries(data.series_list[0].id);
        }
        // Apply suggested hanging protocol
        try {
          const hpq = new URLSearchParams(); hpq.set('modality', currentStudy.modality||'');
          const rhp = await fetch(`/dicom-viewer/api/hanging/?${hpq.toString()}`); const hp = await rhp.json();
          if (hp && hp.suggested && hp.suggested.layout === 'mpr-3plane') { generateReconstruction('mpr'); }
        } catch(e){}
      } catch (e) {
        console.error('Study loading error:', e);
        showToast(`Failed to load study: ${e.message}`, 'error');
        // Reset to initial state
        currentStudy = null;
        currentSeries = null;
        images = [];
        seriesSelect.innerHTML = '<option value="">Study load failed - try "Load Local DICOM"</option>';
      }
    }

    async function loadSeries(seriesId){
      try {
        console.log(`Loading series ID: ${seriesId}`);
        const r = await fetch(`/dicom-viewer/series/${seriesId}/images/`);
        if (!r.ok) {
          console.error(`Series fetch failed: ${r.status} ${r.statusText}`);
          throw new Error(`series fetch failed: ${r.status} ${r.statusText}`);
        }
        const data = await r.json();
        console.log('Series data loaded:', data);
        currentSeries = data.series; images = data.images || []; index = 0;
        imageCache.clear();
        sliceSlider.max = Math.max(0, images.length - 1); sliceSlider.value = 0; document.getElementById('sliceVal').textContent = '1';
        if (images.length){
          const probe = await fetch(`/dicom-viewer/api/image/${images[0].id}/display/`);
          if (probe.ok){
            const j = await probe.json();
            if (j && j.image_info){
              ww = j.image_info.default_window_width || ww;
              wl = j.image_info.default_window_level || wl;
              defaultWw = ww; defaultWl = wl;
              if (j.windowing && typeof j.windowing.inverted === 'boolean') { inverted = j.windowing.inverted; }
            }
          }
          wwSlider.value = Math.round(ww); wlSlider.value = Math.round(wl); wwNum.value = Math.round(ww); wlNum.value = Math.round(wl); document.getElementById('wwVal').textContent = Math.round(ww); document.getElementById('wlVal').textContent = Math.round(wl);
        }
        // Reset view state
        zoom = 1.0; panOffset = {x:0,y:0}; activeTool = 'window'; crosshair = false; mprMode = false; mprImgs = {axial:null,sagittal:null,coronal:null}; reconMode = null; reconImgs = []; reconIndex = 0;
        mprCross = { x: null, y: null, z: null }; // reset crosshair linkage
        mprMeasurements = { axial: [], sagittal: [], coronal: [] };
        mprImageCache.clear();
        const enterMpr = document.getElementById('btnEnterMpr');
        const exitMpr = document.getElementById('btnExitMpr');
        if (enterMpr) enterMpr.style.display = images.length ? '' : 'none';
        if (exitMpr) exitMpr.style.display = 'none';
        document.querySelectorAll('.tool').forEach(x=>x.classList.remove('active'));
        document.querySelector('.tool[data-tool="window"]').classList.add('active');
        setCanvasSize();
        await draw();
        await loadOverlaysForCurrentImage();
        // Prefetch neighbors
        prefetchAround(0, 3);
        // Warm up MPR mid-slices so first MPR is instant
        try { warmupMpr(); } catch(e) {}
      } catch (e) {
        console.error('Series loading error:', e);
        showToast(`Failed to load series: ${e.message}`, 'error');
        // Reset series state
        currentSeries = null;
        images = [];
        seriesSelect.innerHTML = '<option value="">Series load failed</option>';
      }
    }

    function getCurrentImageId(){
      if (!images.length) return null;
      return images[index].id;
    }

    function getViewportPlacement(imgW, imgH){
      const scale = Math.min(canvas.width / imgW, canvas.height / imgH) * zoom;
      const w = imgW * scale, h = imgH * scale;
      const x = (canvas.width - w)/2 + panOffset.x;
      const y = (canvas.height - h)/2 + panOffset.y;
      return { scale, w, h, x, y };
    }

    async function draw(){
      if (!images.length && reconImgs.length===0) { ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height); return; }
      if (mprMode){
        try{
          // Enlarge one plane if set
          if (mprFullPlane){
            // Ensure image for that plane is current
            if (!mprImgs[mprFullPlane]){
              try {
                const img = await getMprImage(currentSeries.id, mprFullPlane, mprScroll[mprFullPlane] || 0);
                mprImgs[mprFullPlane] = img;
              } catch(e){}
            }
            ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
            const imgSrc = mprImgs[mprFullPlane];
            if (imgSrc){
              try {
                const im = await loadImage(imgSrc);
                const scale = Math.min(canvas.width / im.width, canvas.height / im.height);
                const dw = im.width * scale, dh = im.height * scale;
                const dx = (canvas.width - dw)/2, dy = (canvas.height - dh)/2;
                if (ctx.imageSmoothingEnabled !== false) ctx.imageSmoothingEnabled = false; 
                ctx.drawImage(im, dx, dy, dw, dh);
                mprRegionVps[mprFullPlane] = { x: dx, y: dy, scale: scale, imgW: im.width, imgH: im.height, rect: {x:0,y:0,w:canvas.width,h:canvas.height} };
                if (huEllipse && huEllipse.mode==='mpr' && huEllipse.plane===mprFullPlane){ drawEllipseOverlay(mprFullPlane); }
                // Draw linked crosshair on enlarged plane (only if enabled)
                if (crosshair) { drawMprCrosshairOverlay(mprFullPlane, dx, dy, scale, im.width, im.height); }
              } catch (e) {
                console.error(`Failed to load full plane ${mprFullPlane} image:`, e);
                // Draw placeholder
                ctx.save();
                ctx.fillStyle = '#333';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#666';
                ctx.font = '24px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('Loading 3D View...', canvas.width/2, canvas.height/2);
                ctx.restore();
              }
            }
            document.getElementById('overlay').innerHTML = `MPR (${mprFullPlane.toUpperCase()}) | WW: ${Math.round(ww)}<br>WL: ${Math.round(wl)}`;
            document.getElementById('zoominfo').textContent = `MPR`;
            return;
          }
          // Ensure counts and initial mid-slice indices are loaded
          if (!mprImgs.axial || !mprImgs.sagittal || !mprImgs.coronal){
            const params = new URLSearchParams(); params.set('window_width', ww); params.set('window_level', wl); params.set('inverted', inverted);
            const r = await fetch(`/dicom-viewer/api/series/${currentSeries.id}/mpr/?${params.toString()}`);
            const j = await r.json();
            if (j && j.mpr_views){ mprImgs = j.mpr_views; }
            if (j && j.counts){
              mprScroll.counts = j.counts;
              mprScroll.axial = Math.floor((j.counts.axial||0)/2);
              mprScroll.sagittal = Math.floor((j.counts.sagittal||0)/2);
              mprScroll.coronal = Math.floor((j.counts.coronal||0)/2);
              if (mprCross.x === null || mprCross.y === null || mprCross.z === null){
                mprCross = {
                  x: mprScroll.sagittal,
                  y: mprScroll.coronal,
                  z: mprScroll.axial
                };
              }
              // Immediately request exact mid slices for all planes
              await Promise.all([
                getMprImage(currentSeries.id, 'axial', mprScroll.axial).then(img=>{ mprImgs.axial = img; }).catch(err=>{ console.error('Failed to load axial MPR image:', err); }),
                getMprImage(currentSeries.id, 'sagittal', mprScroll.sagittal).then(img=>{ mprImgs.sagittal = img; }).catch(err=>{ console.error('Failed to load sagittal MPR image:', err); }),
                getMprImage(currentSeries.id, 'coronal', mprScroll.coronal).then(img=>{ mprImgs.coronal = img; }).catch(err=>{ console.error('Failed to load coronal MPR image:', err); })
              ]);
              prefetchMprSlices('axial', mprScroll.axial);
              prefetchMprSlices('sagittal', mprScroll.sagittal);
              prefetchMprSlices('coronal', mprScroll.coronal);
            }
          }
          ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
          const halfW = Math.floor(canvas.width/2), halfH = Math.floor(canvas.height/2);
          const regions = [
            { x: 0, y: 0, w: halfW, h: halfH, key: 'sagittal' },
            { x: halfW, y: 0, w: canvas.width - halfW, h: halfH, key: 'coronal' },
            { x: 0, y: halfH, w: halfW, h: canvas.height - halfH, key: 'axial' },
            { x: halfW, y: halfH, w: canvas.width - halfW, h: canvas.height - halfH, key: 'empty' },
          ];
          // Crosshair dividing lines
          ctx.save();
          ctx.strokeStyle = 'rgba(0,255,255,0.8)';
          ctx.beginPath();
          ctx.moveTo(halfW, 0); ctx.lineTo(halfW, canvas.height);
          ctx.moveTo(0, halfH); ctx.lineTo(canvas.width, halfH);
          ctx.stroke();
          ctx.restore();
          // Draw regions using available images immediately, then refresh asynchronously
          for (const reg of regions){
            if (reg.key === 'empty') continue;
            const imgSrc = mprImgs[reg.key];
            if (imgSrc){
              try {
                const im = await loadImage(imgSrc);
                if (im && im.width > 0 && im.height > 0) {
                  const scale = Math.min(reg.w / im.width, reg.h / im.height);
                  const dw = im.width * scale, dh = im.height * scale;
                  const dx = reg.x + (reg.w - dw)/2, dy = reg.y + (reg.h - dh)/2;
                  
                  // Apply windowing for better contrast and enhanced clarity
                  ctx.save();
                  ctx.imageSmoothingEnabled = true; // Enable smoothing for better image quality
                  ctx.imageSmoothingQuality = 'high';
                  
                  // Apply image enhancement for clarity
                  ctx.filter = 'contrast(1.1) brightness(1.05)';
                  
                  ctx.drawImage(im, dx, dy, dw, dh);
                  
                  // Save mapping for tools
                  mprRegionVps[reg.key] = { x: dx, y: dy, scale: scale, imgW: im.width, imgH: im.height, rect: reg };
                  ctx.restore();
                } else {
                  throw new Error('Invalid image dimensions');
                }
              } catch (e) {
                console.error(`Failed to load ${reg.key} image:`, e);
                // Draw placeholder for failed image but keep trying
                ctx.save();
                ctx.fillStyle = '#333';
                ctx.fillRect(reg.x, reg.y, reg.w, reg.h);
                ctx.fillStyle = '#666';
                ctx.font = '14px Arial, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(`${reg.key.toUpperCase()}`, reg.x + reg.w/2, reg.y + reg.h/2 - 10);
                ctx.fillText('Loading...', reg.x + reg.w/2, reg.y + reg.h/2 + 10);
                ctx.restore();
                
                // Retry loading after a short delay
                setTimeout(() => {
                  console.log(`Retrying load for ${reg.key}...`);
                  requestDraw();
                }, 1000);
              }
              // Draw plane label and slice index (use region coordinates if image failed)
              const labelX = (mprRegionVps[reg.key] ? mprRegionVps[reg.key].x : reg.x) + 8;
              const labelY = (mprRegionVps[reg.key] ? mprRegionVps[reg.key].y : reg.y) + 8;
              ctx.save();
              ctx.fillStyle = 'rgba(0,0,0,0.5)';
              ctx.fillRect(labelX, labelY, 180, 22);
              ctx.fillStyle = '#0ff';
              ctx.font = '12px monospace';
              // Enhanced plane label with crosshair coordinates
              const crossInfo = `${reg.key.toUpperCase()} ${ (mprScroll[reg.key]||0) + 1 }/${ mprScroll.counts[reg.key]||0 }`;
              let coordInfo = '';
              if (mprCross.x !== null && mprCross.y !== null && mprCross.z !== null) {
                if (reg.key === 'axial') coordInfo = ` [${mprCross.x},${mprCross.y}]`;
                else if (reg.key === 'sagittal') coordInfo = ` [${mprCross.y},${mprCross.z}]`;
                else if (reg.key === 'coronal') coordInfo = ` [${mprCross.x},${mprCross.z}]`;
              }
              ctx.fillText(crossInfo + coordInfo, labelX + 4, labelY + 16);
              ctx.restore();
              // Draw measurement overlays for this plane
              ctx.save();
              ctx.strokeStyle = 'yellow'; ctx.fillStyle = 'yellow'; ctx.lineWidth = 2;
              const planeMeasures = mprMeasurements[reg.key] || [];
              if (mprRegionVps[reg.key]) {
                const vp = mprRegionVps[reg.key];
                for (const m of planeMeasures){
                  const x1 = vp.x + m.start.x * vp.scale, y1 = vp.y + m.start.y * vp.scale;
                  const x2 = vp.x + m.end.x * vp.scale, y2 = vp.y + m.end.y * vp.scale;
                  ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
                  if (m.label){ ctx.font='12px monospace'; ctx.fillText(m.label, x2 + 6, y2 - 6); }
                }
                // Draft line if belongs to this plane
                if (measureDraft && measureDraft.plane === reg.key && measureDraft.start && measureDraft.end){
                  const x1 = vp.x + measureDraft.start.x * vp.scale, y1 = vp.y + measureDraft.start.y * vp.scale;
                  const x2 = vp.x + measureDraft.end.x * vp.scale, y2 = vp.y + measureDraft.end.y * vp.scale;
                  ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
                }
              }
              ctx.restore();
              // Draw HU ellipse overlay if belongs to this plane
              if (huEllipse && huEllipse.mode==='mpr' && huEllipse.plane===reg.key){
                drawEllipseOverlay(reg.key);
              }
              // Draw linked crosshair overlay for this plane (only if enabled)
              if (crosshair && mprRegionVps[reg.key]) { 
                const vp = mprRegionVps[reg.key];
                drawMprCrosshairOverlay(reg.key, vp.x, vp.y, vp.scale, vp.imgW, vp.imgH); 
              }
            }
            // Fetch updated slice without blocking draw
            (async ()=>{
              try {
                const img = await getMprImage(currentSeries.id, reg.key, mprScroll[reg.key] || 0);
                mprImgs[reg.key] = img; requestAnimationFrame(()=>draw());
              } catch(e){ console.error('Failed to load MPR image for plane', reg.key, ':', e); }
            })();
          }
          document.getElementById('overlay').innerHTML = `MPR | WW: ${Math.round(ww)}<br>WL: ${Math.round(wl)}`;
          document.getElementById('zoominfo').textContent = `MPR`;
          return;
        } catch(e){ /* fallback to normal draw below */ }
      }
      if (reconMode && reconImgs.length){
        try {
          console.log(`Drawing reconstruction mode: ${reconMode}, images: ${reconImgs.length}`);
          ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
          if (reconMode === 'mip' || reconMode === 'bone'){
            console.log(`Drawing 3-plane ${reconMode} reconstruction`);
            // Draw 3-plane grid similar to MPR using the three recon previews
            const imgs = [];
            for (let i=0;i<3;i++){ 
              if (reconImgs[i]) { 
                try { 
                  imgs[i] = await loadImage(reconImgs[i]); 
                  console.log(`Loaded image ${i}: ${imgs[i].width}x${imgs[i].height}`);
                } catch(e){ 
                  console.error(`Failed to load image ${i}:`, e);
                  imgs[i] = null; 
                } 
              } else {
                console.warn(`No image data for index ${i}`);
              }
            }
            const halfW = Math.floor(canvas.width/2), halfH = Math.floor(canvas.height/2);
            const regions = [
              { x: 0, y: 0, w: halfW, h: halfH, key: 'sagittal', im: imgs[1] },
              { x: halfW, y: 0, w: canvas.width - halfW, h: halfH, key: 'coronal', im: imgs[2] },
              { x: 0, y: halfH, w: halfW, h: canvas.height - halfH, key: 'axial', im: imgs[0] },
              { x: halfW, y: halfH, w: canvas.width - halfW, h: canvas.height - halfH, key: 'empty', im: null },
            ];
            // Crosshair dividing lines
            ctx.save(); ctx.strokeStyle = 'rgba(0,255,255,0.8)'; ctx.beginPath(); ctx.moveTo(halfW, 0); ctx.lineTo(halfW, canvas.height); ctx.moveTo(0, halfH); ctx.lineTo(canvas.width, halfH); ctx.stroke(); ctx.restore();
            for (const reg of regions){
              if (!reg.im) continue;
              const im = reg.im;
              const scale = Math.min(reg.w / im.width, reg.h / im.height);
              const dw = im.width * scale, dh = im.height * scale;
              const dx = reg.x + (reg.w - dw)/2 + panOffset.x; const dy = reg.y + (reg.h - dh)/2 + panOffset.y;
              ctx.imageSmoothingEnabled = false;
              ctx.drawImage(im, dx, dy, dw, dh);
              // Label
              ctx.save(); ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(dx + 8, dy + 8, 150, 22); ctx.fillStyle = '#0ff'; ctx.font = '12px monospace'; ctx.fillText(`${reg.key.toUpperCase()}`, dx + 12, dy + 24); ctx.restore();
            }
            document.getElementById('overlay').innerHTML = `${reconMode.toUpperCase()} | 3-Plane`;
            document.getElementById('zoominfo').textContent = `${reconMode.toUpperCase()}`;
            return;
          } else {
            const im = await loadImage(reconImgs[reconIndex]);
            const scale = Math.min(canvas.width / im.width, canvas.height / im.height) * zoom;
            const dw = im.width * scale, dh = im.height * scale;
            const dx = (canvas.width - dw)/2 + panOffset.x; const dy = (canvas.height - dh)/2 + panOffset.y;
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(im, dx, dy, dw, dh);
            lastVp = { x: dx, y: dy, scale: scale, imgW: im.width, imgH: im.height };
            document.getElementById('overlay').innerHTML = `${reconMode.toUpperCase()} | View ${reconIndex+1}/${reconImgs.length}`;
            document.getElementById('zoominfo').textContent = `Zoom: ${Math.round(zoom*100)}%`;
            return;
          }
        } catch(e){}
      }
      try {
        const htmlImg = await getImageForIndex(index);
        const vp = getViewportPlacement(htmlImg.width, htmlImg.height);
        ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
        
        // Enhanced image rendering for clarity
        ctx.save();
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        ctx.filter = 'contrast(1.05) brightness(1.02)';
        
        ctx.drawImage(htmlImg, vp.x, vp.y, vp.w, vp.h);
        ctx.restore();
        lastVp = { x: vp.x, y: vp.y, scale: vp.scale, imgW: htmlImg.width, imgH: htmlImg.height };
        drawOverlays(vp);
        if (huEllipse && huEllipse.mode==='series') drawEllipseOverlay();
        // Spyglass lens on top
        if (spyglass.active && spyglass.isPress && lastVp){
          ctx.save();
          const r = Math.max(20, spyglass.radius);
          // Clip circle
          ctx.beginPath(); ctx.arc(spyglass.cx, spyglass.cy, r, 0, Math.PI*2); ctx.clip();
          // Compute anchor image coords under cursor
          const imgPt = canvasToImageCoords(lastVp, spyglass.cx, spyglass.cy);
          const factor = Math.max(1.2, spyglass.factor);
          const scale2 = lastVp.scale * factor;
          const dw2 = lastVp.imgW * scale2, dh2 = lastVp.imgH * scale2;
          const dx2 = spyglass.cx - (imgPt.x * scale2);
          const dy2 = spyglass.cy - (imgPt.y * scale2);
          ctx.imageSmoothingEnabled = false;
          ctx.drawImage(htmlImg, dx2, dy2, dw2, dh2);
          if (spyglass.invert){
            // Invert only inside lens
            const imgData = ctx.getImageData(spyglass.cx - r, spyglass.cy - r, r*2, r*2);
            const d = imgData.data; for (let i=0;i<d.length;i+=4){ d[i]=255-d[i]; d[i+1]=255-d[i+1]; d[i+2]=255-d[i+2]; }
            ctx.putImageData(imgData, spyglass.cx - r, spyglass.cy - r);
          }
          ctx.restore();
          // Lens ring and info
          ctx.save(); ctx.strokeStyle = '#0ff'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(spyglass.cx, spyglass.cy, r, 0, Math.PI*2); ctx.stroke(); ctx.restore();
          document.getElementById('overlay').innerHTML = `WW: ${Math.round(ww)}<br>WL: ${Math.round(wl)}<br>Slice: ${index+1}/${images.length}<br>Spyglass x:${Math.round(imgPt.x)} y:${Math.round(imgPt.y)} mag:${factor.toFixed(1)}x`;
        }
        if (showTagsOverlay && currentImageTags){
          const lines = [];
          const t = currentImageTags;
          if (t.patient_name) lines.push(`Patient: ${t.patient_name}`);
          if (t.study_date) lines.push(`Study: ${t.study_date}`);
          if (t.series_number !== undefined) lines.push(`Series#: ${t.series_number}`);
          if (images[index] && images[index].instance_number !== undefined) lines.push(`Instance#: ${images[index].instance_number}`);
          if (t.slice_thickness) lines.push(`Slice Thk: ${t.slice_thickness}`);
          if (t.pixel_spacing) lines.push(`Pix Spacing: ${t.pixel_spacing}`);
          ctx.save();
          ctx.fillStyle = 'rgba(0,0,0,0.6)';
          ctx.fillRect(canvas.width - 260, 12, 248, lines.length*16 + 10);
          ctx.fillStyle = '#ddd'; ctx.font = '12px monospace';
          lines.forEach((ln, i)=> ctx.fillText(ln, canvas.width - 250, 28 + i*16));
          ctx.restore();
        }
        document.getElementById('overlay').innerHTML = `WW: ${Math.round(ww)}<br>WL: ${Math.round(wl)}<br>Slice: ${index+1}/${images.length}`;
        document.getElementById('zoominfo').textContent = `Zoom: ${Math.round(zoom*100)}%`;
        // Opportunistically prefetch neighbors
        prefetchAround(index, 3);
      } catch (e) {
        await fallbackToDesktop();
      }
    }

    function drawMprCrosshairOverlay(planeKey, dx, dy, scale, imgW, imgH){
      if (mprCross.x === null || mprCross.y === null || mprCross.z === null) return;
      
      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,0,0.9)';
      ctx.lineWidth = 1;
      
      // Optimized crosshair drawing - ensure coordinates are valid
      if (planeKey === 'axial'){
        const cx = dx + Math.max(0, Math.min(imgW - 1, mprCross.x)) * scale;
        const cy = dy + Math.max(0, Math.min(imgH - 1, mprCross.y)) * scale;
        ctx.beginPath();
        ctx.moveTo(cx, dy); 
        ctx.lineTo(cx, dy + imgH * scale);
        ctx.moveTo(dx, cy); 
        ctx.lineTo(dx + imgW * scale, cy);
        ctx.stroke();
      } else if (planeKey === 'sagittal'){
        // sagittal image axes: x=height(y), y=depth(z)
        const cx = dx + Math.max(0, Math.min(imgW - 1, mprCross.y)) * scale;
        const cy = dy + Math.max(0, Math.min(imgH - 1, mprCross.z)) * scale;
        ctx.beginPath();
        ctx.moveTo(cx, dy); 
        ctx.lineTo(cx, dy + imgH * scale);
        ctx.moveTo(dx, cy); 
        ctx.lineTo(dx + imgW * scale, cy);
        ctx.stroke();
      } else if (planeKey === 'coronal'){
        // coronal image axes: x=width(x), y=depth(z)
        const cx = dx + Math.max(0, Math.min(imgW - 1, mprCross.x)) * scale;
        const cy = dy + Math.max(0, Math.min(imgH - 1, mprCross.z)) * scale;
        ctx.beginPath();
        ctx.moveTo(cx, dy); 
        ctx.lineTo(cx, dy + imgH * scale);
        ctx.moveTo(dx, cy); 
        ctx.lineTo(dx + imgW * scale, cy);
        ctx.stroke();
      }
      ctx.restore();
    }

    function drawOverlays(vp){
      // Measurements (draft first)
      ctx.save();
      ctx.strokeStyle = 'yellow';
      ctx.fillStyle = 'yellow';
      ctx.lineWidth = 2;
      const toCanvas = (p)=>({
        x: vp.x + p.x * vp.scale,
        y: vp.y + p.y * vp.scale,
      });
      const drawLine = (a,b)=>{
        const A = toCanvas(a), B = toCanvas(b);
        ctx.beginPath(); ctx.moveTo(A.x, A.y); ctx.lineTo(B.x, B.y); ctx.stroke();
      };
      const drawText = (p, text)=>{
        const P = toCanvas(p);
        ctx.font = '12px monospace';
        ctx.fillStyle = 'yellow';
        ctx.fillText(text, P.x + 6, P.y - 6);
      };
      if (measureDraft && measureDraft.start && measureDraft.end){
        drawLine(measureDraft.start, measureDraft.end);
      }
      measurements.forEach(m=>{ drawLine(m.start, m.end); if (m.label) drawText(m.end, m.label); });
      // Annotations
      annotations.forEach(a=>{ drawText(a.pos, a.text); });
      // Crosshair
      if (crosshair){
        ctx.strokeStyle = 'rgba(0,255,255,0.8)';
        ctx.beginPath();
        ctx.moveTo(canvas.width/2, 0); ctx.lineTo(canvas.width/2, canvas.height);
        ctx.moveTo(0, canvas.height/2); ctx.lineTo(canvas.width, canvas.height/2);
        ctx.stroke();
      }
      ctx.restore();
    }

    function drawEllipseOverlay(planeKey){
      if (!huEllipse) return;
      ctx.save();
      
      let mapping;
      if (huEllipse && huEllipse.mode==='mpr'){
        mapping = mprRegionVps[planeKey||huEllipse.plane];
      } else {
        mapping = lastVp;
      }
      if (!mapping) { ctx.restore(); return; }
      
      const { x, y, scale } = mapping;
      const cx = x + huEllipse.cx * scale;
      const cy = y + huEllipse.cy * scale;
      const rx = Math.max(2, Math.abs(huEllipse.rx * scale)); // Minimum 2px radius
      const ry = Math.max(2, Math.abs(huEllipse.ry * scale)); // Minimum 2px radius
      
      // Draw ellipse with enhanced visibility
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#00ff88';
      ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
      ctx.shadowBlur = 3;
      
      ctx.beginPath();
      ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI*2);
      ctx.stroke();
      
      // Draw center crosshair
      ctx.shadowBlur = 0;
      ctx.strokeStyle = '#ffff00';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(cx - 5, cy);
      ctx.lineTo(cx + 5, cy);
      ctx.moveTo(cx, cy - 5);
      ctx.lineTo(cx, cy + 5);
      ctx.stroke();
      
      // Draw resize handles if ellipse is large enough
      if (rx > 10 || ry > 10) {
        ctx.fillStyle = '#00ff88';
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 1;
        
        // Right handle
        ctx.beginPath();
        ctx.arc(cx + rx, cy, 3, 0, Math.PI*2);
        ctx.fill();
        ctx.stroke();
        
        // Bottom handle
        ctx.beginPath();
        ctx.arc(cx, cy + ry, 3, 0, Math.PI*2);
        ctx.fill();
        ctx.stroke();
      }
      
      ctx.restore();
    }

    function canvasToImageCoords(vp, cx, cy){
      const x = (cx - vp.x) / vp.scale;
      const y = (cy - vp.y) / vp.scale;
      return { x, y };
    }

    function imageDistance(a, b){
      const dx = b.x - a.x, dy = b.y - a.y;
      const px = Math.sqrt(dx*dx + dy*dy);
      const spacing = parsePixelSpacing(currentSeries && currentSeries.pixel_spacing);
      if (spacing && spacing.length >= 2 && isFinite(spacing[0]) && isFinite(spacing[1])){
        const mm = Math.sqrt((dx*spacing[0])**2 + (dy*spacing[1])**2);
        const value = (measureUnit === 'cm') ? (mm/10.0) : mm;
        const unit = (measureUnit === 'cm') ? 'cm' : 'mm';
        return { px, mm, value, unit };
      }
      return { px, mm: null, value: px, unit: 'px' };
    }

    function mprImageDistance(planeKey, a, b){
      const dx = b.x - a.x, dy = b.y - a.y;
      const px = Math.sqrt(dx*dx + dy*dy);
      const ps = parsePixelSpacing(currentSeries && currentSeries.pixel_spacing) || [1,1];
      const st = (currentSeries && +currentSeries.slice_thickness) || 1.0;
      let sx = 1.0, sy = 1.0;
      if (planeKey === 'axial') { sx = ps[0]; sy = ps[1]; }
      else if (planeKey === 'sagittal') { sx = ps[0]; sy = st; }
      else if (planeKey === 'coronal') { sx = ps[1]; sy = st; }
      const mm = Math.sqrt((dx*sx)**2 + (dy*sy)**2);
      const value = (measureUnit === 'cm') ? (mm/10.0) : mm;
      const unit = (measureUnit === 'cm') ? 'cm' : 'mm';
      return { px, mm, value, unit };
    }

    async function saveMeasurementToServer(m){
      const imageId = getCurrentImageId();
      if (!imageId) return;
      const dist = imageDistance(m.start, m.end);
      const payload = {
        image_id: imageId,
        type: 'distance',
        points: [m.start, m.end],
        value: (dist.mm ? (measureUnit==='cm' ? (dist.mm/10.0) : dist.mm) : dist.px),
        unit: (dist.mm ? measureUnit : 'px'),
        notes: ''
      };
      try {
        const r = await fetch('/dicom-viewer/measurements/save/', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
        const j = await r.json();
        if (j && j.success){
          if (dist.mm){
            const mm = dist.mm; const cm = mm/10.0;
            m.label = (measureUnit==='cm') ? `${cm.toFixed(2)} cm` : `${mm.toFixed(2)} mm`;
          } else { m.label = `${dist.px.toFixed(1)} px`; }
        }
      } catch(e){}
    }

    async function saveAnnotationToServer(p, text){
      const imageId = getCurrentImageId();
      if (!imageId) return;
      try {
        await fetch('/dicom-viewer/annotations/save/', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ image_id: imageId, position_x: p.x, position_y: p.y, text }) });
      } catch(e){}
    }

    async function loadOverlaysForCurrentImage(){
      const reqId = ++overlayRequestId;
      const imageId = getCurrentImageId();
      if (!imageId) return;
      const tasks = [];
      if (imageIdToMeasurements.has(imageId)) {
        measurements = imageIdToMeasurements.get(imageId);
      } else {
        tasks.push(
          (async ()=>{
            try {
              const r = await fetch(`/dicom-viewer/measurements/${imageId}/`); const j = await r.json();
              measurements = (j.measurements||[]).map(m=>({ start: m.points[0], end: m.points[1], label: m.unit==='mm' ? `${(+m.value).toFixed(2)} mm` : `${(+m.value).toFixed(1)} px` }));
              imageIdToMeasurements.set(imageId, measurements);
            } catch(e){ measurements = []; }
          })()
        );
      }
      if (imageIdToAnnotations.has(imageId)) {
        annotations = imageIdToAnnotations.get(imageId);
      } else {
        tasks.push(
          (async ()=>{
            try {
              const r = await fetch(`/dicom-viewer/annotations/${imageId}/`); const j = await r.json();
              annotations = (j.annotations||[]).map(a=>({ pos: {x:a.position_x, y:a.position_y}, text: a.text }));
              imageIdToAnnotations.set(imageId, annotations);
            } catch(e){ annotations = []; }
          })()
        );
      }
      if (showTagsOverlay){
        tasks.push(
          (async ()=>{
            try {
              const r = await fetch(`/dicom-viewer/api/image/${imageId}/data/`); const j = await r.json();
              currentImageTags = {
                patient_name: j.patient_name || j.image_info?.patient_name,
                study_date: j.study_date || j.image_info?.study_date,
                series_number: j.series?.series_number ?? j.series_number,
                slice_thickness: j.series?.slice_thickness ?? j.slice_thickness,
                pixel_spacing: j.series?.pixel_spacing ?? j.pixel_spacing
              };
            } catch(e){ currentImageTags = null; }
          })()
        );
      } else {
        currentImageTags = null;
      }
      if (tasks.length) { try { await Promise.all(tasks); } catch(e){} }
      // If a newer overlay request superseded this one or image changed, skip applying
      if (reqId !== overlayRequestId || imageId !== getCurrentImageId()) return;
      renderMeasurementsList();
      requestDraw();
    }

    function renderMeasurementsList(){
      measurementsList.innerHTML = '';
      measurements.forEach((m, i)=>{
        const li = document.createElement('li');
        li.style.cssText = 'margin-bottom: 8px; padding: 4px; background: var(--secondary-bg); border-radius: 4px; display: flex; justify-content: space-between; align-items: center;';
        li.innerHTML = `
          <span style="font-size: 10px; color: var(--text-secondary);">${m.label || `Measurement ${i + 1}`}</span>
          <button type="button" class="remove-measurement-btn" data-index="${i}" style="background: var(--danger-color); color: white; border: none; padding: 2px 6px; border-radius: 2px; font-size: 9px; cursor: pointer;">Remove</button>
        `;
        measurementsList.appendChild(li);
      });
      
      // Add event listeners for remove buttons
      document.querySelectorAll('.remove-measurement-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const index = parseInt(e.target.dataset.index);
          measurements.splice(index, 1);
          imageIdToMeasurements.set(getCurrentImageId(), measurements);
          renderMeasurementsList();
          requestDraw();
        });
      });
    }

    // UI wiring
    seriesSelect.addEventListener('change', e=>{ if(e.target.value) loadSeries(e.target.value); });
    wwSlider.addEventListener('input', e=>{ ww = +e.target.value; wwNum.value = Math.round(ww); document.getElementById('wwVal').textContent = ww; imageCache.clear(); mprImageCache.clear(); mprImgs = { axial:null, sagittal:null, coronal:null }; requestDraw(); });
    wlSlider.addEventListener('input', e=>{ wl = +e.target.value; wlNum.value = Math.round(wl); document.getElementById('wlVal').textContent = wl; imageCache.clear(); mprImageCache.clear(); mprImgs = { axial:null, sagittal:null, coronal:null }; requestDraw(); });
    sliceSlider.addEventListener('input', e=>{ index = +e.target.value; document.getElementById('sliceVal').textContent = index+1; requestDraw(); debouncedLoadOverlaysForCurrentImage(); prefetchAround(index, 3); });
    zoomSlider.addEventListener('input', e=>{ zoom = (+e.target.value)/100; document.getElementById('zoomVal').textContent = `${e.target.value}%`; requestDraw(); });
    // Window/Level preset buttons - Fixed with enhanced functionality and feedback
    document.querySelectorAll('[data-preset]').forEach(btn => {
      btn.addEventListener('click', () => {
        try {
          const preset = btn.getAttribute('data-preset');
          const presetMap = {
            lung: { ww: 1500, wl: -600, name: 'Lung' },
            bone: { ww: 2000, wl: 300, name: 'Bone' },
            soft: { ww: 400, wl: 40, name: 'Soft Tissue' },
            brain: { ww: 100, wl: 50, name: 'Brain' }
          };
          
          const presetData = presetMap[preset];
          if (!presetData) {
            showToast('Invalid window/level preset', 'error');
            return;
          }
          
          // Apply preset values
          ww = presetData.ww;
          wl = presetData.wl;
          
          // Update UI controls
          wwSlider.value = ww;
          wlSlider.value = wl;
          wwNum.value = Math.round(ww);
          wlNum.value = Math.round(wl);
          document.getElementById('wwVal').textContent = ww;
          document.getElementById('wlVal').textContent = wl;
          
          // Clear caches and redraw
          imageCache.clear();
          mprImageCache.clear();
          mprImgs = { axial: null, sagittal: null, coronal: null };
          requestDraw();
          
          // Provide user feedback
          showToast(`${presetData.name} preset applied (WW: ${ww}, WL: ${wl})`, 'success', 2000);
          
          // Highlight the selected preset button temporarily
          btn.style.background = 'var(--success-color)';
          btn.style.color = 'var(--primary-bg)';
          setTimeout(() => {
            btn.style.background = '';
            btn.style.color = '';
          }, 1000);
          
        } catch (error) {
          console.error('Preset button error:', error);
          showToast(`Failed to apply preset: ${error.message}`, 'error');
        }
      });
    });
    
    // Enhanced tool button handlers with comprehensive functionality
    function initializeToolButtons() {
      const toolButtons = document.querySelectorAll('.tool[data-tool]');
      
      toolButtons.forEach(button => {
        button.addEventListener('click', function(e) {
          e.preventDefault();
          e.stopPropagation();
          
          const tool = this.getAttribute('data-tool');
          if (!tool) return;
          
          // Handle tool activation
          handleToolAction(tool, this);
        });
      });
    }
    
    function handleToolAction(tool, button) {
      try {
        // Action tools that don't change the active state
        const actionTools = ['invert', 'reset', 'fit', 'one', 'reload', 'align-center'];
        
        // Toggle tools that maintain their own state
        const toggleTools = ['cine', 'crosshair', 'spyglass'];
        
        // State-changing tools
        const stateTools = ['window', 'zoom', 'pan', 'measure', 'annotate', 'hu'];
        
        if (actionTools.includes(tool)) {
          // Execute action without changing active tool
          executeToolAction(tool);
        } else if (toggleTools.includes(tool)) {
          // Toggle the tool state
          executeToggleTool(tool, button);
        } else if (stateTools.includes(tool)) {
          // Change active tool
          document.querySelectorAll('.tool').forEach(t => t.classList.remove('active'));
          button.classList.add('active');
          activeTool = tool;
          
          // Special handling for specific tools
          if (tool === 'hu') {
            showHuProbe = true;
          } else {
            showHuProbe = false;
          }
          
          // Clear any temporary states
          measureDraft = null;
          spyglass.isPress = false;
          
          showToast(`${tool.charAt(0).toUpperCase() + tool.slice(1)} tool selected`, 'info', 1000);
        } else if (tool === 'ai') {
          showAiAnalysis();
        }
        
        requestDraw();
      } catch (error) {
        console.error(`Tool action error for ${tool}:`, error);
        showToast(`Error: ${error.message}`, 'error');
      }
    }
    
    function executeToolAction(tool) {
      switch(tool) {
        case 'invert':
          inverted = !inverted;
          imageCache.clear();
          mprImageCache.clear();
          mprImgs = { axial: null, sagittal: null, coronal: null };
          showToast('Image inverted', 'info', 1000);
          break;
          
        case 'reset':
          resetViewport();
          break;
          
        case 'fit':
          fitToWindow();
          break;
          
        case 'one':
          setOneToOneZoom();
          break;
          
        case 'reload':
          reloadCurrentImage();
          break;
          
        case 'align-center':
          centerImage();
          break;
      }
    }
    
    function executeToggleTool(tool, button) {
      switch(tool) {
        case 'cine':
          cineActive = !cineActive;
          button.classList.toggle('active', cineActive);
          if (cineActive) {
            startCine();
          } else {
            stopCine();
          }
          break;
          
        case 'crosshair':
          crosshair = !crosshair;
          button.classList.toggle('active', crosshair);
          showToast(crosshair ? 'Crosshair enabled' : 'Crosshair disabled', 'info', 1000);
          break;
          
        case 'spyglass':
          spyglass.active = !spyglass.active;
          button.classList.toggle('active', spyglass.active);
          showToast(spyglass.active ? 'Spyglass enabled' : 'Spyglass disabled', 'info', 1000);
          break;
      }
    }
    
    function resetViewport() {
      zoom = 1.0;
      panOffset = { x: 0, y: 0 };
      ww = defaultWw;
      wl = defaultWl;
      inverted = false;
      
      // Update UI controls
      if (zoomSlider) zoomSlider.value = 100;
      if (wwSlider) wwSlider.value = Math.round(ww);
      if (wlSlider) wlSlider.value = Math.round(wl);
      if (wwNum) wwNum.value = Math.round(ww);
      if (wlNum) wlNum.value = Math.round(wl);
      
      // Update display values
      const zoomVal = document.getElementById('zoomVal');
      const wwVal = document.getElementById('wwVal');
      const wlVal = document.getElementById('wlVal');
      
      if (zoomVal) zoomVal.textContent = '100%';
      if (wwVal) wwVal.textContent = Math.round(ww);
      if (wlVal) wlVal.textContent = Math.round(wl);
      
      // Clear caches
      imageCache.clear();
      mprImageCache.clear();
      mprImgs = { axial: null, sagittal: null, coronal: null };
      
      showToast('View reset to defaults', 'success', 1500);
    }
    
    function fitToWindow() {
      panOffset = { x: 0, y: 0 };
      zoom = 1.0;
      if (zoomSlider) zoomSlider.value = 100;
      const zoomVal = document.getElementById('zoomVal');
      if (zoomVal) zoomVal.textContent = '100%';
      showToast('Image fitted to viewport', 'info', 1000);
    }
    
    function setOneToOneZoom() {
      if (lastVp && lastVp.imgW && lastVp.imgH) {
        const baseFit = Math.min(canvas.width / lastVp.imgW, canvas.height / lastVp.imgH);
        zoom = 1 / baseFit;
        const zoomPercent = Math.round(zoom * 100);
        
        if (zoomSlider) {
          zoomSlider.value = Math.min(500, Math.max(25, zoomPercent));
        }
        
        const zoomVal = document.getElementById('zoomVal');
        if (zoomVal) {
          zoomVal.textContent = `${zoomPercent}%`;
        }
        
        panOffset = { x: 0, y: 0 };
        showToast('Zoom set to 1:1', 'info', 1000);
      } else {
        showToast('Image not loaded', 'warning');
      }
    }
    
    function reloadCurrentImage() {
      if (images.length > 0) {
        const currentUrl = getCurrentImageUrl();
        if (currentUrl) {
          imageCache.delete(currentUrl);
          showToast('Image reloaded', 'info', 1000);
        }
      } else {
        showToast('No image to reload', 'warning');
      }
    }
    
    function centerImage() {
      panOffset = { x: 0, y: 0 };
      showToast('Image centered', 'info', 1000);
    }
    
    // Initialize tool buttons when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeToolButtons);
    } else {
      initializeToolButtons();
    }// Update active state
          document.querySelectorAll('.tool').forEach(x => x.classList.remove('active'));
          t.classList.add('active');
          
          // Handle specific tools with improved functionality
          switch (tool) {
            case 'invert':
              inverted = !inverted;
              imageCache.clear();
              mprImageCache.clear();
              mprImgs = { axial: null, sagittal: null, coronal: null };
              requestDraw();
              showToast('Image inverted', 'info', 1000);
              return;
              
            case 'reset':
              zoom = 1.0;
              panOffset = { x: 0, y: 0 };
              ww = defaultWw;
              wl = defaultWl;
              inverted = false;
              zoomSlider.value = 100;
              wwSlider.value = Math.round(ww);
              wlSlider.value = Math.round(wl);
              document.getElementById('zoomVal').textContent = '100%';
              document.getElementById('wwVal').textContent = Math.round(ww);
              document.getElementById('wlVal').textContent = Math.round(wl);
              imageCache.clear();
              mprImageCache.clear();
              mprImgs = { axial: null, sagittal: null, coronal: null };
              requestDraw();
              showToast('View reset to defaults', 'success', 1000);
              return;
              
            case 'fit':
              panOffset = { x: 0, y: 0 };
              zoom = 1.0;
              zoomSlider.value = 100;
              document.getElementById('zoomVal').textContent = '100%';
              requestDraw();
              showToast('Image fitted to viewport', 'info', 1000);
              return;
              
            case 'one':
              if (lastVp) {
                const baseFit = Math.min(canvas.width / lastVp.imgW, canvas.height / lastVp.imgH);
                zoom = 1 / baseFit;
                zoomSlider.value = Math.min(500, Math.max(25, Math.round(zoom * 100)));
                document.getElementById('zoomVal').textContent = `${Math.round(zoom * 100)}%`;
                panOffset = { x: 0, y: 0 };
                requestDraw();
                showToast('Zoom set to 1:1', 'info', 1000);
              }
              return;
              
            case 'cine':
              cineActive = !cineActive;
              if (cineActive) {
                if (!images.length) {
                  showToast('No images available for cine mode', 'warning');
                  cineActive = false;
                  return;
                }
                if (cineTimer) clearInterval(cineTimer);
                cineTimer = setInterval(() => {
                  if (!images.length) return;
                  index = (index + 1) % images.length;
                  sliceSlider.value = index;
                  document.getElementById('sliceVal').textContent = index + 1;
                  requestDraw();
                  debouncedLoadOverlaysForCurrentImage();
                }, Math.max(30, Math.round(1000 / cineFps)));
                showToast('Cine mode started', 'success', 1000);
              } else {
                if (cineTimer) {
                  clearInterval(cineTimer);
                  cineTimer = null;
                }
                showToast('Cine mode stopped', 'info', 1000);
              }
              return;
              
            case 'spyglass':
              spyglass.active = !spyglass.active;
              requestDraw();
              showToast(`Spyglass ${spyglass.active ? 'enabled' : 'disabled'}`, 'info', 1000);
              return;
              
            case 'align-center':
              panOffset = { x: 0, y: 0 };
              requestDraw();
              showToast('Image centered', 'info', 1000);
              return;
              
            case 'reload':
              // Reset all parameters
              ww = defaultWw;
              wl = defaultWl;
              inverted = false;
              panOffset = { x: 0, y: 0 };
              zoom = 1.0;
              wwSlider.value = Math.round(ww);
              wlSlider.value = Math.round(wl);
              document.getElementById('wwVal').textContent = Math.round(ww);
              document.getElementById('wlVal').textContent = Math.round(wl);
              zoomSlider.value = 100;
              document.getElementById('zoomVal').textContent = '100%';
              imageCache.clear();
              mprImageCache.clear();
              mprImgs = { axial: null, sagittal: null, coronal: null };
              requestDraw();
              showToast('All settings reloaded', 'success', 1000);
              return;
              
            case 'ai':
              showToast('AI analysis feature coming soon', 'info');
              return;
              
            case 'crosshair':
              if (activeTool === 'crosshair') {
                crosshair = false;
                activeTool = 'window';
                showToast('Crosshair disabled', 'info', 1000);
              } else {
                activeTool = 'crosshair';
                crosshair = true;
                showToast('Crosshair enabled', 'info', 1000);
              }
              requestDraw();
              return;
              
            case 'hu':
              showHuProbe = true;
              huEllipse = null;
              requestDraw();
              showToast('HU probe enabled', 'info', 1000);
              return;
              
            case 'measure':
              showHuProbe = false;
              if (mprMode) {
                document.getElementById('mprMeasurePanel').style.display = '';
              }
              showToast('Measurement tool selected', 'info', 1000);
              break;
              
            case 'mpr':
              // No-op, handled by 3D dropdown
              return;
              
            default:
              // Generic tool activation
              break;
          }
          
          // Handle MPR mode specifics
          if (mprMode) {
            const mprPanel = document.getElementById('mprMeasurePanel');
            if (mprPanel) {
              mprPanel.style.display = (tool === 'measure') ? '' : mprPanel.style.display;
            }
            return;
          }
          
          // Set active tool
          activeTool = tool;
          
        } catch (error) {
          console.error('Tool button error:', error);
          showToast(`Tool error: ${error.message}`, 'error');
        }
      });
    });

    // Mouse interactions on viewport
    const viewport = document.getElementById('viewport');
    viewport.addEventListener('mousedown', (e)=>{
      isDragging = true; dragStart = { x: e.offsetX, y: e.offsetY };
      // Start measurement draft
      if (activeTool === 'measure'){
        if (mprMode){
          const halfW = Math.floor(canvas.width/2), halfH = Math.floor(canvas.height/2);
          const mx = e.offsetX, my = e.offsetY;
          let plane = null; if (mx < halfW && my < halfH) plane='sagittal'; else if (mx>=halfW && my<halfH) plane='coronal'; else if (mx<halfW && my>=halfH) plane='axial';
          if (mprFullPlane) plane = mprFullPlane;
          if (mprMeasurePlaneMode !== 'auto') plane = mprMeasurePlaneMode;
          if (plane && mprRegionVps[plane]){
            const vpR = mprRegionVps[plane];
            // Ignore clicks outside the image bounds within region
            if (mx < vpR.x || mx > vpR.x + vpR.imgW * vpR.scale || my < vpR.y || my > vpR.y + vpR.imgH * vpR.scale) {
              return;
            }
            const imgPt = canvasToImageCoords(vpR, e.offsetX, e.offsetY);
            measureDraft = { plane, start: imgPt, end: imgPt };
          }
        } else {
          const vp2 = lastVp || { x:0, y:0, scale:1 };
          measureDraft = { start: canvasToImageCoords(vp2, e.offsetX, e.offsetY), end: canvasToImageCoords(vp2, e.offsetX, e.offsetY) };
        }
      }
      if (mprMode && activeTool === 'crosshair'){
        const halfW = Math.floor(canvas.width/2), halfH = Math.floor(canvas.height/2);
        const mx = e.offsetX, my = e.offsetY;
        let plane = null; if (mx < halfW && my < halfH) plane='sagittal'; else if (mx>=halfW && my<halfH) plane='coronal'; else if (mx<halfW && my>=halfH) plane='axial';
        if (plane && mprRegionVps[plane]){
          const vpR = mprRegionVps[plane];
          // Ignore clicks outside the image bounds within region
          if (mx < vpR.x || mx > vpR.x + vpR.imgW * vpR.scale || my < vpR.y || my > vpR.y + vpR.imgH * vpR.scale) {
            return;
          }
          const imgPt = canvasToImageCoords(vpR, mx, my);
          // Update crosshair global coordinates and synchronize all planes
          const oldCross = {...mprCross};
          let needsUpdate = false;
          
          if (plane === 'axial'){
            const newX = Math.round(imgPt.x);
            const newY = Math.round(imgPt.y);
            if (mprCross.x !== newX || mprCross.y !== newY) {
              mprCross.x = newX;
              mprCross.y = newY;
              mprScroll.sagittal = Math.max(0, Math.min((mprScroll.counts.sagittal||1)-1, newX));
              mprScroll.coronal = Math.max(0, Math.min((mprScroll.counts.coronal||1)-1, newY));
              needsUpdate = true;
            }
          } else if (plane === 'sagittal'){
            // sagittal image: x->height(y), y->depth(z)
            const newY = Math.round(imgPt.x);
            const newZ = Math.round(imgPt.y);
            if (mprCross.y !== newY || mprCross.z !== newZ) {
              mprCross.y = newY;
              mprCross.z = newZ;
              mprScroll.axial = Math.max(0, Math.min((mprScroll.counts.axial||1)-1, newZ));
              mprScroll.coronal = Math.max(0, Math.min((mprScroll.counts.coronal||1)-1, newY));
              needsUpdate = true;
            }
          } else if (plane === 'coronal'){
            // coronal image: x->width(x), y->depth(z)
            const newX = Math.round(imgPt.x);
            const newZ = Math.round(imgPt.y);
            if (mprCross.x !== newX || mprCross.z !== newZ) {
              mprCross.x = newX;
              mprCross.z = newZ;
              mprScroll.axial = Math.max(0, Math.min((mprScroll.counts.axial||1)-1, newZ));
              mprScroll.sagittal = Math.max(0, Math.min((mprScroll.counts.sagittal||1)-1, newX));
              needsUpdate = true;
            }
          }
          
          if (needsUpdate) {
            // Force refresh of all plane images when crosshair moves
            mprImgs = { axial: null, sagittal: null, coronal: null };
            
            // Prefetch the new slice positions for smooth interaction
            prefetchMprSlices('axial', mprScroll.axial, 2);
            prefetchMprSlices('sagittal', mprScroll.sagittal, 2);
            prefetchMprSlices('coronal', mprScroll.coronal, 2);
            
            draw();
          }
        }
      }
      if (showHuProbe){
        if (mprMode){
          // determine plane by quadrant
          const halfW = Math.floor(canvas.width/2), halfH = Math.floor(canvas.height/2);
          const mx = e.offsetX, my = e.offsetY;
          let plane = null; if (mx < halfW && my < halfH) plane='sagittal'; else if (mx>=halfW && my<halfH) plane='coronal'; else if (mx<halfW && my>=halfH) plane='axial';
          if (plane && mprRegionVps[plane]){
            const vpR = mprRegionVps[plane];
            const imgPt = canvasToImageCoords(vpR, e.offsetX, e.offsetY);
            huEllipse = { mode:'mpr', plane, slice: (mprScroll[plane]||0), cx: imgPt.x, cy: imgPt.y, rx: 1, ry: 1 };
          }
        } else if (lastVp){
          const imgPt = canvasToImageCoords(lastVp, e.offsetX, e.offsetY);
          huEllipse = { mode:'series', cx: imgPt.x, cy: imgPt.y, rx: 1, ry: 1 };
        }
        draw();
      }
      if (spyglass.active){ spyglass.isPress = true; spyglass.cx = e.offsetX; spyglass.cy = e.offsetY; draw(); }
    });
    viewport.addEventListener('mousemove', async (e)=>{
      if (!isDragging) { if (spyglass.active && spyglass.isPress){ spyglass.cx = e.offsetX; spyglass.cy = e.offsetY; requestDraw(); } return; }
      const vp = lastVp || { x:0, y:0, scale:1 };
      if (activeTool === 'window'){
        const dx = e.offsetX - dragStart.x; const dy = e.offsetY - dragStart.y; dragStart = { x: e.offsetX, y: e.offsetY };
        ww = Math.max(1, ww + dx*4); wl = wl + dy*2; wwSlider.value = Math.round(ww); wlSlider.value = Math.round(wl); document.getElementById('wwVal').textContent = Math.round(ww); document.getElementById('wlVal').textContent = Math.round(wl); requestDraw();
      } else if (activeTool === 'pan'){
        panOffset.x += (e.offsetX - dragStart.x); panOffset.y += (e.offsetY - dragStart.y); dragStart = { x: e.offsetX, y: e.offsetY }; requestDraw();
      } else if (activeTool === 'measure' && measureDraft){
        if (mprMode && measureDraft.plane && mprRegionVps[measureDraft.plane]){
          const vpR = mprRegionVps[measureDraft.plane];
          measureDraft.end = canvasToImageCoords(vpR, e.offsetX, e.offsetY);
        } else {
          measureDraft.end = canvasToImageCoords(vp, e.offsetX, e.offsetY);
        }
        requestDraw();
      } else if (activeTool === 'annotate'){
        // no-op while dragging
      } else if (activeTool === 'zoom'){
        const dy = e.offsetY - dragStart.y; dragStart = { x: e.offsetX, y: e.offsetY }; const factor = dy<0 ? 1.05 : 0.95; zoom = Math.min(5.0, Math.max(0.25, zoom*factor)); zoomSlider.value = Math.round(zoom*100); document.getElementById('zoomVal').textContent = `${Math.round(zoom*100)}%`; requestDraw();
      } else if (mprMode && activeTool === 'crosshair'){
        const halfW = Math.floor(canvas.width/2), halfH = Math.floor(canvas.height/2);
        const mx = e.offsetX, my = e.offsetY;
        let plane = null; if (mx < halfW && my < halfH) plane='sagittal'; else if (mx>=halfW && my<halfH) plane='coronal'; else if (mx<halfW && my>=halfH) plane='axial';
        if (mprFullPlane) plane = mprFullPlane;
        if (plane && mprRegionVps[plane]){
          const vpR = mprRegionVps[plane];
          // Ignore clicks outside the image bounds within region
          if (mx < vpR.x || mx > vpR.x + vpR.imgW * vpR.scale || my < vpR.y || my > vpR.y + vpR.imgH * vpR.scale) {
            return;
          }
          const imgPt = canvasToImageCoords(vpR, mx, my);
          
          // Update crosshair global coordinates and synchronize all planes
          const oldCross = {...mprCross};
          
          if (plane === 'axial'){
            mprCross.x = Math.round(imgPt.x);
            mprCross.y = Math.round(imgPt.y);
            // Update orthogonal planes to intersect this point
            mprScroll.sagittal = Math.max(0, Math.min((mprScroll.counts.sagittal||1)-1, mprCross.x));
            mprScroll.coronal = Math.max(0, Math.min((mprScroll.counts.coronal||1)-1, mprCross.y));
          } else if (plane === 'sagittal'){
            // sagittal image: x->height(y), y->depth(z)
            mprCross.y = Math.round(imgPt.x);
            mprCross.z = Math.round(imgPt.y);
            mprScroll.axial = Math.max(0, Math.min((mprScroll.counts.axial||1)-1, mprCross.z));
            mprScroll.coronal = Math.max(0, Math.min((mprScroll.counts.coronal||1)-1, mprCross.y));
          } else if (plane === 'coronal'){
            // coronal image: x->width(x), y->depth(z)
            mprCross.x = Math.round(imgPt.x);
            mprCross.z = Math.round(imgPt.y);
            mprScroll.axial = Math.max(0, Math.min((mprScroll.counts.axial||1)-1, mprCross.z));
            mprScroll.sagittal = Math.max(0, Math.min((mprScroll.counts.sagittal||1)-1, mprCross.x));
          }
          
          // Check if crosshair position actually changed
          const crossChanged = (oldCross.x !== mprCross.x || oldCross.y !== mprCross.y || oldCross.z !== mprCross.z);
          
          if (crossChanged) {
            // Prefetch new slices for updated orthogonal planes
            console.log(`Crosshair moved to [${mprCross.x}, ${mprCross.y}, ${mprCross.z}]`);
            
            // Update slice indicators
            document.querySelector('[data-plane="axial"] .slice-indicator')?.textContent = `${mprScroll.axial + 1}/${mprScroll.counts.axial || 0}`;
            document.querySelector('[data-plane="sagittal"] .slice-indicator')?.textContent = `${mprScroll.sagittal + 1}/${mprScroll.counts.sagittal || 0}`;
            document.querySelector('[data-plane="coronal"] .slice-indicator')?.textContent = `${mprScroll.coronal + 1}/${mprScroll.counts.coronal || 0}`;
            
            // Load new slices for orthogonal planes immediately
            const loadPromises = [];
            if (plane !== 'axial') {
              loadPromises.push(getMprImage(currentSeries.id, 'axial', mprScroll.axial).then(img => {
                mprImgs.axial = img;
              }));
            }
            if (plane !== 'sagittal') {
              loadPromises.push(getMprImage(currentSeries.id, 'sagittal', mprScroll.sagittal).then(img => {
                mprImgs.sagittal = img;
              }));
            }
            if (plane !== 'coronal') {
              loadPromises.push(getMprImage(currentSeries.id, 'coronal', mprScroll.coronal).then(img => {
                mprImgs.coronal = img;
              }));
            }
            
            // Wait for all images to load then redraw
            Promise.all(loadPromises).then(() => {
              requestDraw();
            }).catch(err => {
              console.error('Error loading orthogonal images:', err);
              requestDraw(); // Draw anyway
            });
            
            // Also prefetch surrounding slices
            prefetchMprSlices('axial', mprScroll.axial, 2);
            prefetchMprSlices('sagittal', mprScroll.sagittal, 2);
            prefetchMprSlices('coronal', mprScroll.coronal, 2);
          }
          
          requestDraw();
        }
      } else if (showHuProbe && huEllipse){
        if (huEllipse.mode==='mpr' && mprRegionVps[huEllipse.plane]){
          const vpR = mprRegionVps[huEllipse.plane];
          const cur = canvasToImageCoords(vpR, e.offsetX, e.offsetY);
          huEllipse.rx = Math.abs(cur.x - huEllipse.cx);
          huEllipse.ry = Math.abs(cur.y - huEllipse.cy);
          requestDraw();
        } else if (lastVp && huEllipse.mode==='series'){
          const cur = canvasToImageCoords(lastVp, e.offsetX, e.offsetY);
          huEllipse.rx = Math.abs(cur.x - huEllipse.cx);
          huEllipse.ry = Math.abs(cur.y - huEllipse.cy);
          requestDraw();
        }
      }
    });
    // HU probe on mousemove in MPR when enabled
    viewport.addEventListener('mousemove', async (e)=>{
      if (!mprMode || !showHuProbe) return;
      
      // Skip if we're in the middle of dragging to resize an ellipse
      if (isDragging && huEllipse) return;
      // Determine which plane region the mouse is in
      const halfW = Math.floor(canvas.width/2), halfH = Math.floor(canvas.height/2);
      const mx = e.offsetX, my = e.offsetY;
      let plane = null; if (mx < halfW && my < halfH) plane='sagittal'; else if (mx>=halfW && my<halfH) plane='coronal'; else if (mx<halfW && my>=halfH) plane='axial';
      if (mprFullPlane) plane = mprFullPlane;
      if (!plane || !mprRegionVps[plane]) return;
      try {
        const vpR = mprRegionVps[plane];
        const imgPt = canvasToImageCoords(vpR, mx, my);
        const px = Math.max(0, Math.min(vpR.imgW-1, imgPt.x));
        const py = Math.max(0, Math.min(vpR.imgH-1, imgPt.y));
        // Query HU from backend
        const q = new URLSearchParams();
        q.set('mode','mpr'); q.set('series_id', currentSeries.id); q.set('plane', plane);
        q.set('slice', mprScroll[plane]||0); q.set('x', Math.floor(px)); q.set('y', Math.floor(py));
        try {
          const resp = await fetch(`/dicom-viewer/api/hu/?${q.toString()}`);
          const j = await resp.json();
          if (j && typeof j.hu === 'number'){
            document.getElementById('overlay').innerHTML = `HU (${plane}): ${j.hu} @ x:${Math.floor(px)} y:${Math.floor(py)} slice:${(mprScroll[plane]||0)+1}/${mprScroll.counts[plane]||0}`;
          }
        } catch(e){}
      } catch(e){}
    });
    viewport.addEventListener('mouseup', async (e)=>{
      if (!isDragging) return; isDragging = false;
      const vp = lastVp || { x:0, y:0, scale:1 };
      if (activeTool === 'measure' && measureDraft){
        if (mprMode && measureDraft.plane && mprRegionVps[measureDraft.plane]){
          const vpR = mprRegionVps[measureDraft.plane];
          measureDraft.end = canvasToImageCoords(vpR, e.offsetX, e.offsetY);
          const plane = measureDraft.plane;
          const m = { plane, start: measureDraft.start, end: measureDraft.end };
          const dist = mprImageDistance(plane, m.start, m.end);
          if (dist.mm){
            const mm = dist.mm; const cm = mm/10.0;
            m.label = (measureUnit==='cm') ? `${cm.toFixed(2)} cm` : `${mm.toFixed(2)} mm`;
          } else { m.label = `${dist.px.toFixed(1)} px`; }
          mprMeasurements[plane].push(m);
          measureDraft = null; await draw();
        } else {
          measureDraft.end = canvasToImageCoords(vp, e.offsetX, e.offsetY);
          const m = { start: measureDraft.start, end: measureDraft.end };
          measureDraft = null; measurements.push(m); imageIdToMeasurements.set(getCurrentImageId(), measurements);
          await saveMeasurementToServer(m); renderMeasurementsList(); await draw();
        }
      } else if (activeTool === 'annotate'){
        const pos = canvasToImageCoords(vp, e.offsetX, e.offsetY);
                 // Create inline annotation with default text
         const text = 'Annotation';
         annotations.push({ pos, text }); 
         imageIdToAnnotations.set(getCurrentImageId(), annotations); 
         await saveAnnotationToServer(pos, text); 
         await draw();
         showToast('Annotation added', 'success', 2000);
      } else if (showHuProbe && huEllipse){
        // Submit ROI to backend
        try {
          const qp = new URLSearchParams();
          qp.set('shape','ellipse');
          if (huEllipse.mode==='series'){
            qp.set('mode','series');
            qp.set('image_id', String(getCurrentImageId()));
          } else {
            qp.set('mode','mpr');
            qp.set('series_id', String(currentSeries.id));
            qp.set('plane', huEllipse.plane);
            qp.set('slice', String(huEllipse.slice||0));
          }
          qp.set('cx', Math.round(huEllipse.cx));
          qp.set('cy', Math.round(huEllipse.cy));
          qp.set('rx', Math.max(1, Math.round(huEllipse.rx)));
          qp.set('ry', Math.max(1, Math.round(huEllipse.ry)));
          const r = await fetch(`/dicom-viewer/api/hu/?${qp.toString()}`);
          const j = await r.json();
          if (j && j.stats){
            const s = j.stats; // mean, std, min, max, n
            document.getElementById('overlay').innerHTML = `HU ROI (ellipse): mean ${s.mean.toFixed(1)}, sd ${s.std.toFixed(1)}, min ${s.min.toFixed(0)}, max ${s.max.toFixed(0)} (n=${s.n})`;
          }
        } catch(e){}
        await draw();
      }
      if (spyglass.active){ spyglass.isPress = false; }
    });
    // Double-click enlarge/restore MPR plane
    viewport.addEventListener('dblclick', async (e)=>{
      if (!mprMode) return;
      if (mprFullPlane) { mprFullPlane = null; await draw(); return; }
      const halfW = Math.floor(canvas.width/2), halfH = Math.floor(canvas.height/2);
      const mx = e.offsetX, my = e.offsetY;
      let plane = null; if (mx < halfW && my < halfH) plane='sagittal'; else if (mx>=halfW && my<halfH) plane='coronal'; else if (mx<halfW && my>=halfH) plane='axial';
      if (plane) { mprFullPlane = plane; await draw(); }
    });

    // Mouse wheel slice/zoom
    document.getElementById('viewport').addEventListener('wheel', async (e)=>{
      e.preventDefault();
      if (spyglass.active && spyglass.isPress){
        const d = e.deltaY>0 ? -10 : 10; spyglass.radius = Math.max(20, Math.min(300, spyglass.radius + d)); requestDraw(); return;
      }
      if (reconMode && reconImgs.length){
        const d = e.deltaY>0 ? 1 : -1;
        reconIndex = Math.max(0, Math.min(reconImgs.length-1, reconIndex + d));
        requestDraw();
        return;
      }
      if (mprMode){
        // Determine which quadrant and scroll that plane
        const halfW = Math.floor(canvas.width/2), halfH = Math.floor(canvas.height/2);
        const mx = e.offsetX, my = e.offsetY; const d = e.deltaY>0 ? 1 : -1;
        let plane = null;
        if (mx < halfW && my < halfH) plane = 'sagittal';
        else if (mx >= halfW && my < halfH) plane = 'coronal';
        else if (mx < halfW && my >= halfH) plane = 'axial';
        else plane = null; // bottom-right empty
        if (mprFullPlane) plane = mprFullPlane;
        if (!plane) return;
        const count = (mprScroll.counts[plane]||1);
        const cur = (mprScroll[plane]||0);
        const ni = Math.max(0, Math.min(count-1, cur + d));
                 if (ni !== cur){
           mprScroll[plane] = ni;
           
           // Keep crosshair in sync with the scrolled plane axis and update other planes
           if (plane === 'axial') {
             mprCross.z = ni;
           } else if (plane === 'sagittal') {
             mprCross.x = ni;
             // Update coronal slice to intersect at this sagittal position
             mprScroll.coronal = Math.max(0, Math.min((mprScroll.counts.coronal||1)-1, mprCross.y));
           } else if (plane === 'coronal') {
             mprCross.y = ni;
             // Update sagittal slice to intersect at this coronal position  
             mprScroll.sagittal = Math.max(0, Math.min((mprScroll.counts.sagittal||1)-1, mprCross.x));
           }
           
           // Clear images to force refresh with new slice positions
           mprImgs = { axial: null, sagittal: null, coronal: null };
           
           prefetchMprSlices(plane, ni);
           await draw();
         }
        return;
      }
      if (e.ctrlKey){ const delta = e.deltaY>0?0.9:1.1; zoom = Math.max(0.1, Math.min(5.0, zoom*delta)); zoomSlider.value = Math.round(zoom*100); document.getElementById('zoomVal').textContent = `${Math.round(zoom*100)}%`; requestDraw(); }
      else { const d = e.deltaY>0?1:-1; const ni = Math.max(0, Math.min(images.length-1, index+d)); if (ni !== index){ index = ni; sliceSlider.value = index; document.getElementById('sliceVal').textContent = index+1; requestDraw(); debouncedLoadOverlaysForCurrentImage(); prefetchAround(index, 3); } }
    }, { passive:false });

    // Local DICOM upload with debounce protection
    let uploadInProgress = false;
    
    // Load Local DICOM button - Fixed with better state management
    if (btnLoadLocal && inputLocal) {
      btnLoadLocal.addEventListener('click', () => {
        if (uploadInProgress) {
          showToast('Upload already in progress', 'warning');
          return;
        }
        try {
          inputLocal.click();
        } catch (error) {
          console.error('File input error:', error);
          showToast('Failed to open file dialog', 'error');
        }
      });
    }
    
    // File input change handler - Fixed with comprehensive error handling
    if (inputLocal) {
      inputLocal.addEventListener('change', async (e) => {
        try {
          if (uploadInProgress) {
            showToast('Upload already in progress', 'warning');
            return;
          }
          
          const files = e.target.files ? Array.from(e.target.files) : [];
          if (!files.length) {
            showToast('No files selected', 'warning');
            return;
          }
          
          // Validate file types
          const validFiles = files.filter(file => {
            const name = file.name.toLowerCase();
            return name.endsWith('.dcm') || name.endsWith('.dicom') || file.type === 'application/dicom' || file.size > 132;
          });
          
          if (validFiles.length === 0) {
            showToast('No valid DICOM files found', 'error');
            return;
          }
          
          if (validFiles.length < files.length) {
            showToast(`${files.length - validFiles.length} non-DICOM files filtered out`, 'warning');
          }
          
          // Set upload state immediately
          uploadInProgress = true;
          btnLoadLocal.disabled = true;
          btnLoadLocal.style.pointerEvents = 'none';
          btnLoadLocal.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Uploading...';
          reconStatus.textContent = `Uploading ${validFiles.length} DICOM files...`;
          showProgressIndicator();
          
          const CHUNK_SIZE = 50; // Reduced for better reliability
          const MAX_PARALLEL = 2;
          const chunks = [];
          for (let i = 0; i < validFiles.length; i += CHUNK_SIZE) {
            chunks.push(validFiles.slice(i, i + CHUNK_SIZE));
          }
          
          let current = 0;
          let lastStudyId = null;
          let errors = 0;
          
          async function uploadChunk(chunk) {
            try {
              const form = new FormData();
              chunk.forEach(f => form.append('dicom_files', f));
              
              const resp = await fetch('/dicom-viewer/upload/', { 
                method: 'POST', 
                body: form,
                headers: {
                  'X-Requested-With': 'XMLHttpRequest'
                }
              });
              
              if (!resp.ok) {
                const errorText = await resp.text();
                console.error('Upload failed with status:', resp.status, errorText);
                errors++;
                return;
              }
              
              const data = await resp.json();
              
              if (!data.success) {
                console.error('Upload chunk failed:', data.error);
                errors++;
                return;
              }
              
              current += chunk.length;
              if (!lastStudyId && data.study_id) lastStudyId = data.study_id;
              reconStatus.textContent = `Uploading... ${current}/${validFiles.length} (${Math.round(current/validFiles.length*100)}%)`;
              
            } catch (error) {
              console.error('Upload chunk error:', error);
              errors++;
            }
          }
          
          // Process chunks with controlled parallelism
          let chunkIndex = 0;
          const workers = Array.from({length: Math.min(MAX_PARALLEL, chunks.length)}).map(async () => {
            while (chunkIndex < chunks.length) {
              const currentChunk = chunkIndex++;
              if (currentChunk < chunks.length) {
                await uploadChunk(chunks[currentChunk]);
              }
            }
          });
          
          await Promise.all(workers);
          
          if (errors > 0 && current === 0) {
            throw new Error('All upload chunks failed');
          }
          
          if (errors > 0) {
            showToast(`Upload completed with ${errors} errors`, 'warning');
          }
          
          reconStatus.textContent = 'Upload complete. Loading study...';
          
          if (lastStudyId) {
            await loadStudy(lastStudyId);
            showToast('DICOM files uploaded and loaded successfully', 'success');
          } else {
            throw new Error('No study ID returned from upload');
          }
          
          reconStatus.textContent = '';
          
        } catch (err) {
          console.error('Upload error:', err);
          reconStatus.textContent = `Error: ${err.message}`;
          showToast(`Upload failed: ${err.message}`, 'error');
          // Don't fallback to desktop for upload errors
        } finally {
          // Reset upload state
          uploadInProgress = false;
          btnLoadLocal.disabled = false;
          btnLoadLocal.style.pointerEvents = '';
          btnLoadLocal.innerHTML = '<i class="fas fa-folder-open"></i> Load Local DICOM';
          hideProgressIndicator();
          
          // Reset file input and clear any lingering progress indicators
          inputLocal.value = '';
          reconStatus.textContent = '';
          e.target.value = '';
        }
      });
    }

    // Recon controls
    reconType.addEventListener('change', ()=>{
      const v = reconType.value; boneCtrl.style.display = v==='bone' ? '' : 'none';
    });
    boneSlider.addEventListener('input', e=> boneVal.textContent = e.target.value);

    // Debounce mechanism for reconstruction buttons to prevent multiple clicks
    let reconstructionTimeout = null;

    // Extracted function so both dropdown and button can trigger
    async function generateReconstruction(kind){
      try {
        // Prevent multiple simultaneous reconstruction requests
        if (reconstructionInProgress) {
          console.warn('Reconstruction already in progress');
          return;
        }
        
        if (!currentSeries || !currentSeries.id){ 
          console.warn('Select a series first'); 
          reconStatus.textContent = 'Please select a series first';
          return; 
        }
        
        // Set loading state immediately to prevent UI freezing
        reconstructionInProgress = true;
        reconStatus.textContent = 'Preparing reconstruction...';
        
        // Disable reconstruction buttons during processing
        const reconButtons = document.querySelectorAll('[data-recon], #btnGenerateRecon');
        reconButtons.forEach(btn => btn.style.pointerEvents = 'none');
        
        // Show progress indicator
        showProgressIndicator();
        
        // Clear any cached MPR images to ensure fresh load
        mprImgs = {};
        
        reconMode = null; reconImgs = []; reconIndex = 0; panOffset = {x:0,y:0}; zoom = 1.0;
        const params = new URLSearchParams();
        params.set('window_width', ww);
        params.set('window_level', wl);
        params.set('inverted', inverted);
        let url = '';
        const type = kind || reconType.value;
        if (type === 'mpr') url = `/dicom-viewer/api/series/${currentSeries.id}/mpr/?${params.toString()}`;
        else if (type === 'mip') url = `/dicom-viewer/api/series/${currentSeries.id}/mip/?quality=high&${params.toString()}`;
        else { url = `/dicom-viewer/api/series/${currentSeries.id}/bone/?threshold=${boneSlider.value}&mesh=true&quality=high`; }
        
        console.log(`Requesting reconstruction: ${type}, URL: ${url}`);
        
        // Add timeout and progress updates
        const controller = new AbortController();
        const timeoutId = setTimeout(() => {
          controller.abort();
          throw new Error('Reconstruction timeout - please try again');
        }, 180000); // 3 minute timeout for slow connections
        
        reconStatus.textContent = 'Loading reconstruction...';
        
        const r = await fetch(url, { 
          signal: controller.signal,
          headers: {
            'Cache-Control': 'no-cache',
            'Pragma': 'no-cache'
          }
        });
        
        clearTimeout(timeoutId);
        console.log(`Response status: ${r.status}`);
        
        if (!r.ok) {
          const errorText = await r.text();
          throw new Error(`HTTP ${r.status}: ${errorText}`);
        }
        
        reconStatus.textContent = 'Processing data...';
        
        const j = await r.json();
        console.log(`Response data:`, j);
        
        if (j.error) throw new Error(j.error);
        
        if (j.mpr_views){ 
          console.log('Processing MPR views');
          reconMode = 'mpr'; 
          reconImgs = [j.mpr_views.axial, j.mpr_views.sagittal, j.mpr_views.coronal]; 
          console.log('MPR images:', reconImgs.map(img => img ? 'loaded' : 'null'));
          mprMode = true; 
          document.getElementById('mprMeasurePanel').style.display=''; 
          if (j.counts){ 
            mprScroll.counts = j.counts; 
            mprScroll.axial = Math.floor((j.counts.axial||0)/2); 
            mprScroll.sagittal = Math.floor((j.counts.sagittal||0)/2); 
            mprScroll.coronal = Math.floor((j.counts.coronal||0)/2); 
            mprCross = { x: mprScroll.sagittal, y: mprScroll.coronal, z: mprScroll.axial }; 
            prefetchMprSlices('axial', mprScroll.axial); 
            prefetchMprSlices('sagittal', mprScroll.sagittal); 
            prefetchMprSlices('coronal', mprScroll.coronal); 
          } 
        }
        if (j.mip_views){ 
          console.log('Processing MIP views');
          reconMode = 'mip'; 
          reconImgs = [j.mip_views.axial, j.mip_views.sagittal, j.mip_views.coronal]; 
          console.log('MIP images:', reconImgs.map(img => img ? 'loaded' : 'null'));
          document.getElementById('mprMeasurePanel').style.display='none'; 
          mprMode = true; 
          mprFullPlane = null; 
          mprScroll.counts = j.counts || mprScroll.counts; 
        }
        if (j.bone_views){ 
          console.log('Processing bone views');
          reconMode = 'bone'; 
          reconImgs = [j.bone_views.axial || j.bone_views.bone_axial_preview, j.bone_views.sagittal || j.bone_views.bone_sagittal_preview, j.bone_views.coronal || j.bone_views.bone_coronal_preview]; 
          console.log('Bone images:', reconImgs.map(img => img ? 'loaded' : 'null'));
          document.getElementById('mprMeasurePanel').style.display='none'; 
          mprMode = true; 
          mprFullPlane = null; 
          if (j.mesh) showBone3D(j.mesh); 
        }
        reconImgs = reconImgs.filter(Boolean);
        reconIndex = 0;
        console.log(`Final reconstruction mode: ${reconMode}, images: ${reconImgs.length}`);
        await draw();
        reconStatus.textContent = 'Done'; setTimeout(()=> reconStatus.textContent = '', 1500);
      } catch (err){
        console.error('Reconstruction error:', err);
        reconStatus.textContent = `Error: ${err.message}`;
        await fallbackToDesktop();
      } finally {
        // Re-enable reconstruction buttons and reset state
        reconstructionInProgress = false;
        hideProgressIndicator();
        const reconButtons = document.querySelectorAll('[data-recon], #btnGenerateRecon');
        reconButtons.forEach(btn => btn.style.pointerEvents = '');
      }
    }
 
           // Generate reconstruction button - Fixed with proper reconstruction type detection
           if (btnGenerateRecon) {
             btnGenerateRecon.addEventListener('click', () => {
               const selectedType = reconType.value || 'mpr';
               try {
                 generateReconstruction(selectedType);
               } catch (error) {
                 console.error('Reconstruction button error:', error);
                 showToast(`Failed to start reconstruction: ${error.message}`, 'error');
               }
             });
           }

      // Worklist navigation that prefers returning to the original/mother worklist window
      function returnToWorklist(e){
        try {
          const targetUrl = '{% url 'worklist:dashboard' %}';
          if (e && typeof e.preventDefault === 'function') e.preventDefault();
          if (window.opener && !window.opener.closed) {
            try { window.opener.location.href = targetUrl; } catch(err) {}
            window.close();
            return false;
          }
          if (window.top && window.top !== window){
            try { window.top.location.href = targetUrl; return false; } catch(err) {}
          }
          window.location.href = targetUrl;
          return false;
        } catch(_) { window.location.href = '{% url 'worklist:dashboard' %}'; return false; }
      }
      // expose for inline onclick
      window.returnToWorklist = returnToWorklist;

    // Preload MPR mid-slices after series load to avoid UI stall on first click
    function warmupMpr(){
      if (!currentSeries || !currentSeries.id) return;
      const params = new URLSearchParams(); params.set('window_width', ww); params.set('window_level', wl); params.set('inverted', inverted);
      fetch(`/dicom-viewer/api/series/${currentSeries.id}/mpr/?${params.toString()}`)
        .then(r=>r.json())
        .then(j=>{ if (j && j.counts) { mprScroll.counts = j.counts; mprScroll.axial = Math.floor((j.counts.axial||0)/2); mprScroll.sagittal = Math.floor((j.counts.sagittal||0)/2); mprScroll.coronal = Math.floor((j.counts.coronal||0)/2); prefetchMprSlices('axial', mprScroll.axial); prefetchMprSlices('sagittal', mprScroll.sagittal); prefetchMprSlices('coronal', mprScroll.coronal);} })
        .catch(()=>{});
    }
 
     // 3D dropdown interactions (already handled above)
 
     // Clear measurements - Fixed with confirmation and feedback
     if (btnClearMeasurements) {
       btnClearMeasurements.addEventListener('click', () => {
         try {
           const hasMeasurements = mprMode ? 
             (mprMeasurements.axial.length > 0 || mprMeasurements.sagittal.length > 0 || mprMeasurements.coronal.length > 0) :
             (measurements.length > 0);
           
           if (!hasMeasurements) {
             showToast('No measurements to clear', 'info');
             return;
           }
           
           if (!confirm('Are you sure you want to clear all measurements?')) {
             return;
           }
           
           if (mprMode) {
             mprMeasurements.axial = [];
             mprMeasurements.sagittal = [];
             mprMeasurements.coronal = [];
             showToast('MPR measurements cleared', 'success');
           } else {
             measurements = [];
             const imageId = getCurrentImageId();
             if (imageId) {
               imageIdToMeasurements.set(imageId, measurements);
             }
             renderMeasurementsList();
             showToast('Measurements cleared', 'success');
           }
           
           draw();
           
         } catch (error) {
           console.error('Clear measurements error:', error);
           showToast(`Failed to clear measurements: ${error.message}`, 'error');
         }
       });
     }

     // Sorting
     sortSelect.addEventListener('change', async ()=>{
       if (!images || !images.length) return;
       const mode = sortSelect.value;
       if (mode === 'inst_desc') images.sort((a,b)=> (b.instance_number||0) - (a.instance_number||0));
       else images.sort((a,b)=> (a.instance_number||0) - (b.instance_number||0));
       index = 0; sliceSlider.max = Math.max(0, images.length - 1); sliceSlider.value = 0; document.getElementById('sliceVal').textContent = '1';
       await loadOverlaysForCurrentImage();
     });

     // Toggle tags overlay
     btnToggleTags.addEventListener('click', async ()=>{
       showTagsOverlay = !showTagsOverlay; await loadOverlaysForCurrentImage();
     });

     // Show DICOM modal - Removed duplicate handler (handled above with better error handling)
     closeDicomModal.addEventListener('click', ()=>{ dicomModal.style.display = 'none'; });
     dicomModal.addEventListener('click', (e)=>{ if (e.target === dicomModal) dicomModal.style.display = 'none'; });

     // Capture canvas - Removed duplicate handler (handled above with better error handling)

     // Print functionality
     const btnPrint = document.getElementById('btnPrint');
     const printModal = document.getElementById('printModal');
     const closePrintModal = document.getElementById('closePrintModal');
     const cancelPrint = document.getElementById('cancelPrint');
     const printForm = document.getElementById('printForm');
     const printerSelect = document.getElementById('printerSelect');
     
     // Client-side printer detection and capabilities
     async function loadClientPrinters() {
       printerSelect.innerHTML = '<option value="">Detecting printers...</option>';
       
       try {
         // Check if the browser supports the Print API
         if ('navigator' in window && 'print' in navigator) {
           console.log('Browser print API available');
         }
         
         // Use the modern approach with Print API if available
         if (window.navigator && window.navigator.printer) {
           try {
             const printers = await window.navigator.printer.getPrinters();
             if (printers && printers.length > 0) {
               printerSelect.innerHTML = '';
               printers.forEach((printer, index) => {
                 const option = document.createElement('option');
                 option.value = `client:${printer.id || index}`;
                 option.textContent = `🖨️ ${printer.name || `Printer ${index + 1}`}`;
                 printerSelect.appendChild(option);
               });
               return;
             }
           } catch (e) {
             console.log('Print API not fully supported:', e);
           }
         }
         
         // Fallback: Auto-detect using browser's print dialog capabilities
         await detectPrintersFromMediaQuery();
         
       } catch (error) {
         console.error('Error detecting client printers:', error);
         printerSelect.innerHTML = '<option value="browser">🖨️ Use Browser Print Dialog</option>';
       }
     }
     
     // Detect printer capabilities using media queries and print dialog
     async function detectPrintersFromMediaQuery() {
       printerSelect.innerHTML = '';
       
       // Add default browser printing option
       const browserOption = document.createElement('option');
       browserOption.value = 'browser';
       browserOption.textContent = '🖨️ System Default Printer (Browser)';
       browserOption.selected = true;
       printerSelect.appendChild(browserOption);
       
       // Try to detect common printer types and capabilities
       const printCapabilities = {
         color: window.matchMedia('print and (color)').matches,
         grayscale: window.matchMedia('print and (monochrome)').matches,
         highResolution: window.matchMedia('print and (min-resolution: 300dpi)').matches,
         a4: window.matchMedia('print and (width: 210mm)').matches,
         letter: window.matchMedia('print and (width: 8.5in)').matches
       };
       
       console.log('Detected print capabilities:', printCapabilities);
       
       // Add high-quality option if supported
       if (printCapabilities.highResolution || printCapabilities.color) {
         const hqOption = document.createElement('option');
         hqOption.value = 'browser-hq';
         hqOption.textContent = '🖨️ High Quality Print (300+ DPI)';
         printerSelect.appendChild(hqOption);
       }
       
       // Add photo printer option
       const photoOption = document.createElement('option');
       photoOption.value = 'browser-photo';
       photoOption.textContent = '📸 Photo Quality Print';
       printerSelect.appendChild(photoOption);
       
       // Store capabilities for later use
       window.detectedPrintCapabilities = printCapabilities;
     }

     // Print button - Fixed with comprehensive error handling
     if (btnPrint && printModal) {
       btnPrint.addEventListener('click', async () => {
         try {
           if (!canvas || !canvas.getContext) {
             showToast('No image available for printing', 'error');
             return;
           }
           
           // Show loading state
           btnPrint.disabled = true;
           btnPrint.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Loading...';
           
           // Auto-detect client machine printers using Web API
           await loadClientPrinters();
           
           // Also load server printers as fallback
           try {
             const printersResponse = await fetch('/dicom-viewer/print/printers/');
             const printersData = await printersResponse.json();
             
             if (printersData.success && printersData.printers.length > 0) {
             // Add server printers with indication
             printersData.printers.forEach(printer => {
               const option = document.createElement('option');
               option.value = `server:${printer.name}`;
               option.textContent = `🖥️ Server: ${printer.name} - ${printer.description}`;
               printerSelect.appendChild(option);
             });
           }
         } catch (e) {
           console.warn('Server printers not available:', e);
         }
         
         // Load modality-specific layouts
         const currentModality = getCurrentModality();
         if (currentModality) {
           const layoutsResponse = await fetch(`/dicom-viewer/print/layouts/?modality=${currentModality}`);
           const layoutsData = await layoutsResponse.json();
           
           if (layoutsData.success) {
             const layoutSelect = document.getElementById('layoutType');
             layoutSelect.innerHTML = '';
             
             layoutsData.layouts.forEach(layout => {
               const option = document.createElement('option');
               option.value = layout.value;
               option.textContent = layout.name;
               option.setAttribute('data-description', layout.description);
               layoutSelect.appendChild(option);
             });
             
             // Update description
             updateLayoutDescription();
           }
         }
         
           printModal.style.display = 'flex';
           showToast('Print options loaded', 'success');
           
         } catch(error) {
           console.error('Error loading print options:', error);
           showToast(`Failed to load print options: ${error.message}`, 'error');
         } finally {
           // Reset button state
           btnPrint.disabled = false;
           btnPrint.innerHTML = '<i class="fas fa-print"></i> Print';
         }
       });
     }

     // Handle print medium changes
     const printMedium = document.getElementById('printMedium');
     const paperTypeGroup = document.getElementById('paperTypeGroup');
     const paperSize = document.getElementById('paperSize');
     const paperType = document.getElementById('paperType');
     
     printMedium.addEventListener('change', function() {
       if (this.value === 'film') {
         // Show film-specific options
         paperType.innerHTML = `
           <option value="film">Medical Film</option>
           <option value="film_blue">Blue-Base Film</option>
           <option value="film_clear">Clear-Base Film</option>
         `;
         
         // Show film sizes
         paperSize.innerHTML = `
           <option value="FILM_14X17">Film 14" × 17" (Standard)</option>
           <option value="FILM_11X14">Film 11" × 14"</option>
           <option value="FILM_10X12">Film 10" × 12"</option>
           <option value="FILM_8X10">Film 8" × 10"</option>
         `;
         
         paperTypeGroup.querySelector('label').textContent = 'Film Type:';
       } else {
         // Show paper-specific options
         paperType.innerHTML = `
           <option value="glossy">🌟 Glossy Photo Paper</option>
           <option value="matte">Matte Paper</option>
           <option value="plain">Plain Paper</option>
         `;
         
         // Show paper sizes
         paperSize.innerHTML = `
           <option value="A4">A4 (210 × 297 mm)</option>
           <option value="Letter">Letter (8.5 × 11 in)</option>
         `;
         
         paperTypeGroup.querySelector('label').textContent = 'Paper Type:';
       }
     });

     // Handle layout type changes
     const layoutType = document.getElementById('layoutType');
     layoutType.addEventListener('change', updateLayoutDescription);
     
     function updateLayoutDescription() {
       const selectedOption = layoutType.options[layoutType.selectedIndex];
       const description = selectedOption.getAttribute('data-description') || selectedOption.textContent;
       document.getElementById('layoutDescription').textContent = description;
     }
     
     function getCurrentModality() {
       // Extract modality from patient info
       const patientInfo = document.getElementById('patientInfo').textContent;
       const modalityMatch = patientInfo.match(/Modality: ([^|]+)/);
       return modalityMatch ? modalityMatch[1].trim() : '';
     }

     // Close print modal
     closePrintModal.addEventListener('click', ()=>{ printModal.style.display = 'none'; });
     cancelPrint.addEventListener('click', ()=>{ printModal.style.display = 'none'; });
     printModal.addEventListener('click', (e)=>{ if (e.target === printModal) printModal.style.display = 'none'; });

     // Client-side printing function
     function printImageOnClient(imageData, settings) {
       const printWindow = window.open('', '_blank', 'width=800,height=600');
       const printHTML = `
         <!DOCTYPE html>
         <html>
         <head>
           <title>DICOM Print</title>
           <style>
             body { margin: 0; padding: 20px; font-family: Arial, sans-serif; }
             .print-container { text-align: center; }
             .dicom-image { max-width: 100%; height: auto; }
             .print-info { margin-top: 20px; font-size: 12px; color: #666; }
           </style>
         </head>
         <body>
           <div class="print-container">
             <img src="${imageData}" class="dicom-image" alt="DICOM Image">
             <div class="print-info">
               <p>Patient: ${document.getElementById('patientInfo').textContent}</p>
               <p>Printed: ${new Date().toLocaleString()}</p>
               <p>Settings: ${settings.paperSize}, ${settings.quality}</p>
             </div>
           </div>
         </body>
         </html>
       `;
       
       printWindow.document.write(printHTML);
       printWindow.document.close();
       
       // Auto-print after a short delay
       setTimeout(() => {
         printWindow.focus();
         printWindow.print();
       }, 500);
       
       return printWindow;
     }

     // Handle print form submission
     printForm.addEventListener('submit', async (e)=>{
        e.preventDefault();
        
        try {
          // Get current canvas image data
          const imageData = canvas.toDataURL('image/png', 1.0);
          const selectedPrinter = document.getElementById('printerSelect').value;
          
          // Check if this is a client-side printer
          if (selectedPrinter.startsWith('browser') || selectedPrinter.startsWith('client')) {
            // Handle client-side printing
            const printerSettings = {
              paperSize: document.getElementById('paperSize').value,
              paperType: document.getElementById('paperType').value,
              quality: document.getElementById('printQuality').value,
              copies: document.getElementById('copies').value,
              layout: document.getElementById('layoutType').value,
              medium: document.getElementById('printMedium').value
            };
            
            console.log('Printing on client with settings:', printerSettings);
            
            // Use client-side printing
            const printWindow = printImageOnClient(imageData, printerSettings);
            
            showToast('Print dialog opened successfully', 'success');
            printModal.style.display = 'none';
            
            return;
          }
          
          // Server-side printing (existing functionality)
          // Get patient information from current study
          const patientInfo = document.getElementById('patientInfo').textContent;
          const patientMatch = patientInfo.match(/Patient: ([^|]+)/);
          const dateMatch = patientInfo.match(/Study Date: ([^|]+)/);
          const modalityMatch = patientInfo.match(/Modality: ([^|]+)/);
          
          const formData = new FormData();
          formData.append('image_data', imageData);
          formData.append('printer_name', selectedPrinter.replace('server:', ''));
          formData.append('paper_size', document.getElementById('paperSize').value);
          formData.append('paper_type', document.getElementById('paperType').value);
          formData.append('print_quality', document.getElementById('printQuality').value);
          formData.append('copies', document.getElementById('copies').value);
          formData.append('layout_type', document.getElementById('layoutType').value);
          formData.append('print_medium', document.getElementById('printMedium').value);
          formData.append('patient_name', patientMatch ? patientMatch[1].trim() : 'Unknown Patient');
          formData.append('study_date', dateMatch ? dateMatch[1].trim() : '');
          formData.append('modality', modalityMatch ? modalityMatch[1].trim() : '');
          formData.append('series_description', currentSeries ? currentSeries.description || '' : '');
          formData.append('institution_name', 'Medical Facility');
          
          // Add CSRF token
          const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]')?.value || 
                           document.querySelector('meta[name="csrf-token"]')?.getAttribute('content') ||
                           getCookie('csrftoken');
          if (csrfToken) {
            formData.append('csrfmiddlewaretoken', csrfToken);
          }
          
          // Submit print job
          const submitBtn = document.getElementById('submitPrint');
          const originalText = submitBtn.innerHTML;
          submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Printing...';
          submitBtn.disabled = true;
          
          const response = await fetch('/dicom-viewer/print/image/', {
            method: 'POST',
            body: formData
          });
          
          const result = await response.json();
          
          if (result.success) {
            console.log('Print success:', result.message);
            showToast('Print job sent successfully', 'success');
            printModal.style.display = 'none';
          } else {
            console.error('Print error:', result.error);
            showToast('Print failed', 'error');
          }
          
                 } catch(e) {
            console.error('Error printing image:', e.message);
          } finally {
          // Reset button
          const submitBtn = document.getElementById('submitPrint');
          submitBtn.innerHTML = '<i class="fas fa-print"></i> Print Image';
          submitBtn.disabled = false;
        }
      });

    // Clean toast notification system (duplicate removed)

        // Utils
    function loadImage(src) {
      return new Promise((res, rej) => {
        const im = new Image();
        im.decoding = 'async';
        im.crossOrigin = 'anonymous';
        im.onload = () => {
          if (im.width > 0 && im.height > 0) {
            res(im);
          } else {
            rej(new Error('Invalid image dimensions'));
          }
        };
        im.onerror = (e) => {
          console.error('Image load error:', e, 'src:', src);
          rej(e);
        };
        im.src = src;
      });
    }
    function mprKey(seriesId, plane, sliceIndex, wwVal, wlVal, inv){
      return `${seriesId}|${plane}|${sliceIndex}|${Math.round(wwVal)}|${Math.round(wlVal)}|${inv?1:0}`;
    }
    
    // Duplicate functions removed to prevent code leakage
    async function getMprImage(seriesId, plane, sliceIndex){
      const key = mprKey(seriesId, plane, sliceIndex, ww, wl, inverted);
      if (mprImageCache.has(key)){
        const val = mprImageCache.get(key);
        return (typeof val?.then === 'function') ? await val : val;
      }
      const url = `/dicom-viewer/api/series/${seriesId}/mpr/?plane=${encodeURIComponent(plane)}&slice=${sliceIndex}&window_width=${Math.round(ww)}&window_level=${Math.round(wl)}&inverted=${inverted}`;
      const pending = fetch(url)
        .then(r=>{ if(!r.ok) throw new Error('mpr fetch failed'); return r.json(); })
        .then(j=>{ if(!j || !j.image) throw new Error('no mpr image'); return j.image; })
        .then(img=>{ mprImageCache.set(key, img); return img; })
        .catch(err=>{ mprImageCache.delete(key); throw err; });
      mprImageCache.set(key, pending);
      return await pending;
    }
    function prefetchMprSlices(plane, centerSlice, radius=3){
      if (!currentSeries || !mprScroll || !mprScroll.counts) return;
      const total = Math.max(0, (mprScroll.counts[plane]||0));
      if (!total) return;
      for (let o = -radius; o <= radius; o++){
        if (o === 0) continue;
        const s = centerSlice + o;
        if (s < 0 || s >= total) continue;
        const key = mprKey(currentSeries.id, plane, s, ww, wl, inverted);
        if (mprImageCache.has(key)) continue;
        // Fire-and-forget; cache will store promise/result
        getMprImage(currentSeries.id, plane, s).catch(err=>{ console.error('Failed to prefetch MPR image:', plane, s, err); });
      }
    }
    
    // 3D viewer for bone mesh
    let three = { renderer: null, scene: null, camera: null, controls: null };
    
    function disposeSceneObjects() {
      if (!three.scene) return;
      const toRemove = [];
      three.scene.traverse(obj => {
        if (obj.isMesh) {
          if (obj.geometry) obj.geometry.dispose();
          if (obj.material) {
            if (Array.isArray(obj.material)) obj.material.forEach(m => m.dispose());
            else obj.material.dispose();
          }
          toRemove.push(obj);
        }
      });
      toRemove.forEach(obj => three.scene.remove(obj));
    }
    
    let threeAnimId = null;
    
    function showBone3D(meshData) {
      try {
        const container = document.getElementById('threeContainer');
        const mount = document.getElementById('threeMount');
        container.style.display = 'block';
        
        // Initialize Three.js only once
        if (!three.renderer) {
          three.renderer = new THREE.WebGLRenderer({
            antialias: true,
            preserveDrawingBuffer: false,
            powerPreference: 'high-performance'
          });
          three.renderer.setSize(mount.clientWidth, mount.clientHeight);
          mount.appendChild(three.renderer.domElement);
          
          three.scene = new THREE.Scene();
          three.scene.background = new THREE.Color(0x000000);
          
          three.camera = new THREE.PerspectiveCamera(45, mount.clientWidth / mount.clientHeight, 0.1, 10000);
          three.camera.position.set(0, 0, 400);
          
          three.controls = new THREE.OrbitControls(three.camera, three.renderer.domElement);
          three.controls.enableDamping = true;
          three.controls.dampingFactor = 0.05;
          
          const light1 = new THREE.DirectionalLight(0xffffff, 1.0);
          light1.position.set(1, 1, 1);
          three.scene.add(light1);
          
          const light2 = new THREE.AmbientLight(0x444444);
          three.scene.add(light2);
          
          const onResize3D = () => {
            if (!three.renderer) return;
            three.renderer.setSize(mount.clientWidth, mount.clientHeight);
            three.camera.aspect = mount.clientWidth / mount.clientHeight;
            three.camera.updateProjectionMatrix();
          };
          window.addEventListener('resize', onResize3D, { passive: true });
          three._onResize3D = onResize3D;
        } else {
          disposeSceneObjects();
        }
        
        // Build geometry with enhanced quality
        const vertices = new Float32Array(meshData.vertices.flat());
        const indices = new Uint32Array(meshData.faces.flat());
        const geom = new THREE.BufferGeometry();
        geom.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
        geom.setIndex(new THREE.BufferAttribute(indices, 1));
        geom.computeVertexNormals();
        
        // Enhanced material for better bone visualization
        const material = new THREE.MeshPhongMaterial({
          color: 0xf5f5dc, // Bone color
          specular: 0x222222,
          shininess: 50,
          transparent: false,
          side: THREE.DoubleSide
        });
        
        const mesh = new THREE.Mesh(geom, material);
        
        // Center & scale
        geom.computeBoundingSphere();
        const bs = geom.boundingSphere;
        if (bs) {
          mesh.position.sub(bs.center);
          const target = 150;
          const s = bs.radius > 0 ? target / bs.radius : 1;
          mesh.scale.setScalar(s);
        }
        
        three.scene.add(mesh);
        
        // Animate
        if (threeAnimId) cancelAnimationFrame(threeAnimId);
        const animate = () => {
          if (!three.renderer || container.style.display === 'none') return;
          three.controls.update();
          three.renderer.render(three.scene, three.camera);
          threeAnimId = requestAnimationFrame(animate);
        };
        animate();
        
        // Close button functionality
        const closeBtn = document.getElementById('close3d');
        if (closeBtn) {
          closeBtn.onclick = () => {
            if (threeAnimId) {
              cancelAnimationFrame(threeAnimId);
              threeAnimId = null;
            }
            disposeSceneObjects();
            if (three._onResize3D) {
              window.removeEventListener('resize', three._onResize3D);
            }
            container.style.display = 'none';
          };
        }
      } catch (e) {
        console.warn('3D setup failed', e);
        showToast('3D visualization failed to load', 'error');
      }
    }
 
     // Debug function for 3D troubleshooting
    window.debug3D = function() {
      console.log('=== 3D Debug Info ===');
      console.log('MPR Mode:', mprMode);
      console.log('MPR Images:', mprImgs);
      console.log('MPR Cross:', mprCross);
      console.log('MPR Scroll:', mprScroll);
      console.log('MPR Region VPs:', mprRegionVps);
      console.log('Current Series:', currentSeries);
      console.log('Reconstruction Mode:', reconMode);
      console.log('Reconstruction Images:', reconImgs);
      console.log('===================');
    };

    // Series selection handler
    if (seriesSelect) {
      seriesSelect.addEventListener('change', async () => {
        const selectedSeriesId = seriesSelect.value;
        if (selectedSeriesId) {
          await loadSeries(selectedSeriesId);
        }
      });
    }
    
    // Window/level controls
    if (wwSlider && wlSlider && wwNum && wlNum) {
      wwSlider.addEventListener('input', () => {
        ww = parseInt(wwSlider.value);
        wwNum.value = ww;
        document.getElementById('wwVal').textContent = ww;
        imageCache.clear();
        mprImageCache.clear();
        requestDraw();
      });
      
      wlSlider.addEventListener('input', () => {
        wl = parseInt(wlSlider.value);
        wlNum.value = wl;
        document.getElementById('wlVal').textContent = wl;
        imageCache.clear();
        mprImageCache.clear();
        requestDraw();
      });
      
      wwNum.addEventListener('input', () => {
        ww = parseInt(wwNum.value);
        wwSlider.value = ww;
        document.getElementById('wwVal').textContent = ww;
        imageCache.clear();
        mprImageCache.clear();
        requestDraw();
      });
      
      wlNum.addEventListener('input', () => {
        wl = parseInt(wlNum.value);
        wlSlider.value = wl;
        document.getElementById('wlVal').textContent = wl;
        imageCache.clear();
        mprImageCache.clear();
        requestDraw();
      });
    }
    
    // Slice navigation
    if (sliceSlider) {
      sliceSlider.addEventListener('input', () => {
        index = parseInt(sliceSlider.value);
        document.getElementById('sliceVal').textContent = index + 1;
        requestDraw();
        prefetchAround(index, 3);
      });
    }
    
    // Zoom control
    if (zoomSlider) {
      zoomSlider.addEventListener('input', () => {
        zoom = parseInt(zoomSlider.value) / 100;
        document.getElementById('zoomVal').textContent = zoomSlider.value + '%';
        requestDraw();
      });
    }
    
        // Canvas mouse event handlers
    canvas.addEventListener('mousedown', (e) => {
      if (activeTool === 'pan') {
        isDragging = true;
        dragStart = { x: e.clientX - panOffset.x, y: e.clientY - panOffset.y };
      } else if (activeTool === 'measure') {
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) / rect.width * canvas.width;
        const y = (e.clientY - rect.top) / rect.height * canvas.height;
        measureDraft = { start: { x, y }, end: { x, y } };
        requestDraw();
      }
    });
    
    canvas.addEventListener('mousemove', (e) => {
      if (isDragging && activeTool === 'pan') {
        panOffset.x = e.clientX - dragStart.x;
        panOffset.y = e.clientY - dragStart.y;
        requestDraw();
      } else if (measureDraft && activeTool === 'measure') {
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) / rect.width * canvas.width;
        const y = (e.clientY - rect.top) / rect.height * canvas.height;
        measureDraft.end = { x, y };
        requestDraw();
      }
    });
    
    canvas.addEventListener('mouseup', (e) => {
      if (isDragging && activeTool === 'pan') {
        isDragging = false;
        dragStart = null;
      } else if (measureDraft && activeTool === 'measure') {
        // Add measurement
        const measurement = {
          start: measureDraft.start,
          end: measureDraft.end,
          label: 'Measurement'
        };
        measurements.push(measurement);
        imageIdToMeasurements.set(getCurrentImageId(), measurements);
        renderMeasurementsList();
        measureDraft = null;
        requestDraw();
      }
    });
    
    // Tool selection
    document.querySelectorAll('.tool[data-tool]').forEach(tool => {
      tool.addEventListener('click', () => {
        document.querySelectorAll('.tool').forEach(t => t.classList.remove('active'));
        tool.classList.add('active');
        activeTool = tool.dataset.tool;
        
        // Handle special tools
        if (activeTool === 'reset') {
          ww = defaultWw;
          wl = defaultWl;
          zoom = 1.0;
          panOffset = { x: 0, y: 0 };
          wwSlider.value = ww;
          wlSlider.value = wl;
          wwNum.value = ww;
          wlNum.value = wl;
          zoomSlider.value = 100;
          document.getElementById('wwVal').textContent = ww;
          document.getElementById('wlVal').textContent = wl;
          document.getElementById('zoomVal').textContent = '100%';
          imageCache.clear();
          mprImageCache.clear();
          requestDraw();
        } else if (activeTool === 'fit') {
          zoom = 1.0;
          panOffset = { x: 0, y: 0 };
          zoomSlider.value = 100;
          document.getElementById('zoomVal').textContent = '100%';
          requestDraw();
        } else if (activeTool === 'one') {
          zoom = 1.0;
          zoomSlider.value = 100;
          document.getElementById('zoomVal').textContent = '100%';
          requestDraw();
        } else if (activeTool === 'invert') {
          inverted = !inverted;
          imageCache.clear();
          mprImageCache.clear();
          requestDraw();
        }
      });
    });
    
    // Comprehensive initialization - Fixed with validation and error handling
    function initializeViewer() {
      try {
        console.log('Initializing DICOM viewer...');
        
        // Validate essential elements
        const essentialElements = {
          canvas: document.getElementById('dicomCanvas'),
          viewport: document.getElementById('viewport'),
          seriesSelect: document.getElementById('seriesSelect'),
          wwSlider: document.getElementById('ww'),
          wlSlider: document.getElementById('wl')
        };
        
        const missingElements = Object.entries(essentialElements)
          .filter(([name, element]) => !element)
          .map(([name]) => name);
        
        if (missingElements.length > 0) {
          console.error('Missing essential elements:', missingElements);
          showToast(`Viewer initialization failed: missing ${missingElements.join(', ')}`, 'error');
          return;
        }
        
        // Set initial canvas size
        setCanvasSize();
        
        // Validate canvas context
        if (!canvas.getContext) {
          console.error('Canvas context not available');
          showToast('Canvas not supported in this browser', 'error');
          return;
        }
        
        // Initialize canvas
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#000000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Load study if specified
        const studyId = q('study_id') || q('study') || {% if study_id %}'{{ study_id }}'{% else %}null{% endif %};
        if (studyId) {
          console.log(`Loading study ID: ${studyId}`);
          loadStudy(studyId);
        } else {
          // Show available studies for selection if no study ID specified
          loadAvailableStudies();
          showToast('DICOM viewer ready - select a study or load local DICOM files', 'info', 5000);
        }
        
        // Validate all button elements
        const buttons = [
          'btnLoadLocal', 'btnBackWorklist', 'btnWriteReport', 'btnToggleTags', 
          'btnShowDicom', 'btnCapture', 'btnPrint', 'btnClearMeasurements',
          'btnSavePreset', 'btnLoadPreset', 'btnGenerateRecon'
        ];
        
        const missingButtons = buttons.filter(id => !document.getElementById(id));
        if (missingButtons.length > 0) {
          console.warn('Some buttons not found:', missingButtons);
        }
        
        console.log('DICOM viewer initialized successfully');
        
        // Initialize all button event handlers
        initializeButtonHandlers();
        
      } catch (error) {
        console.error('Viewer initialization error:', error);
        showToast(`Initialization failed: ${error.message}`, 'error');
        // Reset all button states on error
        resetAllButtonStates();
      }
    }
    
    // Function to reset all button states - fixes stuck loading spinners
    function resetAllButtonStates() {
      try {
        // Reset Load Local button
        if (btnLoadLocal) {
          btnLoadLocal.disabled = false;
          btnLoadLocal.style.pointerEvents = '';
          btnLoadLocal.innerHTML = '<i class="fas fa-folder-open"></i> Load Local DICOM';
        }
        
        // Reset Print button
        const btnPrint = document.getElementById('btnPrint');
        if (btnPrint) {
          btnPrint.disabled = false;
          btnPrint.innerHTML = '<i class="fas fa-print"></i> Print';
        }
        
        // Reset Generate Reconstruction button
        if (btnGenerateRecon) {
          btnGenerateRecon.disabled = false;
          btnGenerateRecon.innerHTML = '<i class="fas fa-cogs"></i> Generate';
        }
        
        // Reset Save/Load Preset buttons
        if (btnSavePreset) {
          btnSavePreset.disabled = false;
          btnSavePreset.innerHTML = '<i class="fas fa-bookmark"></i> Save';
        }
        
        if (btnLoadPreset) {
          btnLoadPreset.disabled = false;
          btnLoadPreset.innerHTML = '<i class="fas fa-list"></i> Load';
        }
        
        // Reset upload state
        uploadInProgress = false;
        
        console.log('All button states reset');
      } catch (error) {
        console.error('Error resetting button states:', error);
      }
    }
    
    // Function to initialize all button handlers - fixes button interaction issues
    function initializeButtonHandlers() {
      try {
        // Ensure all critical buttons have proper event handlers
        
        // Load Local DICOM button
        if (btnLoadLocal && !btnLoadLocal.hasAttribute('data-initialized')) {
          btnLoadLocal.setAttribute('data-initialized', 'true');
          btnLoadLocal.addEventListener('click', () => {
            if (uploadInProgress) {
              showToast('Upload already in progress', 'warning');
              return;
            }
            try {
              inputLocal.click();
            } catch (error) {
              console.error('File input error:', error);
              showToast('Failed to open file dialog', 'error');
            }
          });
        }
        
        // Clear Measurements button
        if (btnClearMeasurements && !btnClearMeasurements.hasAttribute('data-initialized')) {
          btnClearMeasurements.setAttribute('data-initialized', 'true');
          btnClearMeasurements.addEventListener('click', () => {
            try {
              const hasMeasurements = mprMode ? 
                (mprMeasurements.axial.length > 0 || mprMeasurements.sagittal.length > 0 || mprMeasurements.coronal.length > 0) :
                (measurements.length > 0);
              
              if (!hasMeasurements) {
                showToast('No measurements to clear', 'info');
                return;
              }
              
              if (!confirm('Are you sure you want to clear all measurements?')) {
                return;
              }
              
              if (mprMode) {
                mprMeasurements.axial = [];
                mprMeasurements.sagittal = [];
                mprMeasurements.coronal = [];
                showToast('MPR measurements cleared', 'success');
              } else {
                measurements = [];
                const imageId = getCurrentImageId();
                if (imageId) {
                  imageIdToMeasurements.set(imageId, measurements);
                }
                renderMeasurementsList();
                showToast('Measurements cleared', 'success');
              }
              
              requestDraw();
              
            } catch (error) {
              console.error('Clear measurements error:', error);
              showToast(`Failed to clear measurements: ${error.message}`, 'error');
            }
          });
        }
        
        console.log('Button handlers initialized successfully');
      } catch (error) {
        console.error('Error initializing button handlers:', error);
      }
    }
    
    // Global error handler to prevent UI from getting stuck
    window.addEventListener('error', (event) => {
      console.error('Global error caught:', event.error);
      resetAllButtonStates();
      hideProgressIndicator();
      showToast('An error occurred. Interface reset.', 'warning');
    });
    
    window.addEventListener('unhandledrejection', (event) => {
      console.error('Unhandled promise rejection:', event.reason);
      resetAllButtonStates();
      hideProgressIndicator();
    });
    
    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeViewer);
    } else {
      initializeViewer();
    }

     // Unit selector wiring
     const unitSelect = document.getElementById('unitSelect');
     const unitVal = document.getElementById('unitVal');
     if (unitSelect){
             unitSelect.addEventListener('change', ()=>{
        measureUnit = unitSelect.value === 'cm' ? 'cm' : 'mm';
        unitVal.textContent = measureUnit;
        // Recompute labels for current measurements (series view)
        measurements = (measurements||[]).map(m=>{
          if (m && m.start && m.end){
            const dist = imageDistance(m.start, m.end);
            if (dist.mm){
              const mm = dist.mm; const cm = mm/10.0;
              m.label = (measureUnit==='cm') ? `${cm.toFixed(2)} cm` : `${mm.toFixed(2)} mm`;
            }
          }
          return m;
        });
        // Recompute MPR measurement labels
        ['axial','sagittal','coronal'].forEach(plane=>{
          mprMeasurements[plane] = (mprMeasurements[plane]||[]).map(m=>{
            if (m && m.start && m.end){
              const dist = mprImageDistance(plane, m.start, m.end);
              if (dist.mm){
                const mm = dist.mm; const cm = mm/10.0;
                m.label = (measureUnit==='cm') ? `${cm.toFixed(2)} cm` : `${mm.toFixed(2)} mm`;
              }
            }
            return m;
          });
        });
        renderMeasurementsList();
        requestDraw();
      });
     }

     document.getElementById('mprMeasurePlane').addEventListener('change', (e)=>{ mprMeasurePlaneMode = e.target.value; });
     document.getElementById('mprMeasureType').addEventListener('change', (e)=>{ mprMeasureType = e.target.value; });

     // Preset handlers - Fixed with comprehensive error handling and user feedback
     if (btnSavePreset) {
       btnSavePreset.addEventListener('click', async () => {
         try {
           if (!currentStudy) {
             showToast('No study loaded to save preset for', 'warning');
             return;
           }
           
           const name = prompt('Enter preset name:', `${currentStudy.modality || 'Custom'}_Preset_${Date.now()}`);
           if (!name) {
             showToast('Preset save cancelled', 'info');
             return;
           }
           
           const payload = {
             name: name.trim(),
             modality: (currentStudy && currentStudy.modality) || '',
             window_width: ww,
             window_level: wl,
             inverted: inverted
           };
           
           btnSavePreset.disabled = true;
           btnSavePreset.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Saving...';
           
           const response = await fetch('/dicom-viewer/api/presets/', {
             method: 'POST',
             headers: {
               'Content-Type': 'application/json',
               'X-CSRFToken': getCookie('csrftoken')
             },
             body: JSON.stringify(payload)
           });
           
           if (!response.ok) {
             throw new Error(`HTTP ${response.status}: ${response.statusText}`);
           }
           
           const result = await response.json();
           if (result.success) {
             showToast(`Preset "${name}" saved successfully`, 'success', 2000);
           } else {
             throw new Error(result.error || 'Failed to save preset');
           }
           
         } catch (error) {
           console.error('Save preset error:', error);
           showToast(`Failed to save preset: ${error.message}`, 'error');
         } finally {
           btnSavePreset.disabled = false;
           btnSavePreset.innerHTML = '<i class="fas fa-bookmark"></i> Save';
         }
       });
     }
     
     if (btnLoadPreset) {
       btnLoadPreset.addEventListener('click', async () => {
         try {
           btnLoadPreset.disabled = true;
           btnLoadPreset.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Loading...';
           
           const modality = (currentStudy && currentStudy.modality) || '';
           const response = await fetch(`/dicom-viewer/api/presets/?modality=${encodeURIComponent(modality)}`);
           
           if (!response.ok) {
             throw new Error(`HTTP ${response.status}: ${response.statusText}`);
           }
           
           const data = await response.json();
           const presets = data.presets || [];
           
           if (!presets.length) {
             showToast('No presets found for this modality', 'info');
             return;
           }
           
           // Load the most recent preset automatically
           const preset = presets[presets.length - 1];
           
           // Apply preset values
           ww = preset.window_width;
           wl = preset.window_level;
           inverted = !!preset.inverted;
           
           // Update UI controls
           wwSlider.value = ww;
           wlSlider.value = wl;
           wwNum.value = Math.round(ww);
           wlNum.value = Math.round(wl);
           document.getElementById('wwVal').textContent = Math.round(ww);
           document.getElementById('wlVal').textContent = Math.round(wl);
           
           // Clear caches and redraw
           imageCache.clear();
           mprImageCache.clear();
           mprImgs = { axial: null, sagittal: null, coronal: null };
           requestDraw();
           
           showToast(`Preset "${preset.name}" loaded successfully`, 'success', 2000);
           
         } catch (error) {
           console.error('Load preset error:', error);
           showToast(`Failed to load preset: ${error.message}`, 'error');
         } finally {
           btnLoadPreset.disabled = false;
           btnLoadPreset.innerHTML = '<i class="fas fa-list"></i> Load';
         }
       });
     }
   
    
    // Admin delete study functionality
    if (document.getElementById('btnDeleteStudy')) {
      document.getElementById('btnDeleteStudy').addEventListener('click', async function() {
        if (!currentStudy) {
          showToast('No study loaded', 'warning');
          return;
        }
        
        const confirmDelete = confirm(`Are you sure you want to delete this study?\n\nStudy: ${currentStudy}\nPatient: ${document.getElementById('patientInfo').textContent}\n\nThis action cannot be undone!`);
        
        if (!confirmDelete) return;
        
        try {
          showProgressIndicator();
          
          const response = await fetch(`/worklist/api/studies/${currentStudy}/delete/`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'X-CSRFToken': getCookie('csrftoken')
            }
          });
          
          hideProgressIndicator();
          
          if (response.ok) {
            showToast('Study deleted successfully', 'success');
            // Redirect to worklist after 2 seconds
            setTimeout(() => {
              window.location.href = '/worklist/dashboard/';
            }, 2000);
          } else {
            const error = await response.json();
            showToast(`Failed to delete study: ${error.error || 'Unknown error'}`, 'error');
          }
        } catch (error) {
          hideProgressIndicator();
          console.error('Delete error:', error);
          showToast(`Delete failed: ${error.message}`, 'error');
        }
      });
    }
  })();
  </script>
</body>
</html>