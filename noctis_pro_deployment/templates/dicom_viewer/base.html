<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DICOM Viewer</title>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
  <style>
    :root {
      --primary-bg: #0a0a0a;
      --secondary-bg: #1a1a1a;
      --card-bg: #252525;
      --card-surface: #252525;
      --header-bg: #333333;
      --border-color: #404040;
      --accent-color: #00d4ff;
      --text-primary: #ffffff;
      --text-secondary: #b3b3b3;
      --text-muted: #666666;
      --success-color: #00ff88;
      --warning-color: #ffaa00;
      --danger-color: #ff4444;
      --urgent-color: #ff0066;
      --scheduled-color: #4a90e2;
      --in-progress-color: #f5a623;
      --completed-color: #7ed321;
      --cancelled-color: #d0021b;
    }
    body { margin: 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: var(--primary-bg); color: var(--text-primary); }
    .layout { display: grid; grid-template-columns: 82px 1fr 320px; grid-template-rows: 60px 1fr; height: 100vh; }
    .toolbar { grid-row: 1 / span 2; grid-column: 1; background: var(--secondary-bg); border-right: 1px solid var(--border-color); padding: 8px 6px; display: flex; flex-direction: column; gap: 6px; overflow:auto; }
    .tool { width: 52px; height: 46px; background: var(--card-bg); border: 1px solid var(--border-color); border-radius: 2px; color: var(--text-primary); cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 9px; transition: all 0.2s ease; font-weight: 500; }
    .tool.active { background: var(--accent-color); color: var(--primary-bg); border-color: var(--accent-color); }
    .tool:hover:not(.active) { background: var(--accent-color); color: var(--primary-bg); border-color: var(--accent-color); }
    .tool i { font-size: 16px; margin-bottom: 2px; }
    .topbar { grid-row: 1; grid-column: 2 / span 2; display: flex; align-items: center; gap: 8px; padding: 0 16px; background: var(--header-bg); border-bottom: 1px solid var(--border-color); }
    .btn { padding: 3px 8px; border: 1px solid var(--border-color); border-radius: 2px; cursor: pointer; font-size: 10px; background: var(--card-bg); color: var(--text-primary); transition: all 0.2s ease; font-weight: 500; display: inline-flex; align-items: center; gap: 3px; text-decoration: none; }
    .btn:hover { background: var(--accent-color); color: var(--primary-bg); border-color: var(--accent-color); }
    .btn-primary { background: var(--accent-color); color: var(--primary-bg); border-color: var(--accent-color); }
    .btn-primary:hover { background: #00b8d4; border-color: #00b8d4; }
    .btn-control { padding: 3px 8px; border: 1px solid var(--border-color); border-radius: 2px; cursor: pointer; font-size: 10px; background: var(--card-bg); color: var(--text-primary); transition: all 0.2s ease; font-weight: 500; display: inline-flex; align-items: center; gap: 3px; text-decoration: none; }
    .btn-control:hover { background: var(--accent-color); color: var(--primary-bg); border-color: var(--accent-color); }
    .select { padding: 4px 6px; background: var(--secondary-bg); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); min-width: 160px; font-size: 10px; }
    .select:focus { outline: none; border-color: var(--accent-color); box-shadow: 0 0 0 1px var(--accent-color); }
    .viewport { grid-row: 2; grid-column: 2; background: #000000; position: relative; display: flex; align-items: center; justify-content: center; }
    .right { grid-row: 2; grid-column: 3; background: var(--secondary-bg); border-left: 1px solid var(--border-color); padding: 16px; overflow: auto; }
    .panel { background: var(--card-surface); border: 1px solid var(--border-color); border-radius: 8px; padding: 12px; margin-bottom: 16px; }
    .panel h3 { font-size: 12px; margin: 0 0 12px; padding-bottom: 8px; border-bottom: 1px solid var(--border-color); letter-spacing: .3px; color: var(--accent-color); font-weight: 600; text-transform: uppercase; }
    .control { margin-bottom: 12px; }
    .control .label { display: flex; justify-content: space-between; font-size: 11px; color: var(--text-secondary); margin-bottom: 6px; font-weight: 500; }
    input[type=range] { width: 100%; accent-color: var(--accent-color); height: 4px; background: var(--border-color); border-radius: 2px; }
    input[type=number] { width: 100%; padding: 6px 8px; background: var(--secondary-bg); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 11px; }
    input[type=number]:focus { outline: none; border-color: var(--accent-color); box-shadow: 0 0 0 1px var(--accent-color); }
    .overlay { position: absolute; top: 12px; left: 12px; background: rgba(0,0,0,0.8); padding: 8px 12px; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 11px; border: 1px solid var(--border-color); }
    .zoominfo { position: absolute; bottom: 12px; left: 12px; background: rgba(0,0,0,0.8); padding: 6px 10px; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 11px; border: 1px solid var(--border-color); }
    canvas { max-width: 100%; max-height: 100%; image-rendering: pixelated; image-rendering: crisp-edges; }
    .thumbs { display:grid; grid-template-columns: 1fr 1fr; gap:8px; }
    .thumbs img { width:100%; background:#000; border-radius:6px; border:1px solid var(--border-color); }
    .row-3 { display:grid; grid-template-columns: 1fr 1fr 1fr; gap:8px; }
    .muted { color:var(--text-muted); font-size:11px; padding:4px 0; }
    /* 3D dropdown in toolbar */
    .tool-dropdown { position: relative; }
    .tool-dropdown-menu { position: absolute; top: 48px; left: 0; background: var(--card-surface); border: 1px solid var(--border-color); border-radius: 6px; width: 180px; display: none; flex-direction: column; overflow: hidden; z-index: 10; box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
    .tool-dropdown-menu button { background: transparent; border: none; color: var(--text-primary); text-align: left; padding: 8px 12px; cursor: pointer; font-size: 11px; transition: all 0.2s ease; font-weight: 500; }
    .tool-dropdown-menu button:hover { background: var(--accent-color); color: var(--primary-bg); }
    /* 3D modal */
    #threeContainer { position: fixed; inset: 0; background: rgba(0,0,0,0.95); display: none; z-index: 1000; }
    #threeMount { position: absolute; inset: 0; }
    #close3d { position: absolute; top: 12px; right: 12px; z-index: 1001; background: var(--card-surface); border: 1px solid var(--border-color); color: var(--text-primary); padding: 8px 12px; border-radius: 4px; cursor: pointer; transition: all 0.2s ease; }
    #close3d:hover { background: var(--border-color); }
    /* DICOM tags modal */
    #dicomModal { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; background: rgba(0,0,0,0.8); z-index: 1200; }
    #dicomModal .modal-card { background:var(--card-surface); border:1px solid var(--border-color); padding:20px; width:70%; max-width: 960px; max-height:80%; overflow:auto; border-radius:8px; box-shadow: 0 8px 24px rgba(0,0,0,0.4); }
    #dicomModal .modal-header { display:flex; justify-content: space-between; align-items:center; margin-bottom:12px; border-bottom: 1px solid var(--border-color); padding-bottom: 12px; }
    #dicomModal h3 { color: var(--accent-color); font-weight: 600; margin: 0; text-transform: uppercase; font-size: 12px; }
    #dicomModal #dicomTagsPre { background: var(--secondary-bg); border: 1px solid var(--border-color); border-radius: 4px; padding: 12px; color: var(--text-secondary); font-family: 'Courier New', monospace; font-size: 11px; }
    
    /* Print modal */
    #printModal { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; background: rgba(0,0,0,0.8); z-index: 1300; }
    #printModal .modal-card { background:var(--card-surface); border:1px solid var(--border-color); padding:20px; width:500px; max-height:80%; overflow:auto; border-radius:8px; box-shadow: 0 8px 24px rgba(0,0,0,0.4); }
    #printModal .modal-header { display:flex; justify-content: space-between; align-items:center; margin-bottom:16px; border-bottom: 1px solid var(--border-color); padding-bottom: 12px; }
    #printModal h3 { color: var(--accent-color); font-weight: 600; margin: 0; text-transform: uppercase; font-size: 12px; }
    #printModal .form-group { margin-bottom: 16px; }
    #printModal .form-group label { display: block; margin-bottom: 6px; font-size: 11px; color: var(--text-secondary); font-weight: 500; }
    #printModal .form-group select, #printModal .form-group input { width: 100%; padding: 8px; background: var(--secondary-bg); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 11px; }
    #printModal .form-group select:focus, #printModal .form-group input:focus { outline: none; border-color: var(--accent-color); box-shadow: 0 0 0 1px var(--accent-color); }
    #printModal .btn-group { display: flex; gap: 8px; justify-content: flex-end; margin-top: 20px; }
    
    /* Toast notification styles */
    .toast-container { position: fixed; top: 20px; right: 20px; z-index: 9999; max-width: 400px; }
    .toast { background: var(--card-surface); border: 1px solid var(--border-color); border-radius: 6px; padding: 12px 16px; margin-bottom: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); transform: translateX(100%); transition: transform 0.3s ease; }
    .toast.show { transform: translateX(0); }
    .toast.success { border-left: 4px solid var(--success-color); }
    .toast.error { border-left: 4px solid var(--danger-color); }
    .toast.warning { border-left: 4px solid var(--warning-color); }
    .toast.info { border-left: 4px solid var(--accent-color); }
    .toast-content { display: flex; align-items: center; gap: 8px; font-size: 12px; color: var(--text-primary); }
    .toast-icon { font-size: 14px; }
    .toast-message { flex: 1; }
  </style>
  
  <!-- Import map to resolve bare specifier used by OrbitControls -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
    }
  }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';
    // Expose for existing viewer code without mutating the import namespace
    window.THREE = THREE;
    window.OrbitControls = OrbitControls;
  </script>
</head>
<body>
  <div class="layout">
    <div class="toolbar">
      <!-- Basic Navigation Tools -->
      <button class="tool active" data-tool="window" title="Window/Level Adjustment"><i class="fas fa-adjust"></i><span>Window</span></button>
      <button class="tool" data-tool="zoom" title="Zoom Tool"><i class="fas fa-search-plus"></i><span>Zoom</span></button>
      <button class="tool" data-tool="pan" title="Pan Image"><i class="fas fa-arrows-alt"></i><span>Pan</span></button>
      
      <!-- Measurement Tools -->
      <button class="tool" data-tool="measure" title="Distance Measurement"><i class="fas fa-ruler"></i><span>Measure</span></button>
      <button class="tool" data-tool="annotate" title="Add Annotations"><i class="fas fa-comment-dots"></i><span>Annotate</span></button>
      <button class="tool" data-tool="crosshair" title="Crosshair Overlay"><i class="fas fa-crosshairs"></i><span>Crosshair</span></button>
      
      <!-- Diagnostic Tools -->
      <button class="tool" data-tool="hu" title="Hounsfield Unit Probe"><i class="fas fa-thermometer-half"></i><span>HU</span></button>
      <button class="tool" data-tool="roi" title="Region of Interest"><i class="fas fa-circle"></i><span>ROI</span></button>
      <button class="tool" data-tool="angle" title="Angle Measurement"><i class="fas fa-drafting-compass"></i><span>Angle</span></button>
      
      <!-- Display Controls -->
      <button class="tool" data-tool="invert" title="Invert Colors"><i class="fas fa-adjust"></i><span>Invert</span></button>
      <button class="tool" data-tool="reset" title="Reset View"><i class="fas fa-undo"></i><span>Reset</span></button>
      <button class="tool" data-tool="fit" title="Fit to Window"><i class="fas fa-compress-arrows-alt"></i><span>Fit</span></button>
      <button class="tool" data-tool="one" title="1:1 Zoom"><i class="fas fa-expand"></i><span>1:1</span></button>
      
      <!-- Advanced Tools -->
      <button class="tool" data-tool="cine" title="Cine Mode"><i class="fas fa-film"></i><span>Cine</span></button>
      <button class="tool" data-tool="spyglass" title="Magnifying Glass"><i class="fas fa-search"></i><span>Spyglass</span></button>
      <button class="tool" data-tool="sync" title="Synchronize Views"><i class="fas fa-link"></i><span>Sync</span></button>
      
      <!-- 3D Reconstruction Dropdown -->
      <div class="tool-dropdown">
        <button id="btn3D" class="tool" title="3D Reconstruction Tools"><i class="fas fa-cube"></i><span>3D</span></button>
        <div id="menu3D" class="tool-dropdown-menu">
          <button data-recon="mpr"><i class="fas fa-layer-group"></i> MPR Views</button>
          <button data-recon="mip"><i class="fas fa-bullseye"></i> MIP</button>
          <button data-recon="minip"><i class="fas fa-dot-circle"></i> MinIP</button>
          <button data-recon="vr"><i class="fas fa-cube"></i> Volume Render</button>
          <button data-recon="bone"><i class="fas fa-bone"></i> Bone 3D</button>
          <button data-recon="vessel"><i class="fas fa-heartbeat"></i> Vessel Analysis</button>
          <button data-recon="cardiac"><i class="fas fa-heart"></i> Cardiac 4D</button>
          <button data-recon="ai-3d-print"><i class="fas fa-print"></i> AI 3D Print</button>
        </div>
      </div>
      
      <!-- AI Analysis -->
      <button class="tool" data-tool="ai" title="AI-Assisted Analysis"><i class="fas fa-brain"></i><span>AI</span></button>
    </div>
    <div class="topbar">
      <button id="btnLoadLocal" class="btn-control"><i class="fas fa-folder-open"></i> Load Local DICOM</button>
      <a id="btnBackWorklist" class="btn" href="{% url 'worklist:dashboard' %}" onclick="return returnToWorklist(event)"><i class="fas fa-arrow-left"></i> Back to Worklist</a>
      {% if user.is_authenticated and user.can_edit_reports %}
      <button id="btnWriteReport" class="btn-control" style="display:none"><i class="fas fa-file-signature"></i> Write Report</button>
      {% endif %}
      <input id="localDicom" type="file" multiple webkitdirectory directory accept=".dcm,.dicom,application/dicom" style="display:none" />
      <select id="seriesSelect" class="select"><option value="">Select Series</option></select>
      <select id="sortSelect" class="select">
        <option value="">Sort: Instance # (asc)</option>
        <option value="inst_desc">Instance # (desc)</option>
      </select>
      <button id="btnToggleTags" class="btn"><i class="fas fa-tags"></i> Tags</button>
      <button id="btnShowDicom" class="btn"><i class="fas fa-info-circle"></i> Show DICOM</button>
      <button id="btnCapture" class="btn"><i class="fas fa-camera"></i> Capture</button>
      <button id="btnPrint" class="btn"><i class="fas fa-print"></i> Print</button>
      <div id="patientInfo" style="margin-left:auto;color:#ccc;font-size:13px;">Patient: - | Study Date: - | Modality: -</div>
    </div>
    <div class="viewport" id="viewport">
      <canvas id="dicomCanvas"></canvas>
      <div class="overlay" id="overlay">WW: 400<br>WL: 40<br>Slice: 1/1</div>
      <div class="zoominfo" id="zoominfo">Zoom: 100%</div>
    </div>
    <div class="right">
      <div class="panel">
        <h3>Window/Level</h3>
        <div class="control"><div class="label"><span>Window Width</span><span id="wwVal">400</span></div><input id="ww" type="range" min="1" max="4000" value="400"></div>
        <div class="control"><input id="wwNum" type="number" min="1" max="4000" step="1" value="400"></div>
        <div class="control"><div class="label"><span>Window Level</span><span id="wlVal">40</span></div><input id="wl" type="range" min="-1000" max="1000" value="40"></div>
        <div class="control"><input id="wlNum" type="number" min="-1000" max="1000" step="1" value="40"></div>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:6px;">
          <button class="btn" data-preset="lung">Lung</button>
          <button class="btn" data-preset="bone">Bone</button>
          <button class="btn" data-preset="soft">Soft</button>
          <button class="btn" data-preset="brain">Brain</button>
        </div>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:6px;margin-top:8px;">
          <button id="btnSavePreset" class="btn"><i class="fas fa-bookmark"></i> Save</button>
          <button id="btnLoadPreset" class="btn"><i class="fas fa-list"></i> Load</button>
        </div>
      </div>
      <div class="panel">
        <h3>Measurement Units</h3>
        <div class="control">
          <label class="label" for="unitSelect"><span>Display Unit</span><span id="unitVal">mm</span></label>
          <select id="unitSelect" class="select">
            <option value="mm" selected>Millimeters (mm)</option>
            <option value="cm">Centimeters (cm)</option>
          </select>
        </div>
      </div>
      <div class="panel" id="mprMeasurePanel" style="display:none;">
        <h3>MPR Measurements</h3>
        <div class="control">
          <div class="label"><span>Plane Selection</span></div>
          <select id="mprMeasurePlane" class="select">
            <option value="auto" selected>Auto (by quadrant)</option>
            <option value="axial">Axial</option>
            <option value="sagittal">Sagittal</option>
            <option value="coronal">Coronal</option>
          </select>
        </div>
        <div class="control">
          <div class="label"><span>Measurement</span></div>
          <select id="mprMeasureType" class="select">
            <option value="distance" selected>Distance</option>
          </select>
        </div>
      </div>
      <div class="panel">
        <h3>Navigation</h3>
        <div class="control"><div class="label"><span>Slice</span><span id="sliceVal">1</span></div><input id="slice" type="range" min="0" max="0" value="0"></div>
      </div>
      <div class="panel">
        <h3>Transform</h3>
        <div class="control"><div class="label"><span>Zoom</span><span id="zoomVal">100%</span></div><input id="zoom" type="range" min="25" max="500" value="100"></div>
      </div>
      <div class="panel">
        <h3>3D Reconstruction</h3>
        <div class="control">
          <div class="label"><span>Type</span></div>
          <select id="reconType" class="select">
            <option value="mpr">MPR (Axial/Sagittal/Coronal)</option>
            <option value="mip">MIP (Max Intensity)</option>
            <option value="bone">Bone 3D (threshold)</option>
          </select>
        </div>
        <div class="control" id="boneCtrl" style="display:none;">
          <div class="label"><span>Bone Threshold (HU)</span><span id="boneVal">300</span></div>
          <input id="boneThreshold" type="range" min="100" max="1500" value="300">
        </div>
        <div class="control">
          <button id="btnGenerateRecon" class="btn-control"><i class="fas fa-cogs"></i> Generate</button>
        </div>
        <div class="muted" id="reconStatus"></div>
        <div class="row-3" id="reconViews" style="margin-top:8px; display:none;">
          <img id="viewAxial" alt="Axial" loading="lazy" decoding="async"/>
          <img id="viewSagittal" alt="Sagittal" loading="lazy" decoding="async"/>
          <img id="viewCoronal" alt="Coronal" loading="lazy" decoding="async"/>
        </div>
      </div>
      <div class="panel">
        <h3>Image Info</h3>
        <div id="dimInfo" style="color:var(--text-secondary);font-size:11px;margin-bottom:4px;">Dimensions: -</div>
        <div id="spacingInfo" style="color:var(--text-secondary);font-size:11px;margin-bottom:4px;">Pixel Spacing: -</div>
        <div id="seriesInfo" style="color:var(--text-secondary);font-size:11px;margin-bottom:4px;">Series: -</div>
        <div id="institutionInfo" style="color:var(--text-secondary);font-size:11px;margin-bottom:4px;">Institution: -</div>
        <div id="clinicalInfo" style="color:var(--text-secondary);font-size:11px; margin-top:8px; white-space:pre-wrap;padding:6px;background:var(--secondary-bg);border:1px solid var(--border-color);border-radius:4px;">Clinical Info: -</div>
        <div id="priorityInfo" style="color:var(--text-secondary);font-size:11px;margin-top:4px;">Priority: -</div>
      </div>
      <div class="panel">
        <h3>Advanced 3D Reconstruction</h3>
        <div class="control">
          <label style="font-size:11px;color:#ccc;margin-bottom:4px;">Reconstruction Type:</label>
          <select id="advancedReconType" class="select" onchange="updateReconOptions(this.value)">
            <option value="">Select Reconstruction</option>
            <option value="mpr">MPR (Multi-Planar)</option>
            <option value="mip">MIP (Maximum Intensity)</option>
            <option value="minip">MinIP (Minimum Intensity)</option>
            <option value="vr">Volume Rendering</option>
            <option value="bone">Bone 3D</option>
            <option value="vessel">Vessel Analysis</option>
            <option value="cardiac">Cardiac 4D</option>
            <option value="brain">Brain Analysis</option>
          </select>
        </div>
        
        <!-- Modality-specific options -->
        <div id="ctOptions" class="recon-options" style="display:none;">
          <div class="control">
            <div class="label"><span>Bone Threshold (HU)</span><span id="boneThresholdVal">300</span></div>
            <input type="range" id="boneThreshold" min="100" max="1500" value="300" onchange="updateThreshold('bone', this.value)">
          </div>
          <div class="control">
            <div class="label"><span>Vessel Threshold (HU)</span><span id="vesselThresholdVal">150</span></div>
            <input type="range" id="vesselThreshold" min="50" max="500" value="150" onchange="updateThreshold('vessel', this.value)">
          </div>
        </div>

        <div id="mriOptions" class="recon-options" style="display:none;">
          <div class="control">
            <label style="font-size:11px;color:#ccc;">MRI Sequence:</label>
            <select id="mriSequence" class="select">
              <option value="t1">T1-Weighted</option>
              <option value="t2">T2-Weighted</option>
              <option value="flair">FLAIR</option>
              <option value="dwi">Diffusion (DWI)</option>
              <option value="adc">ADC Map</option>
            </select>
          </div>
        </div>

        <div class="control">
          <button class="btn-control" onclick="generateAdvancedReconstruction()" style="width:100%;margin-top:8px;">
            <i class="fas fa-cube"></i> Generate 3D
          </button>
        </div>
        
        <div id="reconProgress" style="display:none;margin-top:8px;">
          <div style="background:var(--secondary-bg);border-radius:4px;padding:8px;">
            <div style="font-size:11px;color:var(--accent-color);">Processing...</div>
            <div class="progress-bar" style="background:var(--border-color);height:4px;border-radius:2px;margin-top:4px;">
              <div id="reconProgressBar" style="background:var(--accent-color);height:100%;border-radius:2px;width:0%;transition:width 0.3s;"></div>
            </div>
          </div>
        </div>
      </div>

      <div class="panel">
        <h3>MPR Navigation</h3>
        <div id="mprControls" style="display:none;">
          <div class="control">
            <div class="label"><span>Axial Slice</span><span id="axialSliceVal">1</span></div>
            <input type="range" id="axialSlice" min="0" max="100" value="50" onchange="updateMPRSlice('axial', this.value)">
          </div>
          <div class="control">
            <div class="label"><span>Sagittal Slice</span><span id="sagittalSliceVal">1</span></div>
            <input type="range" id="sagittalSlice" min="0" max="100" value="50" onchange="updateMPRSlice('sagittal', this.value)">
          </div>
          <div class="control">
            <div class="label"><span>Coronal Slice</span><span id="coronalSliceVal">1</span></div>
            <input type="range" id="coronalSlice" min="0" max="100" value="50" onchange="updateMPRSlice('coronal', this.value)">
          </div>
          <div class="control">
            <button class="btn-control" onclick="synchronizeMPR()" style="width:100%;">
              <i class="fas fa-link"></i> Sync Crosshairs
            </button>
          </div>
        </div>
        
        <!-- 3D Reconstruction Thumbnails -->
        <div id="reconThumbnails" style="display:none;margin-top:8px;">
          <div class="row-3">
            <img id="thumbAxial" alt="Axial" style="cursor:pointer;" onclick="focusPlane('axial')">
            <img id="thumbSagittal" alt="Sagittal" style="cursor:pointer;" onclick="focusPlane('sagittal')">
            <img id="thumbCoronal" alt="Coronal" style="cursor:pointer;" onclick="focusPlane('coronal')">
          </div>
        </div>
      </div>

      <div class="panel">
        <h3>Diagnostic Tools</h3>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:6px;margin-bottom:8px;">
          <button class="btn-control" onclick="toggleHUProbe()"><i class="fas fa-thermometer-half"></i> HU Values</button>
          <button class="btn-control" onclick="toggleCrosshair()"><i class="fas fa-crosshairs"></i> Crosshair</button>
        </div>
        <div id="huProbeResult" style="background:var(--secondary-bg);border:1px solid var(--border-color);border-radius:4px;padding:8px;margin:8px 0;display:none;">
          <div style="font-size:11px;color:var(--accent-color);font-weight:bold;">Hounsfield Units:</div>
          <div id="huValues" style="font-size:12px;color:var(--text-primary);font-weight:bold;">Click on image</div>
        </div>
      </div>

      <div class="panel">
        <h3>Measurements</h3>
        <div class="control">
          <button id="btnClearMeasurements" class="btn">Clear All</button>
        </div>
        <ul id="measurementsList" style="list-style:none;padding-left:0;margin:0;color:var(--text-secondary);font-size:11px;"></ul>
      </div>
    </div>
  </div>

  <!-- Toast notification container -->
  <div class="toast-container" id="toastContainer"></div>

  <!-- Three.js for rotatable bone mesh (loaded only if used) -->
  <!-- Removed deprecated UMD scripts; using ES Modules via importmap -->
  <div id="threeContainer">
    <button id="close3d" class="btn">Close 3D</button>
    <div id="threeMount"></div>
  </div>
  <div id="dicomModal">
    <div class="modal-card">
      <div class="modal-header">
        <h3 style="margin:0;">DICOM Tags</h3>
        <button id="closeDicomModal" class="btn">Close</button>
      </div>
      <pre id="dicomTagsPre" style="white-space:pre-wrap; color:#ddd;"></pre>
    </div>
  </div>

  <!-- Print Modal -->
  <div id="printModal">
    <div class="modal-card">
      <div class="modal-header">
        <h3>Print DICOM Image</h3>
        <button id="closePrintModal" class="btn">Close</button>
      </div>
      <form id="printForm">
        <div class="form-group">
          <label for="printMedium">Print Medium:</label>
          <select id="printMedium" name="print_medium">
            <option value="paper">📄 Paper</option>
            <option value="film">🎞️ Medical Film</option>
          </select>
        </div>
        <div class="form-group">
          <label for="layoutType">Layout:</label>
          <select id="layoutType" name="layout_type">
            <option value="single">Single Image</option>
            <option value="quad">Quad Layout (4 images)</option>
            <option value="comparison">Side-by-Side Comparison</option>
            <option value="film_standard">Film Standard (minimal text)</option>
          </select>
          <div class="form-text" id="layoutDescription">One image per page with full details</div>
        </div>
        <div class="form-group">
          <label for="printerSelect">Printer:</label>
          <select id="printerSelect" name="printer_name">
            <option value="">Loading printers...</option>
          </select>
        </div>
        <div class="form-group">
          <label for="paperSize">Paper/Film Size:</label>
          <select id="paperSize" name="paper_size">
            <option value="A4">A4 (210 × 297 mm)</option>
            <option value="Letter">Letter (8.5 × 11 in)</option>
            <option value="FILM_14X17">Film 14" × 17"</option>
            <option value="FILM_11X14">Film 11" × 14"</option>
          </select>
        </div>
        <div class="form-group" id="paperTypeGroup">
          <label for="paperType">Paper Type:</label>
          <select id="paperType" name="paper_type">
            <option value="glossy">🌟 Glossy Photo Paper</option>
            <option value="matte">Matte Paper</option>
            <option value="plain">Plain Paper</option>
            <option value="film">Medical Film</option>
          </select>
        </div>
        <div class="form-group">
          <label for="printQuality">Print Quality:</label>
          <select id="printQuality" name="print_quality">
            <option value="high">High Quality (1200 DPI)</option>
            <option value="normal">Normal Quality (600 DPI)</option>
            <option value="draft">Draft Quality (300 DPI)</option>
          </select>
        </div>
        <div class="form-group">
          <label for="copies">Number of Copies:</label>
          <input type="number" id="copies" name="copies" value="1" min="1" max="10">
        </div>
        <div class="btn-group">
          <button type="button" id="cancelPrint" class="btn">Cancel</button>
          <button type="submit" id="submitPrint" class="btn btn-primary">
            <i class="fas fa-print"></i> Print Image
          </button>
        </div>
      </form>
    </div>
  </div>

  <script>
  (function(){
    const canvas = document.getElementById('dicomCanvas');
    const ctx = canvas.getContext('2d');
    const seriesSelect = document.getElementById('seriesSelect');
    const wwSlider = document.getElementById('ww');
    const wlSlider = document.getElementById('wl');
    const wwNum = document.getElementById('wwNum');
    const wlNum = document.getElementById('wlNum');
    const sliceSlider = document.getElementById('slice');
    const zoomSlider = document.getElementById('zoom');
    const btnLoadLocal = document.getElementById('btnLoadLocal');
    const inputLocal = document.getElementById('localDicom');
    const btnClearMeasurements = document.getElementById('btnClearMeasurements');
    const measurementsList = document.getElementById('measurementsList');

    const reconType = document.getElementById('reconType');
    const boneCtrl = document.getElementById('boneCtrl');
    const boneSlider = document.getElementById('boneThreshold');
    const boneVal = document.getElementById('boneVal');
    const btnGenerateRecon = document.getElementById('btnGenerateRecon');
    const reconStatus = document.getElementById('reconStatus');
    const reconViews = document.getElementById('reconViews');
    const viewAxial = document.getElementById('viewAxial');
    const viewSagittal = document.getElementById('viewSagittal');
    const viewCoronal = document.getElementById('viewCoronal');

    // 3D dropdown controls
          const btn3D = document.getElementById('btn3D');
      const menu3D = document.getElementById('menu3D');
      // Reduce initial image decode overhead for large previews
      [viewAxial, viewSagittal, viewCoronal].forEach(img=>{ if(img){ img.loading='eager'; img.decoding='async'; }});

    // Topbar extras
    const sortSelect = document.getElementById('sortSelect');
    const btnToggleTags = document.getElementById('btnToggleTags');
    const btnShowDicom = document.getElementById('btnShowDicom');
    const btnCapture = document.getElementById('btnCapture');
    const dicomModal = document.getElementById('dicomModal');
    const dicomTagsPre = document.getElementById('dicomTagsPre');
    const closeDicomModal = document.getElementById('closeDicomModal');
    const btnSavePreset = document.getElementById('btnSavePreset');
    const btnLoadPreset = document.getElementById('btnLoadPreset');

    let currentStudy = null;
    let currentSeries = null;
    let images = [];
    let index = 0;
    let ww = 400, wl = 40, inverted = false, zoom = 1.0;
    let defaultWw = 400, defaultWl = 40;
    let mprMode = false;
    let mprImgs = { axial: null, sagittal: null, coronal: null };
    let reconMode = null; // 'mpr' | 'mip' | 'bone' | null
    let reconImgs = []; // ordered list of image data URLs for canvas display
    let reconIndex = 0;
    // MPR plane browsing state
    let mprScroll = { axial: 0, sagittal: 0, coronal: 0, counts: { axial: 0, sagittal: 0, coronal: 0 } };
    // Crosshair linkage across planes (x: sagittal index, y: coronal index, z: axial index)
    let mprCross = { x: null, y: null, z: null };
    let showHuProbe = false;
    let huEllipse = null;
    let activeTool = 'window';
    let isDragging = false;
    let dragStart = null;
    let panOffset = { x: 0, y: 0 };
    let measureDraft = null; // {start:{x,y}, end:{x,y}}
    let measurements = []; // persisted per image id
    let annotations = [];
    let crosshair = false;
    let measureUnit = 'mm';
    let mprMeasurements = { axial: [], sagittal: [], coronal: [] };
    let mprMeasurePlaneMode = 'auto'; // 'auto' | 'axial' | 'sagittal' | 'coronal'
    let mprMeasureType = 'distance';
    const mprImageCache = new Map(); // key: series|plane|slice|ww|wl|inv -> Promise<string>|string

    // New states
    let showTagsOverlay = false;
    let currentImageTags = null;
    let cineActive = false; let cineTimer = null; let cineFps = 12;
    let spyglass = { active:false, radius:80, factor:2.0, invert:false, isPress:false, cx:0, cy:0 };
    let mprFullPlane = null; // enlarged plane key when in MPR

    // Track last viewport mapping for precise coordinate transforms
    let lastVp = null; // {x,y,scale,imgW,imgH}
    const mprRegionVps = {}; // key-> {x,y,scale,imgW,imgH,rect}

    // Map imageId -> arrays to persist while session active
    const imageIdToMeasurements = new Map();
    const imageIdToAnnotations = new Map();

    // Image cache and render scheduler to improve responsiveness
    const imageCache = new Map(); // key -> Promise<HTMLImageElement> | HTMLImageElement
    let drawScheduled = false;
    const userCanEdit = {% if user.can_edit_reports %}true{% else %}false{% endif %};
    function requestDraw(){
      if (drawScheduled) return;
      drawScheduled = true;
      requestAnimationFrame(async ()=>{ drawScheduled = false; await draw(); });
    }
    function debounce(fn, delay){
      let t; return (...args)=>{ clearTimeout(t); t = setTimeout(()=> fn(...args), delay); };
    }
    // Cancelable overlay requests
    let overlayRequestId = 0;
    function getImageKey(imageId, ww, wl, inverted){
      return `${imageId}|${Math.round(ww)}|${Math.round(wl)}|${inverted?1:0}`;
    }
    async function loadHtmlImage(src){
      return new Promise((resolve, reject)=>{ const im = new Image(); im.crossOrigin = 'anonymous'; im.decoding = 'async'; im.onload = ()=> resolve(im); im.onerror = reject; im.src = src; });
    }
    async function getImageForIndex(i){
      const imgMeta = images[i];
      if (!imgMeta) return null;
      const key = getImageKey(imgMeta.id, ww, wl, inverted);
      if (imageCache.has(key)){
        const val = imageCache.get(key);
        return typeof val.then === 'function' ? await val : val;
      }
      const url = `/dicom-viewer/image/${imgMeta.id}/?ww=${ww}&wl=${wl}&invert=${inverted}`;
      const promise = loadHtmlImage(url).then(im=>{ imageCache.set(key, im); return im; }).catch(err=>{ imageCache.delete(key); throw err; });
      imageCache.set(key, promise);
      return await promise;
    }
    function prefetchIndex(i){
      if (i < 0 || i >= images.length) return;
      const imgMeta = images[i];
      const key = getImageKey(imgMeta.id, ww, wl, inverted);
      if (imageCache.has(key)) return;
      const url = `/dicom-viewer/image/${imgMeta.id}/?ww=${ww}&wl=${wl}&invert=${inverted}`;
      const promise = loadHtmlImage(url).then(im=>{ imageCache.set(key, im); return im; }).catch(()=>{ imageCache.delete(key); });
      imageCache.set(key, promise);
    }
    function prefetchAround(center, radius=3){
      for (let o = -radius; o <= radius; o++){
        if (o === 0) continue;
        prefetchIndex(center + o);
      }
    }
    const debouncedLoadOverlaysForCurrentImage = debounce(()=>{ loadOverlaysForCurrentImage(); }, 80);

    // Helper: parse pixel spacing robustly (string "0.5\\0.5", "0.5,0.5" or array)
    function parsePixelSpacing(ps){
      if (!ps) return null;
      if (Array.isArray(ps)) return ps.map(Number);
      if (typeof ps === 'string'){
        const parts = ps.split(/[\\,\s]+/).filter(Boolean);
        if (parts.length >= 2) return [parseFloat(parts[0]), parseFloat(parts[1])];
      }
      return null;
    }

    async function fallbackToDesktop(){
      try {
        const params = new URLSearchParams(window.location.search);
        const studyId = params.get('study_id') || (currentStudy && currentStudy.id);
        if (studyId){
          const resp = await fetch(`/dicom-viewer/launch-desktop/${studyId}/`);
          const j = await resp.json();
          if (j && j.fallback_url){ window.location.href = j.fallback_url; return; }
          // Desktop launched; leave page as-is
        } else {
          const resp = await fetch('/dicom-viewer/launch-desktop/', { method:'POST', headers:{'Content-Type':'application/json'}, body: '{}' });
          const j = await resp.json();
          if (j && j.fallback_url){ window.location.href = j.fallback_url; return; }
        }
      } catch (e) {
        // swallow
      }
    }

    function setCanvasSize(){
      const vp = document.getElementById('viewport');
      const rect = vp.getBoundingClientRect();
      canvas.width = Math.max(100, rect.width - 20);
      canvas.height = Math.max(100, rect.height - 20);
    }
    window.addEventListener('resize', ()=>{ setCanvasSize(); requestDraw(); });

    function q(name){ return new URLSearchParams(window.location.search).get(name); }
    
    function getCookie(name){
      const value = `; ${document.cookie}`;
      const parts = value.split(`; ${name}=`);
      if (parts.length === 2) {
        const token = parts.pop().split(';').shift();
        return token && token.trim() ? token : null;
      }
      return null;
    }

    async function loadStudy(studyId){
      try {
        const r = await fetch(`/dicom-viewer/api/study/${studyId}/data/`);
        if (!r.ok) throw new Error('study fetch failed');
        const data = await r.json();
        currentStudy = data.study;
        // Enable write report button when study is known
        const wr = document.getElementById('btnWriteReport');
        if (wr && currentStudy && currentStudy.id){
          wr.style.display = '';
          wr.onclick = function(){ window.location.href = `/reports/write/${currentStudy.id}/`; };
        }
        // Mark study as in_progress when opened by editor roles
        try {
          if (userCanEdit && currentStudy && currentStudy.id){
            const headers = { 'Content-Type': 'application/json' };
            const csrfToken = getCookie('csrftoken');
            if (csrfToken) {
              headers['X-CSRFToken'] = csrfToken;
            }
            await fetch(`/worklist/api/study/${currentStudy.id}/update-status/`, {
              method: 'POST',
              headers: headers,
              body: JSON.stringify({ status: 'in_progress' }),
              credentials: 'same-origin'
            });
          }
        } catch (_) { /* non-blocking */ }
        document.getElementById('patientInfo').textContent = `Patient: ${currentStudy.patient_name} | Study Date: ${currentStudy.study_date} | Modality: ${currentStudy.modality}`;
        // Show clinical info and priority
        const clin = (currentStudy.clinical_info && currentStudy.clinical_info.trim()) ? currentStudy.clinical_info : '-';
        document.getElementById('clinicalInfo').textContent = `Clinical Info: ${clin}`;
        document.getElementById('priorityInfo').textContent = `Priority: ${currentStudy.priority ? currentStudy.priority.toString().toUpperCase() : '-'}`;
        seriesSelect.innerHTML = '<option value="">Select Series</option>';
        (data.series_list || []).forEach(s=>{
          const opt = document.createElement('option');
          opt.value = s.id; opt.textContent = `Series ${s.series_number} - ${s.modality} (${s.image_count} images)`;
          seriesSelect.appendChild(opt);
        });
        if ((data.series_list||[]).length){
          seriesSelect.value = data.series_list[0].id;
          await loadSeries(data.series_list[0].id);
        }
        // Apply suggested hanging protocol
        try {
          const hpq = new URLSearchParams(); hpq.set('modality', currentStudy.modality||'');
          const rhp = await fetch(`/dicom-viewer/api/hanging/?${hpq.toString()}`); const hp = await rhp.json();
          if (hp && hp.suggested && hp.suggested.layout === 'mpr-3plane') { generateReconstruction('mpr'); }
        } catch(e){}
      } catch (e) {
        await fallbackToDesktop();
      }
    }

    async function loadSeries(seriesId){
      try {
        const r = await fetch(`/dicom-viewer/series/${seriesId}/images/`);
        if (!r.ok) throw new Error('series fetch failed');
        const data = await r.json();
        currentSeries = data.series; images = data.images || []; index = 0;
        imageCache.clear();
        sliceSlider.max = Math.max(0, images.length - 1); sliceSlider.value = 0; document.getElementById('sliceVal').textContent = '1';
        if (images.length){
          const probe = await fetch(`/dicom-viewer/api/image/${images[0].id}/display/`);
          if (probe.ok){
            const j = await probe.json();
            if (j && j.image_info){
              ww = j.image_info.default_window_width || ww;
              wl = j.image_info.default_window_level || wl;
              defaultWw = ww; defaultWl = wl;
              if (j.windowing && typeof j.windowing.inverted === 'boolean') { inverted = j.windowing.inverted; }
            }
          }
          wwSlider.value = Math.round(ww); wlSlider.value = Math.round(wl); wwNum.value = Math.round(ww); wlNum.value = Math.round(wl); document.getElementById('wwVal').textContent = Math.round(ww); document.getElementById('wlVal').textContent = Math.round(wl);
        }
        // Reset view state
        zoom = 1.0; panOffset = {x:0,y:0}; activeTool = 'window'; crosshair = false; mprMode = false; mprImgs = {axial:null,sagittal:null,coronal:null}; reconMode = null; reconImgs = []; reconIndex = 0;
        mprCross = { x: null, y: null, z: null }; // reset crosshair linkage
        mprMeasurements = { axial: [], sagittal: [], coronal: [] };
        mprImageCache.clear();
        const enterMpr = document.getElementById('btnEnterMpr');
        const exitMpr = document.getElementById('btnExitMpr');
        if (enterMpr) enterMpr.style.display = images.length ? '' : 'none';
        if (exitMpr) exitMpr.style.display = 'none';
        document.querySelectorAll('.tool').forEach(x=>x.classList.remove('active'));
        document.querySelector('.tool[data-tool="window"]').classList.add('active');
        setCanvasSize();
        await draw();
        await loadOverlaysForCurrentImage();
        // Prefetch neighbors
        prefetchAround(0, 3);
        // Warm up MPR mid-slices so first MPR is instant
        try { warmupMpr(); } catch(e) {}
      } catch (e) {
        await fallbackToDesktop();
      }
    }

    function getCurrentImageId(){
      if (!images.length) return null;
      return images[index].id;
    }

    function getViewportPlacement(imgW, imgH){
      const scale = Math.min(canvas.width / imgW, canvas.height / imgH) * zoom;
      const w = imgW * scale, h = imgH * scale;
      const x = (canvas.width - w)/2 + panOffset.x;
      const y = (canvas.height - h)/2 + panOffset.y;
      return { scale, w, h, x, y };
    }

    async function draw(){
      if (!images.length && reconImgs.length===0) { ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height); return; }
      if (mprMode){
        try{
          // Enlarge one plane if set
          if (mprFullPlane){
            // Ensure image for that plane is current
            if (!mprImgs[mprFullPlane]){
              try {
                const img = await getMprImage(currentSeries.id, mprFullPlane, mprScroll[mprFullPlane] || 0);
                mprImgs[mprFullPlane] = img;
              } catch(e){}
            }
            ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
            const imgSrc = mprImgs[mprFullPlane];
            if (imgSrc){
              try {
                const im = await loadImage(imgSrc);
                const scale = Math.min(canvas.width / im.width, canvas.height / im.height);
                const dw = im.width * scale, dh = im.height * scale;
                const dx = (canvas.width - dw)/2, dy = (canvas.height - dh)/2;
                if (ctx.imageSmoothingEnabled !== false) ctx.imageSmoothingEnabled = false; 
                ctx.drawImage(im, dx, dy, dw, dh);
                mprRegionVps[mprFullPlane] = { x: dx, y: dy, scale: scale, imgW: im.width, imgH: im.height, rect: {x:0,y:0,w:canvas.width,h:canvas.height} };
                if (huEllipse && huEllipse.mode==='mpr' && huEllipse.plane===mprFullPlane){ drawEllipseOverlay(mprFullPlane); }
                // Draw linked crosshair on enlarged plane (only if enabled)
                if (crosshair) { drawMprCrosshairOverlay(mprFullPlane, dx, dy, scale, im.width, im.height); }
              } catch (e) {
                console.error(`Failed to load full plane ${mprFullPlane} image:`, e);
                // Draw placeholder
                ctx.save();
                ctx.fillStyle = '#333';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#666';
                ctx.font = '24px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('Loading 3D View...', canvas.width/2, canvas.height/2);
                ctx.restore();
              }
            }
            document.getElementById('overlay').innerHTML = `MPR (${mprFullPlane.toUpperCase()}) | WW: ${Math.round(ww)}<br>WL: ${Math.round(wl)}`;
            document.getElementById('zoominfo').textContent = `MPR`;
            return;
          }
          // Ensure counts and initial mid-slice indices are loaded
          if (!mprImgs.axial || !mprImgs.sagittal || !mprImgs.coronal){
            const params = new URLSearchParams(); params.set('window_width', ww); params.set('window_level', wl); params.set('inverted', inverted);
            const r = await fetch(`/dicom-viewer/api/series/${currentSeries.id}/mpr/?${params.toString()}`);
            const j = await r.json();
            if (j && j.mpr_views){ mprImgs = j.mpr_views; }
            if (j && j.counts){
              mprScroll.counts = j.counts;
              mprScroll.axial = Math.floor((j.counts.axial||0)/2);
              mprScroll.sagittal = Math.floor((j.counts.sagittal||0)/2);
              mprScroll.coronal = Math.floor((j.counts.coronal||0)/2);
              if (mprCross.x === null || mprCross.y === null || mprCross.z === null){
                mprCross = {
                  x: mprScroll.sagittal,
                  y: mprScroll.coronal,
                  z: mprScroll.axial
                };
              }
              // Immediately request exact mid slices for all planes
              await Promise.all([
                getMprImage(currentSeries.id, 'axial', mprScroll.axial).then(img=>{ mprImgs.axial = img; }).catch(err=>{ console.error('Failed to load axial MPR image:', err); }),
                getMprImage(currentSeries.id, 'sagittal', mprScroll.sagittal).then(img=>{ mprImgs.sagittal = img; }).catch(err=>{ console.error('Failed to load sagittal MPR image:', err); }),
                getMprImage(currentSeries.id, 'coronal', mprScroll.coronal).then(img=>{ mprImgs.coronal = img; }).catch(err=>{ console.error('Failed to load coronal MPR image:', err); })
              ]);
              prefetchMprSlices('axial', mprScroll.axial);
              prefetchMprSlices('sagittal', mprScroll.sagittal);
              prefetchMprSlices('coronal', mprScroll.coronal);
            }
          }
          ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
          const halfW = Math.floor(canvas.width/2), halfH = Math.floor(canvas.height/2);
          const regions = [
            { x: 0, y: 0, w: halfW, h: halfH, key: 'sagittal' },
            { x: halfW, y: 0, w: canvas.width - halfW, h: halfH, key: 'coronal' },
            { x: 0, y: halfH, w: halfW, h: canvas.height - halfH, key: 'axial' },
            { x: halfW, y: halfH, w: canvas.width - halfW, h: canvas.height - halfH, key: 'empty' },
          ];
          // Crosshair dividing lines
          ctx.save();
          ctx.strokeStyle = 'rgba(0,255,255,0.8)';
          ctx.beginPath();
          ctx.moveTo(halfW, 0); ctx.lineTo(halfW, canvas.height);
          ctx.moveTo(0, halfH); ctx.lineTo(canvas.width, halfH);
          ctx.stroke();
          ctx.restore();
          // Draw regions using available images immediately, then refresh asynchronously
          for (const reg of regions){
            if (reg.key === 'empty') continue;
            const imgSrc = mprImgs[reg.key];
            if (imgSrc){
              try {
                const im = await loadImage(imgSrc);
                const scale = Math.min(reg.w / im.width, reg.h / im.height);
                const dw = im.width * scale, dh = im.height * scale;
                const dx = reg.x + (reg.w - dw)/2, dy = reg.y + (reg.h - dh)/2;
                // Hint to use low quality interpolation for speed
                if (ctx.imageSmoothingEnabled !== false) ctx.imageSmoothingEnabled = false;
                ctx.drawImage(im, dx, dy, dw, dh);
                // Save mapping for tools
                mprRegionVps[reg.key] = { x: dx, y: dy, scale: scale, imgW: im.width, imgH: im.height, rect: reg };
              } catch (e) {
                console.error(`Failed to load ${reg.key} image:`, e);
                // Draw placeholder for failed image but keep trying
                ctx.save();
                ctx.fillStyle = '#333';
                ctx.fillRect(reg.x, reg.y, reg.w, reg.h);
                ctx.fillStyle = '#666';
                ctx.font = '12px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('Loading...', reg.x + reg.w/2, reg.y + reg.h/2);
                ctx.restore();
              }
              // Draw plane label and slice index (use region coordinates if image failed)
              const labelX = (mprRegionVps[reg.key] ? mprRegionVps[reg.key].x : reg.x) + 8;
              const labelY = (mprRegionVps[reg.key] ? mprRegionVps[reg.key].y : reg.y) + 8;
              ctx.save();
              ctx.fillStyle = 'rgba(0,0,0,0.5)';
              ctx.fillRect(labelX, labelY, 180, 22);
              ctx.fillStyle = '#0ff';
              ctx.font = '12px monospace';
              // Enhanced plane label with crosshair coordinates
              const crossInfo = `${reg.key.toUpperCase()} ${ (mprScroll[reg.key]||0) + 1 }/${ mprScroll.counts[reg.key]||0 }`;
              let coordInfo = '';
              if (mprCross.x !== null && mprCross.y !== null && mprCross.z !== null) {
                if (reg.key === 'axial') coordInfo = ` [${mprCross.x},${mprCross.y}]`;
                else if (reg.key === 'sagittal') coordInfo = ` [${mprCross.y},${mprCross.z}]`;
                else if (reg.key === 'coronal') coordInfo = ` [${mprCross.x},${mprCross.z}]`;
              }
              ctx.fillText(crossInfo + coordInfo, labelX + 4, labelY + 16);
              ctx.restore();
              // Draw measurement overlays for this plane
              ctx.save();
              ctx.strokeStyle = 'yellow'; ctx.fillStyle = 'yellow'; ctx.lineWidth = 2;
              const planeMeasures = mprMeasurements[reg.key] || [];
              if (mprRegionVps[reg.key]) {
                const vp = mprRegionVps[reg.key];
                for (const m of planeMeasures){
                  const x1 = vp.x + m.start.x * vp.scale, y1 = vp.y + m.start.y * vp.scale;
                  const x2 = vp.x + m.end.x * vp.scale, y2 = vp.y + m.end.y * vp.scale;
                  ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
                  if (m.label){ ctx.font='12px monospace'; ctx.fillText(m.label, x2 + 6, y2 - 6); }
                }
                // Draft line if belongs to this plane
                if (measureDraft && measureDraft.plane === reg.key && measureDraft.start && measureDraft.end){
                  const x1 = vp.x + measureDraft.start.x * vp.scale, y1 = vp.y + measureDraft.start.y * vp.scale;
                  const x2 = vp.x + measureDraft.end.x * vp.scale, y2 = vp.y + measureDraft.end.y * vp.scale;
                  ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
                }
              }
              ctx.restore();
              // Draw HU ellipse overlay if belongs to this plane
              if (huEllipse && huEllipse.mode==='mpr' && huEllipse.plane===reg.key){
                drawEllipseOverlay(reg.key);
              }
              // Draw linked crosshair overlay for this plane (only if enabled)
              if (crosshair && mprRegionVps[reg.key]) { 
                const vp = mprRegionVps[reg.key];
                drawMprCrosshairOverlay(reg.key, vp.x, vp.y, vp.scale, vp.imgW, vp.imgH); 
              }
            }
            // Fetch updated slice without blocking draw
            (async ()=>{
              try {
                const img = await getMprImage(currentSeries.id, reg.key, mprScroll[reg.key] || 0);
                mprImgs[reg.key] = img; requestAnimationFrame(()=>draw());
              } catch(e){ console.error('Failed to load MPR image for plane', reg.key, ':', e); }
            })();
          }
          document.getElementById('overlay').innerHTML = `MPR | WW: ${Math.round(ww)}<br>WL: ${Math.round(wl)}`;
          document.getElementById('zoominfo').textContent = `MPR`;
          return;
        } catch(e){ /* fallback to normal draw below */ }
      }
      if (reconMode && reconImgs.length){
        try {
          console.log(`Drawing reconstruction mode: ${reconMode}, images: ${reconImgs.length}`);
          ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
          if (reconMode === 'mip' || reconMode === 'bone'){
            console.log(`Drawing 3-plane ${reconMode} reconstruction`);
            // Draw 3-plane grid similar to MPR using the three recon previews
            const imgs = [];
            for (let i=0;i<3;i++){ 
              if (reconImgs[i]) { 
                try { 
                  imgs[i] = await loadImage(reconImgs[i]); 
                  console.log(`Loaded image ${i}: ${imgs[i].width}x${imgs[i].height}`);
                } catch(e){ 
                  console.error(`Failed to load image ${i}:`, e);
                  imgs[i] = null; 
                } 
              } else {
                console.warn(`No image data for index ${i}`);
              }
            }
            const halfW = Math.floor(canvas.width/2), halfH = Math.floor(canvas.height/2);
            const regions = [
              { x: 0, y: 0, w: halfW, h: halfH, key: 'sagittal', im: imgs[1] },
              { x: halfW, y: 0, w: canvas.width - halfW, h: halfH, key: 'coronal', im: imgs[2] },
              { x: 0, y: halfH, w: halfW, h: canvas.height - halfH, key: 'axial', im: imgs[0] },
              { x: halfW, y: halfH, w: canvas.width - halfW, h: canvas.height - halfH, key: 'empty', im: null },
            ];
            // Crosshair dividing lines
            ctx.save(); ctx.strokeStyle = 'rgba(0,255,255,0.8)'; ctx.beginPath(); ctx.moveTo(halfW, 0); ctx.lineTo(halfW, canvas.height); ctx.moveTo(0, halfH); ctx.lineTo(canvas.width, halfH); ctx.stroke(); ctx.restore();
            for (const reg of regions){
              if (!reg.im) continue;
              const im = reg.im;
              const scale = Math.min(reg.w / im.width, reg.h / im.height);
              const dw = im.width * scale, dh = im.height * scale;
              const dx = reg.x + (reg.w - dw)/2 + panOffset.x; const dy = reg.y + (reg.h - dh)/2 + panOffset.y;
              ctx.imageSmoothingEnabled = false;
              ctx.drawImage(im, dx, dy, dw, dh);
              // Label
              ctx.save(); ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(dx + 8, dy + 8, 150, 22); ctx.fillStyle = '#0ff'; ctx.font = '12px monospace'; ctx.fillText(`${reg.key.toUpperCase()}`, dx + 12, dy + 24); ctx.restore();
            }
            document.getElementById('overlay').innerHTML = `${reconMode.toUpperCase()} | 3-Plane`;
            document.getElementById('zoominfo').textContent = `${reconMode.toUpperCase()}`;
            return;
          } else {
            const im = await loadImage(reconImgs[reconIndex]);
            const scale = Math.min(canvas.width / im.width, canvas.height / im.height) * zoom;
            const dw = im.width * scale, dh = im.height * scale;
            const dx = (canvas.width - dw)/2 + panOffset.x; const dy = (canvas.height - dh)/2 + panOffset.y;
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(im, dx, dy, dw, dh);
            lastVp = { x: dx, y: dy, scale: scale, imgW: im.width, imgH: im.height };
            document.getElementById('overlay').innerHTML = `${reconMode.toUpperCase()} | View ${reconIndex+1}/${reconImgs.length}`;
            document.getElementById('zoominfo').textContent = `Zoom: ${Math.round(zoom*100)}%`;
            return;
          }
        } catch(e){}
      }
      try {
        const htmlImg = await getImageForIndex(index);
        const vp = getViewportPlacement(htmlImg.width, htmlImg.height);
        ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
                 if (ctx.imageSmoothingEnabled !== false) ctx.imageSmoothingEnabled = false;
         ctx.drawImage(htmlImg, vp.x, vp.y, vp.w, vp.h);
        lastVp = { x: vp.x, y: vp.y, scale: vp.scale, imgW: htmlImg.width, imgH: htmlImg.height };
        drawOverlays(vp);
        if (huEllipse && huEllipse.mode==='series') drawEllipseOverlay();
        // Spyglass lens on top
        if (spyglass.active && spyglass.isPress && lastVp){
          ctx.save();
          const r = Math.max(20, spyglass.radius);
          // Clip circle
          ctx.beginPath(); ctx.arc(spyglass.cx, spyglass.cy, r, 0, Math.PI*2); ctx.clip();
          // Compute anchor image coords under cursor
          const imgPt = canvasToImageCoords(lastVp, spyglass.cx, spyglass.cy);
          const factor = Math.max(1.2, spyglass.factor);
          const scale2 = lastVp.scale * factor;
          const dw2 = lastVp.imgW * scale2, dh2 = lastVp.imgH * scale2;
          const dx2 = spyglass.cx - (imgPt.x * scale2);
          const dy2 = spyglass.cy - (imgPt.y * scale2);
          ctx.imageSmoothingEnabled = false;
          ctx.drawImage(htmlImg, dx2, dy2, dw2, dh2);
          if (spyglass.invert){
            // Invert only inside lens
            const imgData = ctx.getImageData(spyglass.cx - r, spyglass.cy - r, r*2, r*2);
            const d = imgData.data; for (let i=0;i<d.length;i+=4){ d[i]=255-d[i]; d[i+1]=255-d[i+1]; d[i+2]=255-d[i+2]; }
            ctx.putImageData(imgData, spyglass.cx - r, spyglass.cy - r);
          }
          ctx.restore();
          // Lens ring and info
          ctx.save(); ctx.strokeStyle = '#0ff'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(spyglass.cx, spyglass.cy, r, 0, Math.PI*2); ctx.stroke(); ctx.restore();
          document.getElementById('overlay').innerHTML = `WW: ${Math.round(ww)}<br>WL: ${Math.round(wl)}<br>Slice: ${index+1}/${images.length}<br>Spyglass x:${Math.round(imgPt.x)} y:${Math.round(imgPt.y)} mag:${factor.toFixed(1)}x`;
        }
        if (showTagsOverlay && currentImageTags){
          const lines = [];
          const t = currentImageTags;
          if (t.patient_name) lines.push(`Patient: ${t.patient_name}`);
          if (t.study_date) lines.push(`Study: ${t.study_date}`);
          if (t.series_number !== undefined) lines.push(`Series#: ${t.series_number}`);
          if (images[index] && images[index].instance_number !== undefined) lines.push(`Instance#: ${images[index].instance_number}`);
          if (t.slice_thickness) lines.push(`Slice Thk: ${t.slice_thickness}`);
          if (t.pixel_spacing) lines.push(`Pix Spacing: ${t.pixel_spacing}`);
          ctx.save();
          ctx.fillStyle = 'rgba(0,0,0,0.6)';
          ctx.fillRect(canvas.width - 260, 12, 248, lines.length*16 + 10);
          ctx.fillStyle = '#ddd'; ctx.font = '12px monospace';
          lines.forEach((ln, i)=> ctx.fillText(ln, canvas.width - 250, 28 + i*16));
          ctx.restore();
        }
        document.getElementById('overlay').innerHTML = `WW: ${Math.round(ww)}<br>WL: ${Math.round(wl)}<br>Slice: ${index+1}/${images.length}`;
        document.getElementById('zoominfo').textContent = `Zoom: ${Math.round(zoom*100)}%`;
        // Opportunistically prefetch neighbors
        prefetchAround(index, 3);
      } catch (e) {
        await fallbackToDesktop();
      }
    }

    function drawMprCrosshairOverlay(planeKey, dx, dy, scale, imgW, imgH){
      if (mprCross.x === null || mprCross.y === null || mprCross.z === null) return;
      
      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,0,0.9)';
      ctx.lineWidth = 1;
      
      // Optimized crosshair drawing - ensure coordinates are valid
      if (planeKey === 'axial'){
        const cx = dx + Math.max(0, Math.min(imgW - 1, mprCross.x)) * scale;
        const cy = dy + Math.max(0, Math.min(imgH - 1, mprCross.y)) * scale;
        ctx.beginPath();
        ctx.moveTo(cx, dy); 
        ctx.lineTo(cx, dy + imgH * scale);
        ctx.moveTo(dx, cy); 
        ctx.lineTo(dx + imgW * scale, cy);
        ctx.stroke();
      } else if (planeKey === 'sagittal'){
        // sagittal image axes: x=height(y), y=depth(z)
        const cx = dx + Math.max(0, Math.min(imgW - 1, mprCross.y)) * scale;
        const cy = dy + Math.max(0, Math.min(imgH - 1, mprCross.z)) * scale;
        ctx.beginPath();
        ctx.moveTo(cx, dy); 
        ctx.lineTo(cx, dy + imgH * scale);
        ctx.moveTo(dx, cy); 
        ctx.lineTo(dx + imgW * scale, cy);
        ctx.stroke();
      } else if (planeKey === 'coronal'){
        // coronal image axes: x=width(x), y=depth(z)
        const cx = dx + Math.max(0, Math.min(imgW - 1, mprCross.x)) * scale;
        const cy = dy + Math.max(0, Math.min(imgH - 1, mprCross.z)) * scale;
        ctx.beginPath();
        ctx.moveTo(cx, dy); 
        ctx.lineTo(cx, dy + imgH * scale);
        ctx.moveTo(dx, cy); 
        ctx.lineTo(dx + imgW * scale, cy);
        ctx.stroke();
      }
      ctx.restore();
    }

    function drawOverlays(vp){
      // Measurements (draft first)
      ctx.save();
      ctx.strokeStyle = 'yellow';
      ctx.fillStyle = 'yellow';
      ctx.lineWidth = 2;
      const toCanvas = (p)=>({
        x: vp.x + p.x * vp.scale,
        y: vp.y + p.y * vp.scale,
      });
      const drawLine = (a,b)=>{
        const A = toCanvas(a), B = toCanvas(b);
        ctx.beginPath(); ctx.moveTo(A.x, A.y); ctx.lineTo(B.x, B.y); ctx.stroke();
      };
      const drawText = (p, text)=>{
        const P = toCanvas(p);
        ctx.font = '12px monospace';
        ctx.fillStyle = 'yellow';
        ctx.fillText(text, P.x + 6, P.y - 6);
      };
      if (measureDraft && measureDraft.start && measureDraft.end){
        drawLine(measureDraft.start, measureDraft.end);
      }
      measurements.forEach(m=>{ drawLine(m.start, m.end); if (m.label) drawText(m.end, m.label); });
      // Annotations
      annotations.forEach(a=>{ drawText(a.pos, a.text); });
      // Crosshair
      if (crosshair){
        ctx.strokeStyle = 'rgba(0,255,255,0.8)';
        ctx.beginPath();
        ctx.moveTo(canvas.width/2, 0); ctx.lineTo(canvas.width/2, canvas.height);
        ctx.moveTo(0, canvas.height/2); ctx.lineTo(canvas.width, canvas.height/2);
        ctx.stroke();
      }
      ctx.restore();
    }

    function drawEllipseOverlay(planeKey){
      ctx.save();
      ctx.strokeStyle = '#00ff88';
      ctx.lineWidth = 2;
      let mapping;
      if (huEllipse && huEllipse.mode==='mpr'){
        mapping = mprRegionVps[planeKey||huEllipse.plane];
      } else {
        mapping = lastVp;
      }
      if (!mapping) { ctx.restore(); return; }
      const { x, y, scale } = mapping;
      const cx = x + huEllipse.cx * scale;
      const cy = y + huEllipse.cy * scale;
      const rx = huEllipse.rx * scale;
      const ry = huEllipse.ry * scale;
      ctx.beginPath();
      ctx.ellipse(cx, cy, Math.abs(rx), Math.abs(ry), 0, 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }

    function canvasToImageCoords(vp, cx, cy){
      const x = (cx - vp.x) / vp.scale;
      const y = (cy - vp.y) / vp.scale;
      return { x, y };
    }

    function imageDistance(a, b){
      const dx = b.x - a.x, dy = b.y - a.y;
      const px = Math.sqrt(dx*dx + dy*dy);
      const spacing = parsePixelSpacing(currentSeries && currentSeries.pixel_spacing);
      if (spacing && spacing.length >= 2 && isFinite(spacing[0]) && isFinite(spacing[1])){
        const mm = Math.sqrt((dx*spacing[0])**2 + (dy*spacing[1])**2);
        const value = (measureUnit === 'cm') ? (mm/10.0) : mm;
        const unit = (measureUnit === 'cm') ? 'cm' : 'mm';
        return { px, mm, value, unit };
      }
      return { px, mm: null, value: px, unit: 'px' };
    }

    function mprImageDistance(planeKey, a, b){
      const dx = b.x - a.x, dy = b.y - a.y;
      const px = Math.sqrt(dx*dx + dy*dy);
      const ps = parsePixelSpacing(currentSeries && currentSeries.pixel_spacing) || [1,1];
      const st = (currentSeries && +currentSeries.slice_thickness) || 1.0;
      let sx = 1.0, sy = 1.0;
      if (planeKey === 'axial') { sx = ps[0]; sy = ps[1]; }
      else if (planeKey === 'sagittal') { sx = ps[0]; sy = st; }
      else if (planeKey === 'coronal') { sx = ps[1]; sy = st; }
      const mm = Math.sqrt((dx*sx)**2 + (dy*sy)**2);
      const value = (measureUnit === 'cm') ? (mm/10.0) : mm;
      const unit = (measureUnit === 'cm') ? 'cm' : 'mm';
      return { px, mm, value, unit };
    }

    async function saveMeasurementToServer(m){
      const imageId = getCurrentImageId();
      if (!imageId) return;
      const dist = imageDistance(m.start, m.end);
      const payload = {
        image_id: imageId,
        type: 'distance',
        points: [m.start, m.end],
        value: (dist.mm ? (measureUnit==='cm' ? (dist.mm/10.0) : dist.mm) : dist.px),
        unit: (dist.mm ? measureUnit : 'px'),
        notes: ''
      };
      try {
        const r = await fetch('/dicom-viewer/measurements/save/', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
        const j = await r.json();
        if (j && j.success){
          if (dist.mm){
            const mm = dist.mm; const cm = mm/10.0;
            m.label = (measureUnit==='cm') ? `${cm.toFixed(2)} cm` : `${mm.toFixed(2)} mm`;
          } else { m.label = `${dist.px.toFixed(1)} px`; }
        }
      } catch(e){}
    }

    async function saveAnnotationToServer(p, text){
      const imageId = getCurrentImageId();
      if (!imageId) return;
      try {
        await fetch('/dicom-viewer/annotations/save/', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ image_id: imageId, position_x: p.x, position_y: p.y, text }) });
      } catch(e){}
    }

    async function loadOverlaysForCurrentImage(){
      const reqId = ++overlayRequestId;
      const imageId = getCurrentImageId();
      if (!imageId) return;
      const tasks = [];
      if (imageIdToMeasurements.has(imageId)) {
        measurements = imageIdToMeasurements.get(imageId);
      } else {
        tasks.push(
          (async ()=>{
            try {
              const r = await fetch(`/dicom-viewer/measurements/${imageId}/`); const j = await r.json();
              measurements = (j.measurements||[]).map(m=>({ start: m.points[0], end: m.points[1], label: m.unit==='mm' ? `${(+m.value).toFixed(2)} mm` : `${(+m.value).toFixed(1)} px` }));
              imageIdToMeasurements.set(imageId, measurements);
            } catch(e){ measurements = []; }
          })()
        );
      }
      if (imageIdToAnnotations.has(imageId)) {
        annotations = imageIdToAnnotations.get(imageId);
      } else {
        tasks.push(
          (async ()=>{
            try {
              const r = await fetch(`/dicom-viewer/annotations/${imageId}/`); const j = await r.json();
              annotations = (j.annotations||[]).map(a=>({ pos: {x:a.position_x, y:a.position_y}, text: a.text }));
              imageIdToAnnotations.set(imageId, annotations);
            } catch(e){ annotations = []; }
          })()
        );
      }
      if (showTagsOverlay){
        tasks.push(
          (async ()=>{
            try {
              const r = await fetch(`/dicom-viewer/api/image/${imageId}/data/`); const j = await r.json();
              currentImageTags = {
                patient_name: j.patient_name || j.image_info?.patient_name,
                study_date: j.study_date || j.image_info?.study_date,
                series_number: j.series?.series_number ?? j.series_number,
                slice_thickness: j.series?.slice_thickness ?? j.slice_thickness,
                pixel_spacing: j.series?.pixel_spacing ?? j.pixel_spacing
              };
            } catch(e){ currentImageTags = null; }
          })()
        );
      } else {
        currentImageTags = null;
      }
      if (tasks.length) { try { await Promise.all(tasks); } catch(e){} }
      // If a newer overlay request superseded this one or image changed, skip applying
      if (reqId !== overlayRequestId || imageId !== getCurrentImageId()) return;
      renderMeasurementsList();
      requestDraw();
    }

    function renderMeasurementsList(){
      measurementsList.innerHTML = '';
      measurements.forEach((m, i)=>{
        const li = document.createElement('li');
        li.textContent = `Measurement ${i+1}: ${m.label||''}`;
        measurementsList.appendChild(li);
      });
    }

    // UI wiring
    seriesSelect.addEventListener('change', e=>{ if(e.target.value) loadSeries(e.target.value); });
    wwSlider.addEventListener('input', e=>{ ww = +e.target.value; wwNum.value = Math.round(ww); document.getElementById('wwVal').textContent = ww; imageCache.clear(); mprImageCache.clear(); mprImgs = { axial:null, sagittal:null, coronal:null }; requestDraw(); });
    wlSlider.addEventListener('input', e=>{ wl = +e.target.value; wlNum.value = Math.round(wl); document.getElementById('wlVal').textContent = wl; imageCache.clear(); mprImageCache.clear(); mprImgs = { axial:null, sagittal:null, coronal:null }; requestDraw(); });
    sliceSlider.addEventListener('input', e=>{ index = +e.target.value; document.getElementById('sliceVal').textContent = index+1; requestDraw(); debouncedLoadOverlaysForCurrentImage(); prefetchAround(index, 3); });
    zoomSlider.addEventListener('input', e=>{ zoom = (+e.target.value)/100; document.getElementById('zoomVal').textContent = `${e.target.value}%`; requestDraw(); });
    document.querySelectorAll('[data-preset]').forEach(btn=>btn.addEventListener('click', ()=>{
      const p = btn.getAttribute('data-preset');
      const map = { lung:{ww:1500,wl:-600}, bone:{ww:2000,wl:300}, soft:{ww:400,wl:40}, brain:{ww:100,wl:50} };
      if (map[p]){ ww = map[p].ww; wl = map[p].wl; wwSlider.value = ww; wlSlider.value = wl; wwNum.value = Math.round(ww); wlNum.value = Math.round(wl); document.getElementById('wwVal').textContent = ww; document.getElementById('wlVal').textContent = wl; imageCache.clear(); mprImageCache.clear(); mprImgs = { axial:null, sagittal:null, coronal:null }; requestDraw(); }
    }));
    document.querySelectorAll('.tool').forEach(t=>t.addEventListener('click', ()=>{
      const tool = t.getAttribute('data-tool');
      document.querySelectorAll('.tool').forEach(x=>x.classList.remove('active')); t.classList.add('active');
      if (tool === 'invert'){ inverted = !inverted; imageCache.clear(); mprImageCache.clear(); mprImgs = { axial:null, sagittal:null, coronal:null }; requestDraw(); return; }
      if (tool === 'reset'){ zoom = 1.0; panOffset = {x:0,y:0}; zoomSlider.value = 100; document.getElementById('zoomVal').textContent = '100%'; requestDraw(); return; }
      if (tool === 'fit'){ panOffset = {x:0,y:0}; zoom = 1.0; zoomSlider.value = 100; document.getElementById('zoomVal').textContent = '100%'; requestDraw(); return; }
      if (tool === 'one'){
        if (lastVp){
          const baseFit = Math.min(canvas.width / lastVp.imgW, canvas.height / lastVp.imgH);
          zoom = 1 / baseFit; zoomSlider.value = Math.min(500, Math.max(25, Math.round(zoom*100))); document.getElementById('zoomVal').textContent = `${Math.round(zoom*100)}%`; panOffset={x:0,y:0}; requestDraw();
        }
        return;
      }
      if (tool === 'cine'){
        cineActive = !cineActive;
        if (cineActive){
          if (cineTimer) clearInterval(cineTimer);
          cineTimer = setInterval(()=>{
            if (!images.length) return; index = (index + 1) % images.length; sliceSlider.value = index; document.getElementById('sliceVal').textContent = index+1; requestDraw(); debouncedLoadOverlaysForCurrentImage();
          }, Math.max(30, Math.round(1000/cineFps)));
        } else { if (cineTimer) { clearInterval(cineTimer); cineTimer = null; } }
        return;
      }
      if (tool === 'spyglass'){ spyglass.active = !spyglass.active; requestDraw(); return; }
      if (tool === 'align-center'){ panOffset = {x:0,y:0}; requestDraw(); return; }
      if (tool === 'reload'){ ww = defaultWw; wl = defaultWl; inverted = false; panOffset={x:0,y:0}; zoom=1.0; wwSlider.value = Math.round(ww); wlSlider.value = Math.round(wl); document.getElementById('wwVal').textContent = Math.round(ww); document.getElementById('wlVal').textContent = Math.round(wl); zoomSlider.value=100; document.getElementById('zoomVal').textContent='100%'; imageCache.clear(); mprImageCache.clear(); mprImgs = { axial:null, sagittal:null, coronal:null }; requestDraw(); return; }
      if (tool === 'ai'){ console.info('AI analysis: stub'); return; }
      if (tool === 'crosshair'){ toggleCrosshair(); return; }
      if (tool === 'hu'){ showHuProbe = true; huEllipse = null; requestDraw(); return; }
             if (tool === 'measure') { showHuProbe = false; if (mprMode) document.getElementById('mprMeasurePanel').style.display=''; }
      // remove old inline MPR toggle from tool button; handled by 3D dropdown now
             if (tool === 'mpr'){
         return; // no-op
       }
       if (mprMode){
         // In MPR, toggle measure panel visibility based on tool
         document.getElementById('mprMeasurePanel').style.display = (tool === 'measure') ? '' : document.getElementById('mprMeasurePanel').style.display;
         return;
       }
       activeTool = tool;
     }));

    // Mouse interactions on viewport
    const viewport = document.getElementById('viewport');
    viewport.addEventListener('mousedown', (e)=>{
      isDragging = true; dragStart = { x: e.offsetX, y: e.offsetY };
      // Start measurement draft
      if (activeTool === 'measure'){
        if (mprMode){
          const halfW = Math.floor(canvas.width/2), halfH = Math.floor(canvas.height/2);
          const mx = e.offsetX, my = e.offsetY;
          let plane = null; if (mx < halfW && my < halfH) plane='sagittal'; else if (mx>=halfW && my<halfH) plane='coronal'; else if (mx<halfW && my>=halfH) plane='axial';
          if (mprFullPlane) plane = mprFullPlane;
          if (mprMeasurePlaneMode !== 'auto') plane = mprMeasurePlaneMode;
          if (plane && mprRegionVps[plane]){
            const vpR = mprRegionVps[plane];
            // Ignore clicks outside the image bounds within region
            if (mx < vpR.x || mx > vpR.x + vpR.imgW * vpR.scale || my < vpR.y || my > vpR.y + vpR.imgH * vpR.scale) {
              return;
            }
            const imgPt = canvasToImageCoords(vpR, e.offsetX, e.offsetY);
            measureDraft = { plane, start: imgPt, end: imgPt };
          }
        } else {
          const vp2 = lastVp || { x:0, y:0, scale:1 };
          measureDraft = { start: canvasToImageCoords(vp2, e.offsetX, e.offsetY), end: canvasToImageCoords(vp2, e.offsetX, e.offsetY) };
        }
      }
      if (mprMode && activeTool === 'crosshair'){
        const halfW = Math.floor(canvas.width/2), halfH = Math.floor(canvas.height/2);
        const mx = e.offsetX, my = e.offsetY;
        let plane = null; if (mx < halfW && my < halfH) plane='sagittal'; else if (mx>=halfW && my<halfH) plane='coronal'; else if (mx<halfW && my>=halfH) plane='axial';
        if (plane && mprRegionVps[plane]){
          const vpR = mprRegionVps[plane];
          // Ignore clicks outside the image bounds within region
          if (mx < vpR.x || mx > vpR.x + vpR.imgW * vpR.scale || my < vpR.y || my > vpR.y + vpR.imgH * vpR.scale) {
            return;
          }
          const imgPt = canvasToImageCoords(vpR, mx, my);
          // Update crosshair global coordinates and synchronize all planes
          const oldCross = {...mprCross};
          let needsUpdate = false;
          
          if (plane === 'axial'){
            const newX = Math.round(imgPt.x);
            const newY = Math.round(imgPt.y);
            if (mprCross.x !== newX || mprCross.y !== newY) {
              mprCross.x = newX;
              mprCross.y = newY;
              mprScroll.sagittal = Math.max(0, Math.min((mprScroll.counts.sagittal||1)-1, newX));
              mprScroll.coronal = Math.max(0, Math.min((mprScroll.counts.coronal||1)-1, newY));
              needsUpdate = true;
            }
          } else if (plane === 'sagittal'){
            // sagittal image: x->height(y), y->depth(z)
            const newY = Math.round(imgPt.x);
            const newZ = Math.round(imgPt.y);
            if (mprCross.y !== newY || mprCross.z !== newZ) {
              mprCross.y = newY;
              mprCross.z = newZ;
              mprScroll.axial = Math.max(0, Math.min((mprScroll.counts.axial||1)-1, newZ));
              mprScroll.coronal = Math.max(0, Math.min((mprScroll.counts.coronal||1)-1, newY));
              needsUpdate = true;
            }
          } else if (plane === 'coronal'){
            // coronal image: x->width(x), y->depth(z)
            const newX = Math.round(imgPt.x);
            const newZ = Math.round(imgPt.y);
            if (mprCross.x !== newX || mprCross.z !== newZ) {
              mprCross.x = newX;
              mprCross.z = newZ;
              mprScroll.axial = Math.max(0, Math.min((mprScroll.counts.axial||1)-1, newZ));
              mprScroll.sagittal = Math.max(0, Math.min((mprScroll.counts.sagittal||1)-1, newX));
              needsUpdate = true;
            }
          }
          
          if (needsUpdate) {
            // Force refresh of all plane images when crosshair moves
            mprImgs = { axial: null, sagittal: null, coronal: null };
            
            // Prefetch the new slice positions for smooth interaction
            prefetchMprSlices('axial', mprScroll.axial, 2);
            prefetchMprSlices('sagittal', mprScroll.sagittal, 2);
            prefetchMprSlices('coronal', mprScroll.coronal, 2);
            
            draw();
          }
        }
      }
      if (showHuProbe){
        if (mprMode){
          // determine plane by quadrant
          const halfW = Math.floor(canvas.width/2), halfH = Math.floor(canvas.height/2);
          const mx = e.offsetX, my = e.offsetY;
          let plane = null; if (mx < halfW && my < halfH) plane='sagittal'; else if (mx>=halfW && my<halfH) plane='coronal'; else if (mx<halfW && my>=halfH) plane='axial';
          if (plane && mprRegionVps[plane]){
            const vpR = mprRegionVps[plane];
            const imgPt = canvasToImageCoords(vpR, e.offsetX, e.offsetY);
            huEllipse = { mode:'mpr', plane, slice: (mprScroll[plane]||0), cx: imgPt.x, cy: imgPt.y, rx: 1, ry: 1 };
          }
        } else if (lastVp){
          const imgPt = canvasToImageCoords(lastVp, e.offsetX, e.offsetY);
          huEllipse = { mode:'series', cx: imgPt.x, cy: imgPt.y, rx: 1, ry: 1 };
        }
        draw();
      }
      if (spyglass.active){ spyglass.isPress = true; spyglass.cx = e.offsetX; spyglass.cy = e.offsetY; draw(); }
    });
    viewport.addEventListener('mousemove', async (e)=>{
      if (!isDragging) { if (spyglass.active && spyglass.isPress){ spyglass.cx = e.offsetX; spyglass.cy = e.offsetY; requestDraw(); } return; }
      const vp = lastVp || { x:0, y:0, scale:1 };
      if (activeTool === 'window'){
        const dx = e.offsetX - dragStart.x; const dy = e.offsetY - dragStart.y; dragStart = { x: e.offsetX, y: e.offsetY };
        ww = Math.max(1, ww + dx*4); wl = wl + dy*2; wwSlider.value = Math.round(ww); wlSlider.value = Math.round(wl); document.getElementById('wwVal').textContent = Math.round(ww); document.getElementById('wlVal').textContent = Math.round(wl); requestDraw();
      } else if (activeTool === 'pan'){
        panOffset.x += (e.offsetX - dragStart.x); panOffset.y += (e.offsetY - dragStart.y); dragStart = { x: e.offsetX, y: e.offsetY }; requestDraw();
      } else if (activeTool === 'measure' && measureDraft){
        if (mprMode && measureDraft.plane && mprRegionVps[measureDraft.plane]){
          const vpR = mprRegionVps[measureDraft.plane];
          measureDraft.end = canvasToImageCoords(vpR, e.offsetX, e.offsetY);
        } else {
          measureDraft.end = canvasToImageCoords(vp, e.offsetX, e.offsetY);
        }
        requestDraw();
      } else if (activeTool === 'annotate'){
        // no-op while dragging
      } else if (activeTool === 'zoom'){
        const dy = e.offsetY - dragStart.y; dragStart = { x: e.offsetX, y: e.offsetY }; const factor = dy<0 ? 1.05 : 0.95; zoom = Math.min(5.0, Math.max(0.25, zoom*factor)); zoomSlider.value = Math.round(zoom*100); document.getElementById('zoomVal').textContent = `${Math.round(zoom*100)}%`; requestDraw();
      } else if (mprMode && activeTool === 'crosshair'){
        const halfW = Math.floor(canvas.width/2), halfH = Math.floor(canvas.height/2);
        const mx = e.offsetX, my = e.offsetY;
        let plane = null; if (mx < halfW && my < halfH) plane='sagittal'; else if (mx>=halfW && my<halfH) plane='coronal'; else if (mx<halfW && my>=halfH) plane='axial';
        if (mprFullPlane) plane = mprFullPlane;
        if (plane && mprRegionVps[plane]){
          const vpR = mprRegionVps[plane];
          // Ignore clicks outside the image bounds within region
          if (mx < vpR.x || mx > vpR.x + vpR.imgW * vpR.scale || my < vpR.y || my > vpR.y + vpR.imgH * vpR.scale) {
            return;
          }
          const imgPt = canvasToImageCoords(vpR, mx, my);
          
          // Update crosshair global coordinates and synchronize all planes
          const oldCross = {...mprCross};
          
          if (plane === 'axial'){
            mprCross.x = Math.round(imgPt.x);
            mprCross.y = Math.round(imgPt.y);
            // Update orthogonal planes to intersect this point
            mprScroll.sagittal = Math.max(0, Math.min((mprScroll.counts.sagittal||1)-1, mprCross.x));
            mprScroll.coronal = Math.max(0, Math.min((mprScroll.counts.coronal||1)-1, mprCross.y));
          } else if (plane === 'sagittal'){
            // sagittal image: x->height(y), y->depth(z)
            mprCross.y = Math.round(imgPt.x);
            mprCross.z = Math.round(imgPt.y);
            mprScroll.axial = Math.max(0, Math.min((mprScroll.counts.axial||1)-1, mprCross.z));
            mprScroll.coronal = Math.max(0, Math.min((mprScroll.counts.coronal||1)-1, mprCross.y));
          } else if (plane === 'coronal'){
            // coronal image: x->width(x), y->depth(z)
            mprCross.x = Math.round(imgPt.x);
            mprCross.z = Math.round(imgPt.y);
            mprScroll.axial = Math.max(0, Math.min((mprScroll.counts.axial||1)-1, mprCross.z));
            mprScroll.sagittal = Math.max(0, Math.min((mprScroll.counts.sagittal||1)-1, mprCross.x));
          }
          
          // Force refresh of all plane images when crosshair moves significantly
          if (Math.abs(oldCross.x - mprCross.x) > 1 || Math.abs(oldCross.y - mprCross.y) > 1 || Math.abs(oldCross.z - mprCross.z) > 1) {
            // Clear images to force reload with new slice positions
            mprImgs = { axial: null, sagittal: null, coronal: null };
            
            // Prefetch the new slice positions for smooth interaction
            prefetchMprSlices('axial', mprScroll.axial, 2);
            prefetchMprSlices('sagittal', mprScroll.sagittal, 2);
            prefetchMprSlices('coronal', mprScroll.coronal, 2);
          }
          
          requestDraw();
        }
      } else if (showHuProbe && huEllipse){
        if (huEllipse.mode==='mpr' && mprRegionVps[huEllipse.plane]){
          const vpR = mprRegionVps[huEllipse.plane];
          const cur = canvasToImageCoords(vpR, e.offsetX, e.offsetY);
          huEllipse.rx = Math.abs(cur.x - huEllipse.cx);
          huEllipse.ry = Math.abs(cur.y - huEllipse.cy);
          requestDraw();
        } else if (lastVp && huEllipse.mode==='series'){
          const cur = canvasToImageCoords(lastVp, e.offsetX, e.offsetY);
          huEllipse.rx = Math.abs(cur.x - huEllipse.cx);
          huEllipse.ry = Math.abs(cur.y - huEllipse.cy);
          requestDraw();
        }
      }
    });
    // HU probe on mousemove in MPR when enabled
    viewport.addEventListener('mousemove', async (e)=>{
      if (!mprMode || !showHuProbe || (huEllipse && (huEllipse.rx>1 || huEllipse.ry>1))) return;
      // Determine which plane region the mouse is in
      const halfW = Math.floor(canvas.width/2), halfH = Math.floor(canvas.height/2);
      const mx = e.offsetX, my = e.offsetY;
      let plane = null; if (mx < halfW && my < halfH) plane='sagittal'; else if (mx>=halfW && my<halfH) plane='coronal'; else if (mx<halfW && my>=halfH) plane='axial';
      if (mprFullPlane) plane = mprFullPlane;
      if (!plane || !mprRegionVps[plane]) return;
      try {
        const vpR = mprRegionVps[plane];
        const imgPt = canvasToImageCoords(vpR, mx, my);
        const px = Math.max(0, Math.min(vpR.imgW-1, imgPt.x));
        const py = Math.max(0, Math.min(vpR.imgH-1, imgPt.y));
        // Query HU from backend
        const q = new URLSearchParams();
        q.set('mode','mpr'); q.set('series_id', currentSeries.id); q.set('plane', plane);
        q.set('slice', mprScroll[plane]||0); q.set('x', Math.floor(px)); q.set('y', Math.floor(py));
        try {
          const resp = await fetch(`/dicom-viewer/api/hu/?${q.toString()}`);
          const j = await resp.json();
          if (j && typeof j.hu === 'number'){
            document.getElementById('overlay').innerHTML = `HU (${plane}): ${j.hu} @ x:${Math.floor(px)} y:${Math.floor(py)} slice:${(mprScroll[plane]||0)+1}/${mprScroll.counts[plane]||0}`;
          }
        } catch(e){}
      } catch(e){}
    });
    viewport.addEventListener('mouseup', async (e)=>{
      if (!isDragging) return; isDragging = false;
      const vp = lastVp || { x:0, y:0, scale:1 };
      if (activeTool === 'measure' && measureDraft){
        if (mprMode && measureDraft.plane && mprRegionVps[measureDraft.plane]){
          const vpR = mprRegionVps[measureDraft.plane];
          measureDraft.end = canvasToImageCoords(vpR, e.offsetX, e.offsetY);
          const plane = measureDraft.plane;
          const m = { plane, start: measureDraft.start, end: measureDraft.end };
          const dist = mprImageDistance(plane, m.start, m.end);
          if (dist.mm){
            const mm = dist.mm; const cm = mm/10.0;
            m.label = (measureUnit==='cm') ? `${cm.toFixed(2)} cm` : `${mm.toFixed(2)} mm`;
          } else { m.label = `${dist.px.toFixed(1)} px`; }
          mprMeasurements[plane].push(m);
          measureDraft = null; await draw();
        } else {
          measureDraft.end = canvasToImageCoords(vp, e.offsetX, e.offsetY);
          const m = { start: measureDraft.start, end: measureDraft.end };
          measureDraft = null; measurements.push(m); imageIdToMeasurements.set(getCurrentImageId(), measurements);
          await saveMeasurementToServer(m); renderMeasurementsList(); await draw();
        }
      } else if (activeTool === 'annotate'){
        const pos = canvasToImageCoords(vp, e.offsetX, e.offsetY);
                 // Create inline annotation with default text
         const text = 'Annotation';
         annotations.push({ pos, text }); 
         imageIdToAnnotations.set(getCurrentImageId(), annotations); 
         await saveAnnotationToServer(pos, text); 
         await draw();
         showToast('Annotation added', 'success', 2000);
      } else if (showHuProbe && huEllipse){
        // Submit ROI to backend
        try {
          const qp = new URLSearchParams();
          qp.set('shape','ellipse');
          if (huEllipse.mode==='series'){
            qp.set('mode','series');
            qp.set('image_id', String(getCurrentImageId()));
          } else {
            qp.set('mode','mpr');
            qp.set('series_id', String(currentSeries.id));
            qp.set('plane', huEllipse.plane);
            qp.set('slice', String(huEllipse.slice||0));
          }
          qp.set('cx', Math.round(huEllipse.cx));
          qp.set('cy', Math.round(huEllipse.cy));
          qp.set('rx', Math.max(1, Math.round(huEllipse.rx)));
          qp.set('ry', Math.max(1, Math.round(huEllipse.ry)));
          const r = await fetch(`/dicom-viewer/api/hu/?${qp.toString()}`);
          const j = await r.json();
          if (j && j.stats){
            const s = j.stats; // mean, std, min, max, n
            document.getElementById('overlay').innerHTML = `HU ROI (ellipse): mean ${s.mean.toFixed(1)}, sd ${s.std.toFixed(1)}, min ${s.min.toFixed(0)}, max ${s.max.toFixed(0)} (n=${s.n})`;
          }
        } catch(e){}
        await draw();
      }
      if (spyglass.active){ spyglass.isPress = false; }
    });
    // Double-click enlarge/restore MPR plane
    viewport.addEventListener('dblclick', async (e)=>{
      if (!mprMode) return;
      if (mprFullPlane) { mprFullPlane = null; await draw(); return; }
      const halfW = Math.floor(canvas.width/2), halfH = Math.floor(canvas.height/2);
      const mx = e.offsetX, my = e.offsetY;
      let plane = null; if (mx < halfW && my < halfH) plane='sagittal'; else if (mx>=halfW && my<halfH) plane='coronal'; else if (mx<halfW && my>=halfH) plane='axial';
      if (plane) { mprFullPlane = plane; await draw(); }
    });

    // Mouse wheel slice/zoom
    document.getElementById('viewport').addEventListener('wheel', async (e)=>{
      e.preventDefault();
      if (spyglass.active && spyglass.isPress){
        const d = e.deltaY>0 ? -10 : 10; spyglass.radius = Math.max(20, Math.min(300, spyglass.radius + d)); requestDraw(); return;
      }
      if (reconMode && reconImgs.length){
        const d = e.deltaY>0 ? 1 : -1;
        reconIndex = Math.max(0, Math.min(reconImgs.length-1, reconIndex + d));
        requestDraw();
        return;
      }
      if (mprMode){
        // Determine which quadrant and scroll that plane
        const halfW = Math.floor(canvas.width/2), halfH = Math.floor(canvas.height/2);
        const mx = e.offsetX, my = e.offsetY; const d = e.deltaY>0 ? 1 : -1;
        let plane = null;
        if (mx < halfW && my < halfH) plane = 'sagittal';
        else if (mx >= halfW && my < halfH) plane = 'coronal';
        else if (mx < halfW && my >= halfH) plane = 'axial';
        else plane = null; // bottom-right empty
        if (mprFullPlane) plane = mprFullPlane;
        if (!plane) return;
        const count = (mprScroll.counts[plane]||1);
        const cur = (mprScroll[plane]||0);
        const ni = Math.max(0, Math.min(count-1, cur + d));
                 if (ni !== cur){
           mprScroll[plane] = ni;
           
           // Keep crosshair in sync with the scrolled plane axis and update other planes
           if (plane === 'axial') {
             mprCross.z = ni;
           } else if (plane === 'sagittal') {
             mprCross.x = ni;
             // Update coronal slice to intersect at this sagittal position
             mprScroll.coronal = Math.max(0, Math.min((mprScroll.counts.coronal||1)-1, mprCross.y));
           } else if (plane === 'coronal') {
             mprCross.y = ni;
             // Update sagittal slice to intersect at this coronal position  
             mprScroll.sagittal = Math.max(0, Math.min((mprScroll.counts.sagittal||1)-1, mprCross.x));
           }
           
           // Clear images to force refresh with new slice positions
           mprImgs = { axial: null, sagittal: null, coronal: null };
           
           prefetchMprSlices(plane, ni);
           await draw();
         }
        return;
      }
      if (e.ctrlKey){ const delta = e.deltaY>0?0.9:1.1; zoom = Math.max(0.1, Math.min(5.0, zoom*delta)); zoomSlider.value = Math.round(zoom*100); document.getElementById('zoomVal').textContent = `${Math.round(zoom*100)}%`; requestDraw(); }
      else { const d = e.deltaY>0?1:-1; const ni = Math.max(0, Math.min(images.length-1, index+d)); if (ni !== index){ index = ni; sliceSlider.value = index; document.getElementById('sliceVal').textContent = index+1; requestDraw(); debouncedLoadOverlaysForCurrentImage(); prefetchAround(index, 3); } }
    }, { passive:false });

    // Local DICOM upload with debounce protection
    let uploadInProgress = false;
    
    btnLoadLocal.addEventListener('click', ()=> {
      if (uploadInProgress) {
        console.warn('Upload already in progress');
        return;
      }
      inputLocal.click();
    });
    
    inputLocal.addEventListener('change', async (e)=>{
      try {
        if (uploadInProgress) {
          console.warn('Upload already in progress');
          return;
        }
        
        const files = e.target.files ? Array.from(e.target.files) : [];
        if (!files.length) return;
        
        // Set upload state immediately
        uploadInProgress = true;
        btnLoadLocal.disabled = true;
        btnLoadLocal.style.pointerEvents = 'none';
        reconStatus.textContent = 'Uploading DICOM files...';
        
        const CHUNK_SIZE = 80;
        const MAX_PARALLEL = 2;
        const chunks = [];
        for (let i=0; i<files.length; i+=CHUNK_SIZE){ chunks.push(files.slice(i, i+CHUNK_SIZE)); }
        let current = 0; let lastStudyId = null; let errors = 0;
        async function uploadChunk(chunk){
          const form = new FormData();
          chunk.forEach(f=> form.append('dicom_files', f));
          const resp = await fetch('/dicom-viewer/upload/', { method:'POST', body: form });
          const data = await resp.json();
          if (!data.success){ errors++; return; }
          current += chunk.length;
          if (!lastStudyId && data.study_id) lastStudyId = data.study_id;
          reconStatus.textContent = `Uploading... ${current}/${files.length}`;
        }
        let idx = 0;
        const workers = Array.from({length: Math.min(MAX_PARALLEL, chunks.length)}).map(async ()=>{
          while (true){ const i = idx++; if (i >= chunks.length) break; await uploadChunk(chunks[i]); }
        });
        await Promise.all(workers);
        if (errors > 0 && current === 0) throw new Error('Upload failed');
        reconStatus.textContent = 'Upload complete. Loading study...';
        if (lastStudyId) { await loadStudy(lastStudyId); }
        reconStatus.textContent = '';
      } catch (err){
        reconStatus.textContent = `Error: ${err.message}`;
        await fallbackToDesktop();
      } finally {
        // Reset upload state
        uploadInProgress = false;
        btnLoadLocal.disabled = false;
        btnLoadLocal.style.pointerEvents = '';
        e.target.value = '';
      }
    });

    // Recon controls
    reconType.addEventListener('change', ()=>{
      const v = reconType.value; boneCtrl.style.display = v==='bone' ? '' : 'none';
    });
    boneSlider.addEventListener('input', e=> boneVal.textContent = e.target.value);

    // Debounce mechanism for reconstruction buttons to prevent multiple clicks
    let reconstructionInProgress = false;
    let reconstructionTimeout = null;

    // Extracted function so both dropdown and button can trigger
    async function generateReconstruction(kind){
      try {
        // Prevent multiple simultaneous reconstruction requests
        if (reconstructionInProgress) {
          console.warn('Reconstruction already in progress');
          return;
        }
        
        if (!currentSeries || !currentSeries.id){ 
          console.warn('Select a series first'); 
          reconStatus.textContent = 'Please select a series first';
          return; 
        }
        
        // Set loading state immediately to prevent UI freezing
        reconstructionInProgress = true;
        reconStatus.textContent = 'Generating...';
        
        // Disable reconstruction buttons during processing
        const reconButtons = document.querySelectorAll('[data-recon], #btnGenerateRecon');
        reconButtons.forEach(btn => btn.style.pointerEvents = 'none');
        
        reconMode = null; reconImgs = []; reconIndex = 0; panOffset = {x:0,y:0}; zoom = 1.0;
        const params = new URLSearchParams();
        params.set('window_width', ww);
        params.set('window_level', wl);
        params.set('inverted', inverted);
        let url = '';
        const type = kind || reconType.value;
        if (type === 'mpr') url = `/dicom-viewer/api/series/${currentSeries.id}/mpr/?${params.toString()}`;
        else if (type === 'mip') url = `/dicom-viewer/api/series/${currentSeries.id}/mip/?quality=high&${params.toString()}`;
        else { url = `/dicom-viewer/api/series/${currentSeries.id}/bone/?threshold=${boneSlider.value}&mesh=true&quality=high`; }
        
        console.log(`Requesting reconstruction: ${type}, URL: ${url}`);
        const r = await fetch(url);
        console.log(`Response status: ${r.status}`);
        
        if (!r.ok) {
          const errorText = await r.text();
          throw new Error(`HTTP ${r.status}: ${errorText}`);
        }
        
        const j = await r.json();
        console.log(`Response data:`, j);
        
        if (j.error) throw new Error(j.error);
        
        if (j.mpr_views){ 
          console.log('Processing MPR views');
          reconMode = 'mpr'; 
          reconImgs = [j.mpr_views.axial, j.mpr_views.sagittal, j.mpr_views.coronal]; 
          console.log('MPR images:', reconImgs.map(img => img ? 'loaded' : 'null'));
          mprMode = true; 
          document.getElementById('mprMeasurePanel').style.display=''; 
          if (j.counts){ 
            mprScroll.counts = j.counts; 
            mprScroll.axial = Math.floor((j.counts.axial||0)/2); 
            mprScroll.sagittal = Math.floor((j.counts.sagittal||0)/2); 
            mprScroll.coronal = Math.floor((j.counts.coronal||0)/2); 
            mprCross = { x: mprScroll.sagittal, y: mprScroll.coronal, z: mprScroll.axial }; 
            prefetchMprSlices('axial', mprScroll.axial); 
            prefetchMprSlices('sagittal', mprScroll.sagittal); 
            prefetchMprSlices('coronal', mprScroll.coronal); 
          } 
        }
        if (j.mip_views){ 
          console.log('Processing MIP views');
          reconMode = 'mip'; 
          reconImgs = [j.mip_views.axial, j.mip_views.sagittal, j.mip_views.coronal]; 
          console.log('MIP images:', reconImgs.map(img => img ? 'loaded' : 'null'));
          document.getElementById('mprMeasurePanel').style.display='none'; 
          mprMode = true; 
          mprFullPlane = null; 
          mprScroll.counts = j.counts || mprScroll.counts; 
        }
        if (j.bone_views){ 
          console.log('Processing bone views');
          reconMode = 'bone'; 
          reconImgs = [j.bone_views.axial || j.bone_views.bone_axial_preview, j.bone_views.sagittal || j.bone_views.bone_sagittal_preview, j.bone_views.coronal || j.bone_views.bone_coronal_preview]; 
          console.log('Bone images:', reconImgs.map(img => img ? 'loaded' : 'null'));
          document.getElementById('mprMeasurePanel').style.display='none'; 
          mprMode = true; 
          mprFullPlane = null; 
          if (j.mesh) showBone3D(j.mesh); 
        }
        reconImgs = reconImgs.filter(Boolean);
        reconIndex = 0;
        console.log(`Final reconstruction mode: ${reconMode}, images: ${reconImgs.length}`);
        await draw();
        reconStatus.textContent = 'Done'; setTimeout(()=> reconStatus.textContent = '', 1500);
      } catch (err){
        console.error('Reconstruction error:', err);
        reconStatus.textContent = `Error: ${err.message}`;
        await fallbackToDesktop();
      } finally {
        // Re-enable reconstruction buttons and reset state
        reconstructionInProgress = false;
        const reconButtons = document.querySelectorAll('[data-recon], #btnGenerateRecon');
        reconButtons.forEach(btn => btn.style.pointerEvents = '');
      }
    }
 
           btnGenerateRecon.addEventListener('click', ()=>{ generateReconstruction(); });

      // Worklist navigation that prefers returning to the original/mother worklist window
      function returnToWorklist(e){
        try {
          const targetUrl = '{% url 'worklist:dashboard' %}';
          if (e && typeof e.preventDefault === 'function') e.preventDefault();
          if (window.opener && !window.opener.closed) {
            try { window.opener.location.href = targetUrl; } catch(err) {}
            window.close();
            return false;
          }
          if (window.top && window.top !== window){
            try { window.top.location.href = targetUrl; return false; } catch(err) {}
          }
          window.location.href = targetUrl;
          return false;
        } catch(_) { window.location.href = '{% url 'worklist:dashboard' %}'; return false; }
      }
      // expose for inline onclick
      window.returnToWorklist = returnToWorklist;

    // Preload MPR mid-slices after series load to avoid UI stall on first click
    function warmupMpr(){
      if (!currentSeries || !currentSeries.id) return;
      const params = new URLSearchParams(); params.set('window_width', ww); params.set('window_level', wl); params.set('inverted', inverted);
      fetch(`/dicom-viewer/api/series/${currentSeries.id}/mpr/?${params.toString()}`)
        .then(r=>r.json())
        .then(j=>{ if (j && j.counts) { mprScroll.counts = j.counts; mprScroll.axial = Math.floor((j.counts.axial||0)/2); mprScroll.sagittal = Math.floor((j.counts.sagittal||0)/2); mprScroll.coronal = Math.floor((j.counts.coronal||0)/2); prefetchMprSlices('axial', mprScroll.axial); prefetchMprSlices('sagittal', mprScroll.sagittal); prefetchMprSlices('coronal', mprScroll.coronal);} })
        .catch(()=>{});
    }
 
     // 3D dropdown interactions
     btn3D.addEventListener('click', (e)=>{
       e.preventDefault(); e.stopPropagation();
       menu3D.style.display = (menu3D.style.display === 'flex') ? 'none' : 'flex';
       if (menu3D.style.display === '' || menu3D.style.display === 'none') menu3D.style.display = 'flex';
     });
           menu3D.addEventListener('click', (e)=>{
        const btn = e.target.closest('button[data-recon]');
        if (!btn) return;
        e.preventDefault(); e.stopPropagation();
        const kind = btn.getAttribute('data-recon');
        menu3D.style.display = 'none';
        
        // Handle new button types
        if (kind === 'ai-3d-print') {
          handleAI3DPrint();
        } else if (kind === 'advanced-recon') {
          handleAdvancedReconstruction();
        } else {
          generateReconstruction(kind);
        }
      });
     // Close dropdown when clicking outside
     document.addEventListener('click', (e)=>{
       if (!menu3D.contains(e.target) && e.target !== btn3D) menu3D.style.display = 'none';
     });
 
     // Clear measurements
     btnClearMeasurements.addEventListener('click', ()=>{
       if (mprMode){ mprMeasurements.axial = []; mprMeasurements.sagittal = []; mprMeasurements.coronal = []; draw(); }
       else { measurements = []; imageIdToMeasurements.set(getCurrentImageId(), measurements); renderMeasurementsList(); draw(); }
     });

     // Sorting
     sortSelect.addEventListener('change', async ()=>{
       if (!images || !images.length) return;
       const mode = sortSelect.value;
       if (mode === 'inst_desc') images.sort((a,b)=> (b.instance_number||0) - (a.instance_number||0));
       else images.sort((a,b)=> (a.instance_number||0) - (b.instance_number||0));
       index = 0; sliceSlider.max = Math.max(0, images.length - 1); sliceSlider.value = 0; document.getElementById('sliceVal').textContent = '1';
       await loadOverlaysForCurrentImage();
     });

     // Toggle tags overlay
     btnToggleTags.addEventListener('click', async ()=>{
       showTagsOverlay = !showTagsOverlay; await loadOverlaysForCurrentImage();
     });

     // Show DICOM modal
     btnShowDicom.addEventListener('click', async ()=>{
       try {
         const imageId = getCurrentImageId(); if (!imageId) return;
                   const r = await fetch(`/dicom-viewer/api/image/${imageId}/data/`); const j = await r.json();
         dicomTagsPre.textContent = JSON.stringify(j, null, 2);
         dicomModal.style.display = 'flex';
       } catch(e){}
     });
     closeDicomModal.addEventListener('click', ()=>{ dicomModal.style.display = 'none'; });
     dicomModal.addEventListener('click', (e)=>{ if (e.target === dicomModal) dicomModal.style.display = 'none'; });

     // Capture canvas
     btnCapture.addEventListener('click', ()=>{
       try {
         const url = canvas.toDataURL('image/jpeg', 0.92);
         const a = document.createElement('a'); a.href = url; a.download = `dicom_capture_${Date.now()}.jpg`; document.body.appendChild(a); a.click(); document.body.removeChild(a);
       } catch(e){}
     });

     // Print functionality
     const btnPrint = document.getElementById('btnPrint');
     const printModal = document.getElementById('printModal');
     const closePrintModal = document.getElementById('closePrintModal');
     const cancelPrint = document.getElementById('cancelPrint');
     const printForm = document.getElementById('printForm');
     const printerSelect = document.getElementById('printerSelect');

     // Load available printers and layouts when modal opens
     btnPrint.addEventListener('click', async ()=>{
       try {
         // Load available printers
         const printersResponse = await fetch('/dicom-viewer/print/printers/');
         const printersData = await printersResponse.json();
         
         if (printersData.success) {
           printerSelect.innerHTML = '';
           if (printersData.printers.length === 0) {
             printerSelect.innerHTML = '<option value="">No printers available</option>';
           } else {
             printersData.printers.forEach(printer => {
               const option = document.createElement('option');
               option.value = printer.name;
               option.textContent = `${printer.name} - ${printer.description}`;
               printerSelect.appendChild(option);
             });
           }
         }
         
         // Load modality-specific layouts
         const currentModality = getCurrentModality();
         if (currentModality) {
           const layoutsResponse = await fetch(`/dicom-viewer/print/layouts/?modality=${currentModality}`);
           const layoutsData = await layoutsResponse.json();
           
           if (layoutsData.success) {
             const layoutSelect = document.getElementById('layoutType');
             layoutSelect.innerHTML = '';
             
             layoutsData.layouts.forEach(layout => {
               const option = document.createElement('option');
               option.value = layout.value;
               option.textContent = layout.name;
               option.setAttribute('data-description', layout.description);
               layoutSelect.appendChild(option);
             });
             
             // Update description
             updateLayoutDescription();
           }
         }
         
         printModal.style.display = 'flex';
       } catch(e) {
         console.error('Error loading print options:', e.message);
       }
     });

     // Handle print medium changes
     const printMedium = document.getElementById('printMedium');
     const paperTypeGroup = document.getElementById('paperTypeGroup');
     const paperSize = document.getElementById('paperSize');
     const paperType = document.getElementById('paperType');
     
     printMedium.addEventListener('change', function() {
       if (this.value === 'film') {
         // Show film-specific options
         paperType.innerHTML = `
           <option value="film">Medical Film</option>
           <option value="film_blue">Blue-Base Film</option>
           <option value="film_clear">Clear-Base Film</option>
         `;
         
         // Show film sizes
         paperSize.innerHTML = `
           <option value="FILM_14X17">Film 14" × 17" (Standard)</option>
           <option value="FILM_11X14">Film 11" × 14"</option>
           <option value="FILM_10X12">Film 10" × 12"</option>
           <option value="FILM_8X10">Film 8" × 10"</option>
         `;
         
         paperTypeGroup.querySelector('label').textContent = 'Film Type:';
       } else {
         // Show paper-specific options
         paperType.innerHTML = `
           <option value="glossy">🌟 Glossy Photo Paper</option>
           <option value="matte">Matte Paper</option>
           <option value="plain">Plain Paper</option>
         `;
         
         // Show paper sizes
         paperSize.innerHTML = `
           <option value="A4">A4 (210 × 297 mm)</option>
           <option value="Letter">Letter (8.5 × 11 in)</option>
         `;
         
         paperTypeGroup.querySelector('label').textContent = 'Paper Type:';
       }
     });

     // Handle layout type changes
     const layoutType = document.getElementById('layoutType');
     layoutType.addEventListener('change', updateLayoutDescription);
     
     function updateLayoutDescription() {
       const selectedOption = layoutType.options[layoutType.selectedIndex];
       const description = selectedOption.getAttribute('data-description') || selectedOption.textContent;
       document.getElementById('layoutDescription').textContent = description;
     }
     
     function getCurrentModality() {
       // Extract modality from patient info
       const patientInfo = document.getElementById('patientInfo').textContent;
       const modalityMatch = patientInfo.match(/Modality: ([^|]+)/);
       return modalityMatch ? modalityMatch[1].trim() : '';
     }

     // Close print modal
     closePrintModal.addEventListener('click', ()=>{ printModal.style.display = 'none'; });
     cancelPrint.addEventListener('click', ()=>{ printModal.style.display = 'none'; });
     printModal.addEventListener('click', (e)=>{ if (e.target === printModal) printModal.style.display = 'none'; });

     // Handle print form submission
     printForm.addEventListener('submit', async (e)=>{
       e.preventDefault();
       
       try {
         // Get current canvas image data
         const imageData = canvas.toDataURL('image/png', 1.0);
         
         // Get patient information from current study
         const patientInfo = document.getElementById('patientInfo').textContent;
         const patientMatch = patientInfo.match(/Patient: ([^|]+)/);
         const dateMatch = patientInfo.match(/Study Date: ([^|]+)/);
         const modalityMatch = patientInfo.match(/Modality: ([^|]+)/);
         
                   const formData = new FormData();
          formData.append('image_data', imageData);
          formData.append('printer_name', document.getElementById('printerSelect').value);
          formData.append('paper_size', document.getElementById('paperSize').value);
          formData.append('paper_type', document.getElementById('paperType').value);
          formData.append('print_quality', document.getElementById('printQuality').value);
          formData.append('copies', document.getElementById('copies').value);
          formData.append('layout_type', document.getElementById('layoutType').value);
          formData.append('print_medium', document.getElementById('printMedium').value);
          formData.append('patient_name', patientMatch ? patientMatch[1].trim() : 'Unknown Patient');
          formData.append('study_date', dateMatch ? dateMatch[1].trim() : '');
          formData.append('modality', modalityMatch ? modalityMatch[1].trim() : '');
          formData.append('series_description', currentSeries ? currentSeries.description || '' : '');
          formData.append('institution_name', 'Medical Facility'); // You can make this dynamic
         
         // Add CSRF token
         const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]')?.value || 
                          document.querySelector('meta[name="csrf-token"]')?.getAttribute('content') ||
                          getCookie('csrftoken');
         if (csrfToken) {
           formData.append('csrfmiddlewaretoken', csrfToken);
         }
         
         // Submit print job
         const submitBtn = document.getElementById('submitPrint');
         const originalText = submitBtn.innerHTML;
         submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Printing...';
         submitBtn.disabled = true;
         
         const response = await fetch('/dicom-viewer/print/image/', {
           method: 'POST',
           body: formData
         });
         
         const result = await response.json();
         
         if (result.success) {
           console.log('Print success:', result.message);
           showToast('Print job sent successfully', 'success');
           printModal.style.display = 'none';
         } else {
           console.error('Print error:', result.error);
           showToast('Print failed', 'error');
         }
         
                } catch(e) {
           console.error('Error printing image:', e.message);
         } finally {
         // Reset button
         const submitBtn = document.getElementById('submitPrint');
         submitBtn.innerHTML = '<i class="fas fa-print"></i> Print Image';
         submitBtn.disabled = false;
       }
     });

    // Clean toast notification system
    function showToast(message, type = 'info', duration = 3000) {
      const toast = document.createElement('div');
      toast.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: var(--card-surface);
        border: 1px solid var(--border-color);
        border-left: 4px solid var(--accent-color);
        color: var(--text-primary);
        padding: 8px 12px;
        border-radius: 3px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        z-index: 2000;
        font-size: 11px;
        max-width: 280px;
        transform: translateX(100%);
        transition: transform 0.3s ease;
        opacity: 0.95;
      `;
      
      if (type === 'error') {
        toast.style.borderLeftColor = 'var(--danger-color)';
      } else if (type === 'success') {
        toast.style.borderLeftColor = 'var(--success-color)';
      } else if (type === 'warning') {
        toast.style.borderLeftColor = 'var(--warning-color)';
      }
      
      toast.innerHTML = `
        <div style="display: flex; align-items: center; gap: 6px;">
          <i class="fas fa-${type === 'success' ? 'check' : type === 'error' ? 'exclamation-triangle' : 'info-circle'}" style="font-size: 10px;"></i>
          <span>${message}</span>
        </div>
      `;
      
      document.body.appendChild(toast);
      
      // Slide in
      setTimeout(() => {
        toast.style.transform = 'translateX(0)';
      }, 10);
      
      // Auto-remove
      setTimeout(() => {
        toast.style.transform = 'translateX(100%)';
        setTimeout(() => {
          if (toast.parentNode) {
            toast.remove();
          }
        }, 300);
      }, duration);
    }

    // Utils
    function loadImage(src){
      return new Promise((res, rej)=>{ 
        const im = new Image(); 
        im.decoding='async'; 
        im.onload=()=>{
          if (im.width > 0 && im.height > 0) {
            res(im);
          } else {
            rej(new Error('Invalid image dimensions'));
          }
        }; 
        im.onerror=(e)=>{
          console.error('Image load error:', e, 'src:', src);
          rej(e);
        }; 
        im.src=src; 
      });
    }
    function mprKey(seriesId, plane, sliceIndex, wwVal, wlVal, inv){
      return `${seriesId}|${plane}|${sliceIndex}|${Math.round(wwVal)}|${Math.round(wlVal)}|${inv?1:0}`;
    }
    async function getMprImage(seriesId, plane, sliceIndex){
      const key = mprKey(seriesId, plane, sliceIndex, ww, wl, inverted);
      if (mprImageCache.has(key)){
        const val = mprImageCache.get(key);
        return (typeof val?.then === 'function') ? await val : val;
      }
      const url = `/dicom-viewer/api/series/${seriesId}/mpr/?plane=${encodeURIComponent(plane)}&slice=${sliceIndex}&window_width=${Math.round(ww)}&window_level=${Math.round(wl)}&inverted=${inverted}`;
      const pending = fetch(url)
        .then(r=>{ if(!r.ok) throw new Error('mpr fetch failed'); return r.json(); })
        .then(j=>{ if(!j || !j.image) throw new Error('no mpr image'); return j.image; })
        .then(img=>{ mprImageCache.set(key, img); return img; })
        .catch(err=>{ mprImageCache.delete(key); throw err; });
      mprImageCache.set(key, pending);
      return await pending;
    }
    function prefetchMprSlices(plane, centerSlice, radius=3){
      if (!currentSeries || !mprScroll || !mprScroll.counts) return;
      const total = Math.max(0, (mprScroll.counts[plane]||0));
      if (!total) return;
      for (let o = -radius; o <= radius; o++){
        if (o === 0) continue;
        const s = centerSlice + o;
        if (s < 0 || s >= total) continue;
        const key = mprKey(currentSeries.id, plane, s, ww, wl, inverted);
        if (mprImageCache.has(key)) continue;
        // Fire-and-forget; cache will store promise/result
        getMprImage(currentSeries.id, plane, s).catch(err=>{ console.error('Failed to prefetch MPR image:', plane, s, err); });
      }
    }
    
    // 3D viewer for bone mesh
    let three = { renderer:null, scene:null, camera:null, controls:null };
    function disposeSceneObjects(){
      if (!three.scene) return;
      const toRemove = [];
      three.scene.traverse(obj=>{ if (obj.isMesh) {
        if (obj.geometry) obj.geometry.dispose();
        if (obj.material) {
          if (Array.isArray(obj.material)) obj.material.forEach(m=>m.dispose()); else obj.material.dispose();
        }
        toRemove.push(obj);
      }});
      toRemove.forEach(obj=> three.scene.remove(obj));
    }
    let threeAnimId = null;
    function showBone3D(meshData){
      try {
        const container = document.getElementById('threeContainer');
        const mount = document.getElementById('threeMount');
        container.style.display = 'block';
        // init three only once
        if (!three.renderer){
          three.renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer:false, powerPreference:'high-performance' });
          three.renderer.setSize(mount.clientWidth, mount.clientHeight);
          mount.appendChild(three.renderer.domElement);
          three.scene = new THREE.Scene();
          three.scene.background = new THREE.Color(0x000000);
          three.camera = new THREE.PerspectiveCamera(45, mount.clientWidth/mount.clientHeight, 0.1, 10000);
          three.camera.position.set(0, 0, 400);
          three.controls = new window.OrbitControls(three.camera, three.renderer.domElement);
          const light1 = new THREE.DirectionalLight(0xffffff, 1.0); light1.position.set(1,1,1); three.scene.add(light1);
          const light2 = new THREE.AmbientLight(0x444444); three.scene.add(light2);
          const onResize3D = ()=>{
            if (!three.renderer) return;
            three.renderer.setSize(mount.clientWidth, mount.clientHeight);
            three.camera.aspect = mount.clientWidth/mount.clientHeight; three.camera.updateProjectionMatrix();
          };
          window.addEventListener('resize', onResize3D, { passive: true });
          three._onResize3D = onResize3D;
        } else {
          disposeSceneObjects();
        }
        // build geometry with enhanced quality
        const vertices = new Float32Array(meshData.vertices.flat());
        const indices = new Uint32Array(meshData.faces.flat());
        const geom = new THREE.BufferGeometry();
        geom.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
        geom.setIndex(new THREE.BufferAttribute(indices, 1));
        geom.computeVertexNormals();
        
        // Enhanced material for better bone visualization
        const material = new THREE.MeshPhongMaterial({ 
          color: 0xf5f5dc,  // Bone color
          specular: 0x222222, 
          shininess: 50,
          transparent: false,
          side: THREE.DoubleSide  // Show both sides for better visibility
        });
        const mesh = new THREE.Mesh(geom, material);
        // center & scale
        geom.computeBoundingSphere();
        const bs = geom.boundingSphere; if (bs){ mesh.position.sub(bs.center); const target = 150; const s = bs.radius>0 ? target/bs.radius : 1; mesh.scale.setScalar(s); }
        three.scene.add(mesh);
        // animate (single RAF loop)
        if (threeAnimId) cancelAnimationFrame(threeAnimId);
        const animate = ()=>{ if (!three.renderer || container.style.display === 'none') return; three.controls.update(); three.renderer.render(three.scene, three.camera); threeAnimId = requestAnimationFrame(animate); };
        animate();
        document.getElementById('close3d').onclick = ()=>{ 
          if (threeAnimId) { cancelAnimationFrame(threeAnimId); threeAnimId = null; }
          disposeSceneObjects();
          if (three._onResize3D) { window.removeEventListener('resize', three._onResize3D); }
          container.style.display='none'; 
        };
      } catch(e){ console.warn('3D setup failed', e); }
    }
 
     // Debug function for 3D troubleshooting
    window.debug3D = function() {
      console.log('=== 3D Debug Info ===');
      console.log('MPR Mode:', mprMode);
      console.log('MPR Images:', mprImgs);
      console.log('MPR Cross:', mprCross);
      console.log('MPR Scroll:', mprScroll);
      console.log('MPR Region VPs:', mprRegionVps);
      console.log('Current Series:', currentSeries);
      console.log('Reconstruction Mode:', reconMode);
      console.log('Reconstruction Images:', reconImgs);
      console.log('===================');
    };

    // Init
     setCanvasSize();
     const studyId = q('study_id');
     if (studyId) loadStudy(studyId);

     // Unit selector wiring
     const unitSelect = document.getElementById('unitSelect');
     const unitVal = document.getElementById('unitVal');
     if (unitSelect){
             unitSelect.addEventListener('change', ()=>{
        measureUnit = unitSelect.value === 'cm' ? 'cm' : 'mm';
        unitVal.textContent = measureUnit;
        // Recompute labels for current measurements (series view)
        measurements = (measurements||[]).map(m=>{
          if (m && m.start && m.end){
            const dist = imageDistance(m.start, m.end);
            if (dist.mm){
              const mm = dist.mm; const cm = mm/10.0;
              m.label = (measureUnit==='cm') ? `${cm.toFixed(2)} cm` : `${mm.toFixed(2)} mm`;
            }
          }
          return m;
        });
        // Recompute MPR measurement labels
        ['axial','sagittal','coronal'].forEach(plane=>{
          mprMeasurements[plane] = (mprMeasurements[plane]||[]).map(m=>{
            if (m && m.start && m.end){
              const dist = mprImageDistance(plane, m.start, m.end);
              if (dist.mm){
                const mm = dist.mm; const cm = mm/10.0;
                m.label = (measureUnit==='cm') ? `${cm.toFixed(2)} cm` : `${mm.toFixed(2)} mm`;
              }
            }
            return m;
          });
        });
        renderMeasurementsList();
        requestDraw();
      });
     }

     document.getElementById('mprMeasurePlane').addEventListener('change', (e)=>{ mprMeasurePlaneMode = e.target.value; });
     document.getElementById('mprMeasureType').addEventListener('change', (e)=>{ mprMeasureType = e.target.value; });

     // Preset handlers
     if (btnSavePreset) btnSavePreset.addEventListener('click', async()=>{
       try {
         const name = `Preset_${Date.now()}`; // Auto-generate preset name
         const payload = { name, modality: (currentStudy&&currentStudy.modality)||'', window_width: ww, window_level: wl, inverted };
         await fetch('/dicom-viewer/api/presets/', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
         showToast('Preset saved', 'success', 2000);
       } catch(_){}
     });
     if (btnLoadPreset) btnLoadPreset.addEventListener('click', async()=>{
       try {
         const r = await fetch(`/dicom-viewer/api/presets/?modality=${encodeURIComponent((currentStudy&&currentStudy.modality)||'')}`);
         const j = await r.json();
         const presets = (j.presets||[]);
         if (!presets.length) return;
         // Load the most recent preset automatically
         const p = presets[presets.length - 1];
         ww = p.window_width; wl = p.window_level; inverted = !!p.inverted; wwSlider.value=ww; wlSlider.value=wl; wwNum.value=Math.round(ww); wlNum.value=Math.round(wl); document.getElementById('wwVal').textContent = Math.round(ww); document.getElementById('wlVal').textContent = Math.round(wl); imageCache.clear(); mprImageCache.clear(); mprImgs = { axial:null, sagittal:null, coronal:null }; requestDraw();
         showToast(`Preset "${p.name}" loaded`, 'success', 2000);
       } catch(_){}
     });

     // AI 3D Print functionality
     async function handleAI3DPrint() {
       if (!currentSeries) {
         showToast('No series loaded', 'error', 3000);
         return;
       }
       
       try {
         showToast('Generating AI 3D print model...', 'info', 3000);
         
         const response = await fetch(`/dicom-viewer/api/ai-3d-print/${currentSeries.id}/`, {
           method: 'POST',
           headers: {
             'Content-Type': 'application/json',
             'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
           },
           body: JSON.stringify({
             quality: 'high',
             format: 'stl',
             ai_enhanced: true
           })
         });
         
         if (response.ok) {
           const result = await response.json();
           if (result.success) {
             showToast('AI 3D print model ready for download', 'success', 5000);
             // Create download link
             const a = document.createElement('a');
             a.href = result.download_url;
             a.download = result.filename;
             a.click();
           } else {
             showToast(result.error || 'AI 3D print generation failed', 'error', 5000);
           }
         } else {
           showToast('AI 3D print service unavailable', 'error', 5000);
         }
       } catch (error) {
         console.error('AI 3D Print error:', error);
         showToast('Error generating AI 3D print model', 'error', 5000);
       }
     }

     // Advanced Reconstruction functionality
     async function handleAdvancedReconstruction() {
       if (!currentSeries) {
         showToast('No series loaded', 'error', 3000);
         return;
       }
       
       try {
         showToast('Running advanced reconstruction...', 'info', 3000);
         
         const response = await fetch(`/dicom-viewer/api/advanced-reconstruction/${currentSeries.id}/`, {
           method: 'POST',
           headers: {
             'Content-Type': 'application/json',
             'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
           },
           body: JSON.stringify({
             reconstruction_type: 'ai_enhanced',
             include_mpr: true,
             include_mip: true,
             include_volume_rendering: true
           })
         });
         
         if (response.ok) {
           const result = await response.json();
           if (result.success) {
             showToast('Advanced reconstruction completed', 'success', 5000);
             
             // Display reconstructed images
             if (result.reconstructions) {
               reconMode = 'advanced';
               reconImgs = result.reconstructions;
               reconIndex = 0;
               requestDraw();
             }
           } else {
             showToast(result.error || 'Advanced reconstruction failed', 'error', 5000);
           }
         } else {
           showToast('Advanced reconstruction service unavailable', 'error', 5000);
         }
       } catch (error) {
         console.error('Advanced Reconstruction error:', error);
         showToast('Error running advanced reconstruction', 'error', 5000);
       }
     }

     // Enhanced crosshair functionality
     let crosshairEnabled = false;
     let crosshairPosition = { x: 0, y: 0 };

     function toggleCrosshair() {
       crosshairEnabled = !crosshairEnabled;
       crosshair = crosshairEnabled;
       
       const crosshairBtn = document.querySelector('[data-tool="crosshair"]');
       if (crosshairEnabled) {
         crosshairBtn.classList.add('active');
         showToast('Crosshair enabled', 'info', 2000);
       } else {
         crosshairBtn.classList.remove('active');
         showToast('Crosshair disabled', 'info', 2000);
       }
       
       requestDraw();
     }

     // Enhanced canvas mouse interaction for crosshair
     canvas.addEventListener('mousemove', (e) => {
       if (crosshairEnabled && !mprMode) {
         const rect = canvas.getBoundingClientRect();
         crosshairPosition.x = e.clientX - rect.left;
         crosshairPosition.y = e.clientY - rect.top;
         requestDraw();
       }
     });

     // Override the existing draw function to include crosshair rendering
     const originalDraw = draw;
     draw = async function() {
       await originalDraw();
       
       if (crosshairEnabled && !mprMode && !reconMode) {
         // Draw crosshair overlay
         ctx.save();
         ctx.strokeStyle = 'rgba(0, 212, 255, 0.8)';
         ctx.lineWidth = 1;
         ctx.setLineDash([5, 5]);
         
         // Vertical line
         ctx.beginPath();
         ctx.moveTo(crosshairPosition.x, 0);
         ctx.lineTo(crosshairPosition.x, canvas.height);
         ctx.stroke();
         
         // Horizontal line
         ctx.beginPath();
         ctx.moveTo(0, crosshairPosition.y);
         ctx.lineTo(canvas.width, crosshairPosition.y);
         ctx.stroke();
         
         ctx.restore();
       }
     };

     })();
 </script>

<!-- Button Handler Scripts -->
{% load static %}
<script src="{% static 'js/button-utils.js' %}"></script>
<script src="{% static 'js/dicom-viewer-utils.js' %}"></script>
<script src="{% static 'js/worklist-button-handlers.js' %}"></script>

</body>
</html>